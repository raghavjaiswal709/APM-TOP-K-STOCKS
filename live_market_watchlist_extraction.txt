================================================================================
LIVE MARKET AND WATCHLIST FILES EXTRACTION
Generated on: 11-07-2025  9:48:09.20
================================================================================

CATEGORIES:
Current Live Market Implementation (3 files)
WatchlistSelector Component (3 files)
Reference Implementations (2 files)
Hooks and Data Management (2 files)
Backend API (3 files)

TOTAL: 13 FILES
================================================================================


================================================================================
FILE: apps/frontend/app/live-market/page.tsx
CATEGORY: Current Live Market Implementation
================================================================================

'use client';
import React, { useState, useEffect, useCallback } from 'react';
import { AppSidebar } from "../components/app-sidebar";
import {
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
  BreadcrumbSeparator,
} from "@/components/ui/breadcrumb";
import { Separator } from "@/components/ui/separator";
import {
  SidebarInset,
  SidebarProvider,
  SidebarTrigger,
} from "@/components/ui/sidebar";
import { ModeToggle } from "../components/toggleButton";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
// import { Alert, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import LiveMarketGrid from './components/LiveMarketGrid';
import CompanySelector from './components/CompanySelector';
import { useLiveMarket } from '../../hooks/useLiveMarket';
import { Info, Activity, Users, TrendingUp } from 'lucide-react';

const LiveMarketPage: React.FC = () => {
  const {
    availableCompanies,
    selectedCompanies,
    marketData,
    marketStatus,
    connectionStatus,
    error,
    loading,
    subscribeToCompanies,
    unsubscribeAll,
    isConnected
  } = useLiveMarket();

  const [selectedCompanyCodes, setSelectedCompanyCodes] = useState<string[]>([]);

  const handleCompanySelection = useCallback((companyCodes: string[]) => {
    setSelectedCompanyCodes(companyCodes);
    if (companyCodes.length > 0) {
      subscribeToCompanies(companyCodes);
    } else {
      unsubscribeAll();
    }
  }, [subscribeToCompanies, unsubscribeAll]);

  const handleClearSelection = useCallback(() => {
    setSelectedCompanyCodes([]);
    unsubscribeAll();
  }, [unsubscribeAll]);

  return (
    <SidebarProvider>
      <AppSidebar />
      <SidebarInset>
        <header className="flex h-16 shrink-0 items-center gap-2 w-full">
          <div className="flex items-center gap-2 px-4">
            <SidebarTrigger className="-ml-1" />
            <Separator orientation="vertical" className="mr-2 h-4" />
            <Breadcrumb className="flex items-center justify-end gap-2">
              <BreadcrumbList>
                <BreadcrumbItem className="hidden md:block">
                  <BreadcrumbLink href="#">
                    Building Your Application
                  </BreadcrumbLink>
                </BreadcrumbItem>
                <BreadcrumbSeparator className="hidden md:block" />
                <BreadcrumbItem>
                  <BreadcrumbPage>Live Market Grid</BreadcrumbPage>
                </BreadcrumbItem>
              </BreadcrumbList>
              <ModeToggle />
            </Breadcrumb>
          </div>
        </header>
        
        <div className="flex flex-1 flex-col gap-4 p-4 pt-0">
          {/* Header Card */}
          <Card className="w-full">
            <CardHeader>
              <div className="flex items-center justify-between">
                <div>
                  <CardTitle className="flex items-center gap-2">
                    <TrendingUp className="h-5 w-5" />
                    Live Market Data Grid
                  </CardTitle>
                  <p className="text-sm text-muted-foreground mt-1">
                    Monitor real-time market data for up to 6 companies simultaneously
                  </p>
                </div>
                <div className="flex items-center gap-4">
                  <div className="flex items-center gap-2">
                    <div className={`w-2 h-2 rounded-full ${
                      isConnected ? 'bg-green-500' : 'bg-red-500'
                    }`} />
                    <span className="text-sm font-medium">
                      {isConnected ? 'Connected' : 'Disconnected'}
                    </span>
                  </div>
                  {marketStatus?.is_trading_hours && (
                    <Badge variant="default" className="bg-green-100 text-green-800">
                      <Activity className="w-3 h-3 mr-1" />
                      Market Open
                    </Badge>
                  )}
                  {!marketStatus?.is_trading_hours && !marketStatus?.is_weekend && (
                    <Badge variant="secondary">
                      Market Closed
                    </Badge>
                  )}
                  {marketStatus?.is_weekend && (
                    <Badge variant="outline">
                      Weekend
                    </Badge>
                  )}
                </div>
              </div>
            </CardHeader>
            <CardContent>
              {/* Connection Status Alert */}
              {/* {error && (
                <Alert className="mb-4">
                  <Info className="h-4 w-4" />
                  <AlertDescription>
                    {error}
                  </AlertDescription>
                </Alert>
              )} */}

              {/* Company Selection */}
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <h3 className="text-lg font-medium">Select Companies (1-6)</h3>
                  {selectedCompanyCodes.length > 0 && (
                    <Button 
                      variant="outline" 
                      size="sm" 
                      onClick={handleClearSelection}
                    >
                      Clear Selection
                    </Button>
                  )}
                </div>
                
                <CompanySelector
                  availableCompanies={availableCompanies}
                  selectedCompanies={selectedCompanyCodes}
                  onSelectionChange={handleCompanySelection}
                  maxSelection={6}
                  loading={loading}
                />

                {/* Selection Summary */}
                {selectedCompanyCodes.length > 0 && (
                  <div className="flex items-center gap-4 text-sm text-muted-foreground">
                    <div className="flex items-center gap-1">
                      <Users className="w-4 h-4" />
                      <span>{selectedCompanies.length} companies selected</span>
                    </div>
                    <div className="flex items-center gap-1">
                      <Activity className="w-4 h-4" />
                      <span>{Object.keys(marketData).length} receiving data</span>
                    </div>
                  </div>
                )}
              </div>
            </CardContent>
          </Card>

          {/* Live Market Grid */}
          {selectedCompanyCodes.length > 0 && (
            <LiveMarketGrid
              selectedCompanies={selectedCompanies}
              marketData={marketData}
              connectionStatus={connectionStatus}
              loading={loading}
            />
          )} 

          {/* No Selection State */}
          {selectedCompanyCodes.length === 0 && (
            <Card className="w-full">
              <CardContent className="flex flex-col items-center justify-center py-12">
                <TrendingUp className="h-12 w-12 text-muted-foreground mb-4" />
                <h3 className="text-lg font-medium mb-2">No Companies Selected</h3>
                <p className="text-sm text-muted-foreground text-center max-w-md">
                  Select 1-6 companies from watchlist A above to start monitoring their real-time market data in an interactive grid layout.
                </p>
              </CardContent>
            </Card>
          )}
        </div>
      </SidebarInset>
    </SidebarProvider>
  );
};

export default LiveMarketPage;


================================================================================
FILE: apps/frontend/app/live-market/components/CompanySelector.tsx
CATEGORY: Current Live Market Implementation
================================================================================

'use client';
import React, { useState, useMemo } from 'react';
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Card, CardContent } from "@/components/ui/card";
import { Search, X, Check, Building2 } from 'lucide-react';

interface Company {
  company_code: string;
  name: string;
  exchange: string;
  marker: string;
  symbol: string;
}

interface CompanySelectorProps {
  availableCompanies: Company[];
  selectedCompanies: string[];
  onSelectionChange: (companyCodes: string[]) => void;
  maxSelection: number;
  loading?: boolean;
}

const CompanySelector: React.FC<CompanySelectorProps> = ({
  availableCompanies,
  selectedCompanies,
  onSelectionChange,
  maxSelection,
  loading = false
}) => {
  const [searchTerm, setSearchTerm] = useState('');

  const filteredCompanies = useMemo(() => {
    if (!searchTerm) return availableCompanies;
    
    const term = searchTerm.toLowerCase();
    return availableCompanies.filter(company =>
      company.company_code.toLowerCase().includes(term) ||
      company.name.toLowerCase().includes(term)
    );
  }, [availableCompanies, searchTerm]);

  const handleCompanyToggle = (companyCode: string) => {
    const isSelected = selectedCompanies.includes(companyCode);
    
    if (isSelected) {
      // Remove from selection
      const newSelection = selectedCompanies.filter(code => code !== companyCode);
      onSelectionChange(newSelection);
    } else {
      // Add to selection if under limit
      if (selectedCompanies.length < maxSelection) {
        const newSelection = [...selectedCompanies, companyCode];
        onSelectionChange(newSelection);
      }
    }
  };

  const handleClearAll = () => {
    onSelectionChange([]);
  };

  const isSelectionFull = selectedCompanies.length >= maxSelection;

  return (
    <div className="space-y-4">
      {/* Search */}
      <div className="relative">
        <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
        <Input
          placeholder="Search companies..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="pl-8"
        />
      </div>

      {/* Selected Companies Tags */}
      {selectedCompanies.length > 0 && (
        <div className="space-y-2">
          <div className="flex items-center justify-between">
            <span className="text-sm font-medium">
              Selected ({selectedCompanies.length}/{maxSelection})
            </span>
            {selectedCompanies.length > 0 && (
              <Button
                variant="ghost"
                size="sm"
                onClick={handleClearAll}
                className="h-6 px-2 text-xs"
              >
                Clear All
              </Button>
            )}
          </div>
          <div className="flex flex-wrap gap-2">
            {selectedCompanies.map((companyCode) => {
              const company = availableCompanies.find(c => c.company_code === companyCode);
              return (
                <Badge
                  key={companyCode}
                  variant="default"
                  className="flex items-center gap-1 pr-1"
                >
                  <Building2 className="w-3 h-3" />
                  <span>{company?.company_code || companyCode}</span>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => handleCompanyToggle(companyCode)}
                    className="h-4 w-4 p-0 hover:bg-transparent"
                  >
                    <X className="w-3 h-3" />
                  </Button>
                </Badge>
              );
            })}
          </div>
        </div>
      )}

      {/* Available Companies Grid */}
      <Card>
        <CardContent className="p-4">
          <div className="flex items-center justify-between mb-3">
            <span className="text-sm font-medium">Available Companies</span>
            <span className="text-xs text-muted-foreground">
              {filteredCompanies.length} companies
            </span>
          </div>
          
          <ScrollArea className="h-64 w-full">
            {loading ? (
              <div className="flex items-center justify-center h-32">
                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
              </div>
            ) : (
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2">
                {filteredCompanies.map((company) => {
                  const isSelected = selectedCompanies.includes(company.company_code);
                  const canSelect = !isSelected && !isSelectionFull;
                  
                  return (
                    <Button
                      key={company.company_code}
                      variant={isSelected ? "default" : "outline"}
                      size="sm"
                      onClick={() => handleCompanyToggle(company.company_code)}
                      disabled={!canSelect && !isSelected}
                      className={`justify-start h-auto p-3 ${
                        isSelected ? 'bg-primary text-primary-foreground' : ''
                      }`}
                    >
                      <div className="flex items-center gap-2 w-full">
                        <div className="flex-shrink-0">
                          {isSelected ? (
                            <Check className="w-4 h-4" />
                          ) : (
                            <Building2 className="w-4 h-4" />
                          )}
                        </div>
                        <div className="flex-1 text-left overflow-hidden">
                          <div className="font-medium text-xs">
                            {company.company_code}
                          </div>
                          <div className="text-xs opacity-70 truncate">
                            {company.name}
                          </div>
                          <div className="text-xs opacity-50">
                            {company.exchange}
                          </div>
                        </div>
                      </div>
                    </Button>
                  );
                })}
              </div>
            )}
          </ScrollArea>
          
          {isSelectionFull && (
            <div className="mt-3 p-2 bg-yellow-50 border border-yellow-200 rounded text-xs text-yellow-800">
              Maximum {maxSelection} companies selected. Remove a company to select another.
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
};

export default CompanySelector;


================================================================================
FILE: apps/frontend/app/live-market/components/LiveMarketGrid.tsx
CATEGORY: Current Live Market Implementation
================================================================================

'use client';
import React, { useMemo } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import GridChart from './GridChart';
import { TrendingUp, TrendingDown, Activity, Wifi, WifiOff } from 'lucide-react';

interface Company {
  company_code: string;
  name: string;
  exchange: string;
  marker: string;
  symbol: string;
}

interface MarketData {
  symbol: string;
  ltp: number;
  change?: number;
  changePercent?: number;
  open?: number;
  high?: number;
  low?: number;
  close?: number;
  volume?: number;
  timestamp: number;
}

interface LiveMarketGridProps {
  selectedCompanies: Company[];
  marketData: Record<string, MarketData>;
  connectionStatus: string;
  loading?: boolean;
}

const LiveMarketGrid: React.FC<LiveMarketGridProps> = ({
  selectedCompanies,
  marketData,
  connectionStatus,
  loading = false
}) => {
  const gridLayout = useMemo(() => {
    const count = selectedCompanies.length;
    
    switch (count) {
      case 1:
        return 'grid-cols-1';
      case 2:
        return 'grid-cols-1 lg:grid-cols-2';
      case 3:
        return 'grid-cols-1 lg:grid-cols-3';
      case 4:
        return 'grid-cols-1 md:grid-cols-2';
      case 5:
        return 'grid-cols-1 md:grid-cols-2 lg:grid-cols-3';
      case 6:
        return 'grid-cols-1 md:grid-cols-2 lg:grid-cols-3';
      default:
        return 'grid-cols-1';
    }
  }, [selectedCompanies.length]);

  const formatPrice = (price?: number) => {
    return price ? `₹${price.toFixed(2)}` : '₹0.00';
  };

  const formatChange = (change?: number, percent?: number) => {
    if (change === undefined || percent === undefined) return '--';
    const sign = change >= 0 ? '+' : '';
    return `${sign}${change.toFixed(2)} (${sign}${percent.toFixed(2)}%)`;
  };

  const getChangeColor = (change?: number) => {
    if (change === undefined) return 'text-muted-foreground';
    return change >= 0 ? 'text-green-600' : 'text-red-600';
  };

  const getChangeIcon = (change?: number) => {
    if (change === undefined) return <Activity className="w-4 h-4" />;
    return change >= 0 ? <TrendingUp className="w-4 h-4" /> : <TrendingDown className="w-4 h-4" />;
  };

  return (
    <div className="space-y-4">
      {/* Grid Status */}
      <div className="flex items-center justify-between">
        <h2 className="text-lg font-semibold">Live Market Grid</h2>
        <div className="flex items-center gap-2 text-sm">
          {connectionStatus === 'Connected' ? (
            <>
              <Wifi className="w-4 h-4 text-green-500" />
              <span className="text-green-600">Live Data</span>
            </>
          ) : (
            <>
              <WifiOff className="w-4 h-4 text-red-500" />
              <span className="text-red-600">Disconnected</span>
            </>
          )}
        </div>
      </div>

      {/* Companies Grid */}
      <div className={`grid ${gridLayout} gap-4`}>
        {selectedCompanies.map((company) => {
          const data = marketData[company.symbol];
          const hasData = !!data;
          
          return (
            <Card key={company.company_code} className="overflow-hidden">
              <CardHeader className="pb-2">
                <div className="flex items-center justify-between">
                  <div>
                    <CardTitle className="text-lg">{company.company_code}</CardTitle>
                    <p className="text-sm text-muted-foreground truncate">
                      {company.name}
                    </p>
                  </div>
                  <Badge variant={hasData ? "default" : "secondary"} className="text-xs">
                    {company.exchange}
                  </Badge>
                </div>
              </CardHeader>
              
              <CardContent className="space-y-4">
                {/* Price Information */}
                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <span className="text-2xl font-bold">
                      {formatPrice(data?.ltp)}
                    </span>
                    <div className={`flex items-center gap-1 text-sm ${getChangeColor(data?.change)}`}>
                      {getChangeIcon(data?.change)}
                      <span className="font-medium">
                        {formatChange(data?.change, data?.changePercent)}
                      </span>
                    </div>
                  </div>
                  
                  {/* OHLC Data */}
                  {hasData && (
                    <div className="grid grid-cols-4 gap-2 text-xs">
                      <div className="text-center">
                        <div className="text-muted-foreground">Open</div>
                        <div className="font-medium">{formatPrice(data.open)}</div>
                      </div>
                      <div className="text-center">
                        <div className="text-muted-foreground">High</div>
                        <div className="font-medium text-green-600">{formatPrice(data.high)}</div>
                      </div>
                      <div className="text-center">
                        <div className="text-muted-foreground">Low</div>
                        <div className="font-medium text-red-600">{formatPrice(data.low)}</div>
                      </div>
                      <div className="text-center">
                        <div className="text-muted-foreground">Volume</div>
                        <div className="font-medium">{data.volume?.toLocaleString() || '0'}</div>
                      </div>
                    </div>
                  )}
                </div>

                {/* Chart */}
                <div className="h-96 bg-muted/20 rounded border">
                  {hasData ? (
                    <GridChart
                      symbol={company.symbol}
                      data={data}
                      company={company}
                    />
                  ) : (
                    <div className="flex items-center justify-center h-full text-muted-foreground">
                      {loading ? (
                        <div className="flex flex-col items-center gap-2">
                          <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary"></div>
                          <span className="text-sm">Loading data...</span>
                        </div>
                      ) : (
                        <div className="flex flex-col items-center gap-2">
                          <WifiOff className="w-8 h-8" />
                          <span className="text-sm">No data</span>
                        </div>
                      )}
                    </div>
                  )}
                </div>

                {/* Last Updated */}
                {hasData && (
                  <div className="text-xs text-muted-foreground text-center">
                    Last updated: {new Date(data.timestamp * 1000).toLocaleTimeString()}
                  </div>
                )}
              </CardContent>
            </Card>
          );
        })}
      </div>
    </div>
  );
};

export default LiveMarketGrid;


================================================================================
FILE: apps/frontend/app/components/controllers/WatchlistSelector/index.tsx
CATEGORY: WatchlistSelector Component
================================================================================

// src/components/WatchlistSelector/index.tsx
export { WatchlistSelector } from './WatchlistSelector';


================================================================================
FILE: apps/frontend/app/components/controllers/WatchlistSelector/WatchlistSelector.tsx
CATEGORY: WatchlistSelector Component
================================================================================

'use client'
import * as React from "react";
import { useWatchlist } from "@/hooks/useWatchlist";
import { RadioGroupDemo } from "./RadioGroup";
import { SelectScrollable } from "./SelectScrollable";

interface WatchlistSelectorProps {
  onCompanySelect?: (companyCode: string | null, exchange?: string, marker?: string) => void;
  selectedWatchlist?: string;
  onWatchlistChange?: (watchlist: string) => void;
  showExchangeFilter?: boolean;
  showMarkerFilter?: boolean;
}

export const WatchlistSelector = React.memo(({ 
  onCompanySelect,
  selectedWatchlist: externalSelectedWatchlist,
  onWatchlistChange,
  showExchangeFilter = true,
  showMarkerFilter = true
}: WatchlistSelectorProps) => {
  
  const [currentWatchlist, setCurrentWatchlist] = React.useState(() => 
    externalSelectedWatchlist || 'A'
  );
  
  const prevExternalWatchlist = React.useRef(externalSelectedWatchlist);
  
  React.useEffect(() => {
    if (externalSelectedWatchlist && 
        externalSelectedWatchlist !== prevExternalWatchlist.current && 
        externalSelectedWatchlist !== currentWatchlist) {
      console.log(`[WatchlistSelector] External watchlist changed to: ${externalSelectedWatchlist}`);
      prevExternalWatchlist.current = externalSelectedWatchlist;
      setCurrentWatchlist(externalSelectedWatchlist);
    }
  }, [externalSelectedWatchlist, currentWatchlist]);

  const {
    selectedWatchlist,
    setSelectedWatchlist,
    companies,
    loading,
    error,
    exists,
    availableExchanges,
    availableMarkers,
    totalCompanies,
    getFilteredCompanies
  } = useWatchlist({ externalWatchlist: currentWatchlist });
  
  const [selectedExchange, setSelectedExchange] = React.useState<string>('');
  const [selectedMarker, setSelectedMarker] = React.useState<string>('');
  
  const handleWatchlistChange = React.useCallback((value: string) => {
    console.log(`[WatchlistSelector] Watchlist changed to: ${value}`);
    
    if (value === currentWatchlist) {
      return;
    }
    
    setSelectedExchange('');
    setSelectedMarker('');
    
    setCurrentWatchlist(value);
    
    if (onWatchlistChange) {
      onWatchlistChange(value);
    }
  }, [currentWatchlist, onWatchlistChange]);

  const handleCompanySelect = React.useCallback((companyCode: string | null) => {
    if (!companyCode) {
      if (onCompanySelect) {
        onCompanySelect(null);
      }
      return;
    }

    const selectedCompany = companies.find(c => c.company_code === companyCode);
    
    console.log(`[WatchlistSelector] Selected company: ${companyCode}`, selectedCompany);
    
    if (onCompanySelect && selectedCompany) {
      onCompanySelect(companyCode, selectedCompany.exchange, selectedCompany.marker);
    }
  }, [companies, onCompanySelect]);

  const filteredCompanies = React.useMemo(() => {
    const filters: any = {};
    if (selectedExchange) filters.exchange = selectedExchange;
    if (selectedMarker) filters.marker = selectedMarker;
    
    const filtered = getFilteredCompanies(filters);
    console.log(`[WatchlistSelector] Filtered companies: ${filtered.length} out of ${companies.length}`);
    return filtered;
  }, [companies, selectedExchange, selectedMarker, getFilteredCompanies]);

  const handleExchangeChange = React.useCallback((e: React.ChangeEvent<HTMLSelectElement>) => {
    setSelectedExchange(e.target.value);
    setSelectedMarker('');
  }, []);

  const handleMarkerChange = React.useCallback((e: React.ChangeEvent<HTMLSelectElement>) => {
    setSelectedMarker(e.target.value);
  }, []);

  console.log(`[WatchlistSelector] Render - currentWatchlist: ${currentWatchlist}, selectedWatchlist: ${selectedWatchlist}, companies: ${companies.length}, loading: ${loading}`);

  return (
    <div className="flex gap-4">
      {/* Watchlist Selection */}
      <div className="flex gap-5 items-center">
        <div className="flex flex-col gap-1">
          <label className="text-sm font-medium">Watchlist</label>
          <RadioGroupDemo
            value={currentWatchlist} 
            onChange={handleWatchlistChange}
          />
          <div className="flex flex-col gap-2">
         <div className="flex gap-4 text-xs text-muted-foreground">
  <div>
    {loading && `Loading watchlist ${currentWatchlist}...`}
    {!loading && exists && `${totalCompanies} companies (${currentWatchlist})`}
    {!loading && !exists && `No data available for watchlist ${currentWatchlist}`}
  </div>
  {/* {availableExchanges.length > 0 && (
    <div>
      Exchanges: {availableExchanges.join(', ')}
    </div>
  )} */}
</div>

         
        </div>
        </div>
        
        {/* Status Information */}
        
      </div>

      {/* Filters */}
      {/* Filters */}
{(showExchangeFilter || showMarkerFilter) && availableExchanges.length > 0 && (
  <div className="flex flex-col gap-2 justify-center">
    {/* Exchange Filter */}
    {showExchangeFilter && (
      <div className="flex flex-col">
        <select
          value={selectedExchange}
          onChange={handleExchangeChange}
          className="px-2 py-1 text-xs border rounded m-0"
        >
          <option value="">All Exchanges</option>
          {availableExchanges.map(exchange => (
            <option key={exchange} value={exchange}>
              {exchange}
            </option>
          ))}
        </select>
      </div>
    )}

    {/* Marker Filter */}
    {showMarkerFilter && availableMarkers.length > 0 && (
      <div className="flex flex-col">
        <select
          value={selectedMarker}
          onChange={handleMarkerChange}
          className="px-2 py-1 text-xs border rounded m-0"
        >
          <option value="">All Markers</option>
          {availableMarkers.map(marker => (
            <option key={marker} value={marker}>
              {marker}
            </option>
          ))}
        </select>
      </div>
    )}

    {/* Filter Results Count - Only render when there's content */}
    {filteredCompanies.length !== companies.length && (
      <div className="text-xs text-muted-foreground">
        {`${filteredCompanies.length} of ${companies.length} shown`}
      </div>
    )}
  </div>
)}


      {/* Error Display */}
      {error && (
        <div className="text-destructive text-xs bg-destructive/10 px-2 py-1 rounded">
          {error}
        </div>
      )}
      
      {/* Company Selection */}
      <div>
        <SelectScrollable
          companies={filteredCompanies}
          loading={loading}
          exists={exists}
          onCompanySelect={handleCompanySelect}
        />
      </div>
    </div>
  );
});

WatchlistSelector.displayName = 'WatchlistSelector';


================================================================================
FILE: apps/frontend/app/components/controllers/WatchlistSelector/SelectScrollable.tsx
CATEGORY: WatchlistSelector Component
================================================================================

"use client"

import * as React from "react"
import { Check, ChevronsUpDown, Building2, TrendingUp, Search } from "lucide-react"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"

interface MergedCompany {
  company_id?: number;
  company_code: string;
  name: string;
  exchange: string;
  marker: string;
  total_valid_days?: number;
  avg_daily_high_low_range?: number;
  median_daily_volume?: number;
  avg_trading_capital?: number;
  pe_ratio?: number;
  N1_Pattern_count?: number;
}

interface SelectScrollableProps {
  companies: MergedCompany[];
  loading: boolean;
  exists: boolean;
  onCompanySelect: (companyCode: string | null) => void;
}

export function SelectScrollable({ 
  companies, 
  loading, 
  exists, 
  onCompanySelect 
}: SelectScrollableProps) {
  const [open, setOpen] = React.useState(false)
  const [value, setValue] = React.useState("")
  const [selectedCompany, setSelectedCompany] = React.useState<MergedCompany | null>(null)
  const [searchTerm, setSearchTerm] = React.useState("")

  React.useEffect(() => {
    console.log(`[SelectScrollable] Companies changed, resetting selection. New count: ${companies.length}`);
    setValue("")
    setSelectedCompany(null)
    setSearchTerm("")
    setOpen(false)
    onCompanySelect(null)
  }, [companies, onCompanySelect]);

  React.useEffect(() => {
    const handleClickOutside = () => {
      if (open) {
        setOpen(false)
        setSearchTerm("")
      }
    }

    if (open) {
      document.addEventListener('click', handleClickOutside)
      return () => document.removeEventListener('click', handleClickOutside)
    }
  }, [open])

  const handleSelect = (company: MergedCompany) => {
    console.log(`[SelectScrollable] handleSelect called with company:`, company);
    
    if (value === company.company_code) {
      console.log(`[SelectScrollable] Deselecting company: ${company.company_code}`);
      setValue("")
      setSelectedCompany(null)
      onCompanySelect(null)
    } else {
      console.log(`[SelectScrollable] Selecting company: ${company.company_code}`);
      setValue(company.company_code)
      setSelectedCompany(company)
      onCompanySelect(company.company_code)
    }
    setOpen(false)
    setSearchTerm("")
  }

  const handleButtonClick = (e: React.MouseEvent) => {
    e.stopPropagation()
    setOpen(!open)
    if (!open) {
      setSearchTerm("")
    }
  }

  const formatCompanyDisplay = (company: MergedCompany) => {
    return `${company.company_code} - ${company.name}`;
  };

  const formatCompanyDetails = (company: MergedCompany) => {
    const details = [];
    if (company.exchange) details.push(company.exchange);
    if (company.marker) details.push(company.marker);
    if (company.total_valid_days) details.push(`${company.total_valid_days} days`);
    return details.join(' • ');
  };

  const filteredCompanies = React.useMemo(() => {
    if (!searchTerm) return companies;
    const searchLower = searchTerm.toLowerCase();
    return companies.filter(company =>
      company.company_code.toLowerCase().includes(searchLower) ||
      company.name.toLowerCase().includes(searchLower) ||
      company.exchange.toLowerCase().includes(searchLower) ||
      company.marker.toLowerCase().includes(searchLower)
    );
  }, [companies, searchTerm]);

   if (loading) {
    return (
      <div className="flex items-center gap-2 px-3 py-2 text-sm text-muted-foreground min-h-[40px]">
        <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-gray-900"></div>
        Loading companies...
      </div>
    );
  }

  if (!exists || companies.length === 0) {
    return (
      <div className="flex items-center gap-2 px-3 py-2 text-sm text-muted-foreground min-h-[40px]">
        <Building2 className="h-4 w-4" />
        {!exists ? 'Watchlist not available' : 'No companies found'}
      </div>
    );
  }

  return (
    <div className="flex gap-3 items-center w-full">

      <div className="relative">
        <Button
          variant="outline"
          onClick={handleButtonClick}
          className="w-[350px] justify-between h-20" 
        >
          {selectedCompany ? (
            <div className="flex items-center gap-2 min-w-0">
              <Building2 className="h-4 w-4 flex-shrink-0" />
              <span className="truncate">
                {formatCompanyDisplay(selectedCompany)}
              </span>
            </div>
          ) : (
            <span className="text-muted-foreground">
              Select company... ({companies.length} available)
            </span>
          )}
          <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
        </Button>

        {open && (
          <div 
            className="absolute top-full left-0 right-0 z-50 mt-1 bg-background border border-border rounded-md shadow-lg max-h-[500px] overflow-hidden"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="p-2 border-b border-border">
              <div className="relative">
                <Search className="absolute left-2 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                <Input
                  placeholder="Search companies..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  className="pl-8 h-8"
                  autoFocus
                  onClick={(e) => e.stopPropagation()}
                />
              </div>
              {filteredCompanies.length !== companies.length && (
                <div className="text-xs text-muted-foreground mt-1">
                  {`Showing ${filteredCompanies.length} of ${companies.length} companies`}
                </div>
              )}
            </div>

            <div className="overflow-y-auto max-h-[250px]">
              {filteredCompanies.length === 0 ? (
                <div className="p-3 text-sm text-muted-foreground text-center">
                  {searchTerm ? 'No companies match your search' : 'No companies found'}
                </div>
              ) : (
                filteredCompanies.map((company, index) => {
                  const uniqueKey = `${company.company_code}-${company.exchange}-${index}`;
                  const isSelected = value === company.company_code;
                  
                  return (
                    <div
                      key={uniqueKey}
                      onClick={(e) => {
                        e.stopPropagation();
                        handleSelect(company);
                      }}
                      className={cn(
                        "flex flex-col gap-1 p-3 cursor-pointer hover:bg-accent transition-colors border-b border-border last:border-b-0",
                        isSelected && "bg-accent"
                      )}
                    >
                      <div className="flex items-center justify-between w-full">
                        <div className="flex items-center gap-2 min-w-0">
                          <Check
                            className={cn(
                              "h-4 w-4 flex-shrink-0",
                              isSelected ? "opacity-100 text-primary" : "opacity-0"
                            )}
                          />
                          <Building2 className="h-4 w-4 text-muted-foreground flex-shrink-0" />
                          <span className="font-medium">
                            {company.company_code}
                          </span>
                        </div>
                        {company.N1_Pattern_count !== undefined && company.N1_Pattern_count > 0 && (
                          <div className="flex items-center gap-1 text-xs text-green-600 flex-shrink-0">
                            <TrendingUp className="h-3 w-3" />
                            {company.N1_Pattern_count}
                          </div>
                        )}
                      </div>
                      <div className="text-sm text-muted-foreground truncate w-full ml-6">
                        {company.name}
                      </div>
                      <div className="text-xs text-muted-foreground ml-6">
                        {formatCompanyDetails(company)}
                      </div>
                    </div>
                  );
                })
              )}
            </div>
          </div>
        )}
      </div>

     
<div className="min-h-[96px] flex items-center"> 
  {selectedCompany && (
    <div className="p-3 bg-muted/50 rounded-md h-20 border border-border w-[250px] overflow-hidden"> 
      <div className="h-full flex flex-col justify-center ">
        <div className="flex items-center justify-between mb-1">
          <h4 className="font-medium text-sm truncate flex-1 mr-2">{selectedCompany.company_code}</h4>
          <div className="flex items-center gap-1 flex-shrink-0">
            <span className="bg-blue-100 text-blue-800 px-1.5 py-0.5 rounded text-xs font-medium">
              {selectedCompany.exchange}
            </span>
            <span className="bg-green-100 text-green-800 px-1.5 py-0.5 rounded text-xs font-medium">
              {selectedCompany.marker}
            </span>
          </div>
        </div>
        
        <p className="text-xs text-muted-foreground mb-2 truncate">
          {selectedCompany.name}
        </p>
        
        {(selectedCompany.total_valid_days || selectedCompany.median_daily_volume || selectedCompany.pe_ratio) && (
          <div className="grid grid-cols-2 gap-x-4 gap-y-1 text-xs">
            {selectedCompany.total_valid_days && (
              <div className="flex  items-center gap-2">
                <span className="text-muted-foreground text-xs">Days:</span>
                <span className="font-medium text-xs">{selectedCompany.total_valid_days}</span>
              </div>
            )}
            {selectedCompany.median_daily_volume && (
              <div className="flex items-center gap-2">
                <span className="text-muted-foreground text-xs">Vol:</span>
                <span className="font-medium text-xs">{(selectedCompany.median_daily_volume / 1000).toFixed(0)}K</span>
              </div>
            )}
            {selectedCompany.pe_ratio && (
              <div className="flex items-center gap-2">
                <span className="text-muted-foreground text-xs">P/E:</span>
                <span className="font-medium text-xs">{selectedCompany.pe_ratio.toFixed(1)}</span>
              </div>
            )}
            {selectedCompany.N1_Pattern_count !== undefined && (
              <div className="flex items-center gap-2">
                <span className="text-muted-foreground text-xs">N1:</span>
                <span className="font-medium text-xs flex items-center gap-1">
                  {selectedCompany.N1_Pattern_count}
                  {selectedCompany.N1_Pattern_count > 0 && <TrendingUp className="h-3 w-3 text-green-600" />}
                </span>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  )}
</div>

    </div>
  );
}


================================================================================
FILE: apps/frontend/app/dashboard/page.tsx
CATEGORY: Reference Implementations
================================================================================

'use client'
import { useState, useEffect, useCallback } from 'react';
import { usePathname } from 'next/navigation';
import { AppSidebar } from "../components/app-sidebar";
import {
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
  BreadcrumbSeparator,
} from "@/components/ui/breadcrumb";
import { Separator } from "@/components/ui/separator";
import {
  SidebarInset,
  SidebarProvider,
  SidebarTrigger,
} from "@/components/ui/sidebar";
import { Card, CardContent } from "@/components/ui/card";
import { ModeToggle } from "../components/toggleButton";
import { CardWithForm } from "../components/options";
import { StockChart } from "../components/charts/StockChart";
import { CalendarForm } from "../components/controllers/CalendarForm";
import { useWatchlist } from "@/hooks/useWatchlist";
import { useStockData } from "@/hooks/useStockData";

import dynamic from 'next/dynamic';
const MarketDataPage = dynamic(() => import('../market-data/page'), { 
  ssr: false,
  loading: () => (
    <div className="flex items-center justify-center h-[80vh]">
      <div className="animate-pulse text-blue-500">Loading market data...</div>
    </div>
  )
});

export default function Page() {
  const pathname = usePathname();
  const isMarketDataRoute = pathname?.includes('/market-data');
  
  const [selectedCompany, setSelectedCompany] = useState<string | null>(null);
  const [selectedExchange, setSelectedExchange] = useState<string | null>(null);
  const [selectedWatchlist, setSelectedWatchlist] = useState('A');
  const [selectedInterval, setSelectedInterval] = useState('1h');
  const [selectedIndicators, setSelectedIndicators] = useState<string[]>([]);
  const [selectedStartDate, setSelectedStartDate] = useState<Date | undefined>();
  const [selectedEndDate, setSelectedEndDate] = useState<Date | undefined>();
  
  const { 
    companies, 
    loading: watchlistLoading, 
    error: watchlistError,
    selectedWatchlist: currentWatchlist,
    setSelectedWatchlist: setWatchlist,
    exists: watchlistExists
  } = useWatchlist();
  
  const { 
    data: stockData, 
    loading: stockLoading, 
    error: stockError, 
    dataRange,
  loadDataForRange,
    fetchData, 
    fetchAllData, 
    clearData 
  } = useStockData({
    companyCode: selectedCompany,  
    exchange: selectedExchange,          
    interval: selectedInterval,
    indicators: selectedIndicators,
     enableIncrementalLoading: true
  });

  const pageTitle = isMarketDataRoute ? "Market Data" : "Historical Data";

  const handleCompanyChange = useCallback((companyCode: string | null, exchange?: string) => {
    console.log(`Selected: ${companyCode} (${exchange})`);
    setSelectedCompany(companyCode);
    setSelectedExchange(exchange || null);
    clearData();
  }, [clearData]);

  const handleDateRangeChange = useCallback((startDate: Date | undefined, endDate: Date | undefined) => {
    setSelectedStartDate(startDate);
    setSelectedEndDate(endDate);
    clearData();
  }, [clearData]);

  const handleFetchData = useCallback(() => {
    if (selectedCompany && selectedStartDate) {
      console.log('Fetching data with date range:', selectedStartDate, selectedEndDate);
      fetchData(selectedStartDate, selectedEndDate);
    }
  }, [selectedCompany, selectedStartDate, selectedEndDate, fetchData]);

  const handleFetchAllData = useCallback(() => {
    if (selectedCompany) {
      console.log('Fetching all available data for company:', selectedCompany);
      fetchAllData();
    }
  }, [selectedCompany, fetchAllData]);

  const handleIntervalChange = useCallback((newInterval: string) => {
    console.log('Interval changed from', selectedInterval, 'to', newInterval);
    setSelectedInterval(newInterval);
  }, [selectedInterval]);

  const handleIndicatorsChange = useCallback((indicators: string[]) => {
    setSelectedIndicators(indicators);
  }, []);
  const handleRangeChange = async (startDate: Date, endDate: Date) => {
  try {
    const response = await fetch(`/api/companies/${selectedCompany}/ohlcv?` + new URLSearchParams({
      startDate: startDate.toISOString(),
      endDate: endDate.toISOString(),
      interval: selectedInterval,
      exchange: 'NSE'
    }));
    
    const newData = await response.json();
  } catch (error) {
    console.error('Error fetching range data:', error);
  }
};

  const handleWatchlistChange = useCallback((watchlist: string) => {
    setSelectedWatchlist(watchlist);
    setWatchlist(watchlist);
    setSelectedCompany(null); 
    clearData();
  }, [setWatchlist, clearData]);

  useEffect(() => {
    if (selectedCompany && !selectedStartDate) {
      console.log('Auto-fetching all data for newly selected company:', selectedCompany);
      handleFetchAllData();
    }
  }, [selectedCompany, selectedStartDate, handleFetchAllData]);

  useEffect(() => {
    if (selectedCompany && stockData.length > 0) {
      console.log('Interval changed, refetching data for company:', selectedCompany);
      if (!selectedStartDate) {
        handleFetchAllData();
      } else {
        handleFetchData();
      }
    }
  }, [selectedInterval, selectedCompany, stockData.length, selectedStartDate, handleFetchAllData, handleFetchData]);

  useEffect(() => {
    const styleElement = document.createElement('style');
    styleElement.innerHTML = `
      :root {
        --popover: 0 0% 3.9%;
        --popover-foreground: 0 0% 98%;
      }
      
      .select-content {
        background-color: hsl(0 0% 3.9%) !important;
        color: hsl(0 0% 98%) !important;
        border: 1px solid hsl(0 0% 14.9%) !important;
      }
      
      [data-radix-select-viewport] {
        background-color: hsl(0 0% 3.9%) !important;
      }
      
      [data-radix-select-item] {
        color: hsl(0 0% 98%) !important;
      }
      
      [data-radix-select-item]:focus {
        background-color: hsl(0 0% 14.9%) !important;
      }
    `;
    
    document.head.appendChild(styleElement);
    
    return () => {
      document.head.removeChild(styleElement);
    };
  }, []);

  return (
    <SidebarProvider>
      <AppSidebar />
      <SidebarInset>
        <header className="flex h-16 shrink-0 items-center gap-2 w-full">
          <div className="flex items-center gap-2 px-4">
            <SidebarTrigger className="-ml-1" />
            <Separator orientation="vertical" className="mr-2 h-4" />
            <Breadcrumb className="flex items-center justify-end gap-2">
              <BreadcrumbList>
                <BreadcrumbItem className="hidden md:block">
                  <BreadcrumbLink href="#">
                    Dashboard
                  </BreadcrumbLink>
                </BreadcrumbItem>
                <BreadcrumbSeparator className="hidden md:block" />
                <BreadcrumbItem>
                  <BreadcrumbPage>{pageTitle}</BreadcrumbPage>
                </BreadcrumbItem>
              </BreadcrumbList>
              <ModeToggle />
            </Breadcrumb>
          </div>
        </header>
        
        <div className="flex flex-1 flex-col gap-4 p-4 pt-0">
          {isMarketDataRoute ? (
            <MarketDataPage />
          ) : (
            <>
              <Card className="w-full ">
                <CardContent className="p-4">
                  <div className="flex gap-4 items-center justify-between w-full">
                    <CardWithForm 
                      onCompanyChange={handleCompanyChange} 
                      onDateRangeChange={handleDateRangeChange}
                      onFetchData={handleFetchData}
                      onIntervalChange={handleIntervalChange}
                      onIndicatorsChange={handleIndicatorsChange}
                      selectedWatchlist={selectedWatchlist}
                      onWatchlistChange={handleWatchlistChange} 
                      loading={stockLoading}
                    />
                    
                    <div className="p-3 border border-opacity-30 rounded-md h-24 flex items-center justify-end w-fit mr-4">
                      <CalendarForm 
                        onDateRangeChange={handleDateRangeChange}
                        onFetchData={handleFetchData}
                        onFetchAllData={handleFetchAllData}
                        loading={stockLoading}
                      />
                    </div>
                    
                    {stockError && (
                      <div className="bg-red-50 border border-red-200 text-red-700 px-3 py-2 rounded-md text-sm">
                        ❌ {stockError}
                      </div>
                    )}
                  </div>
                </CardContent>
              </Card>
              
              <div className="min-h-[500px] flex-1 rounded-xl bg-muted/50">
                <StockChart 
                  companyId={selectedCompany}  
                  exchange={selectedExchange}  
                  data={stockData}
                  startDate={selectedStartDate}
                  endDate={selectedEndDate}
                  interval={selectedInterval}
                  onIntervalChange={handleIntervalChange}
                  indicators={selectedIndicators}
                  loading={stockLoading}
                  error={stockError}
onRangeChange={handleRangeChange}
                />
              </div>
              
              {/* <Card className="w-full border border-opacity-30 h-[400px] overflow-hidden">
                <CardContent className="p-4">
                  <div className="flex justify-between items-center mb-2">
                    <h3 className="text-lg font-medium">Watchlist {selectedWatchlist} Companies</h3>
                    <div className="flex items-center gap-2">
                      <span className="text-sm text-muted-foreground">
                        {watchlistLoading ? 'Loading...' : `${companies.length} companies`}
                      </span>
                      {selectedCompany && (
                        <button
                          onClick={() => handleCompanyChange(null)}
                          className="text-xs bg-red-100 text-red-700 px-2 py-1 rounded hover:bg-red-200 transition-colors"
                        >
                          Clear Selection
                        </button>
                      )}
                    </div>
                  </div>
                  
                  <div className="h-[340px] overflow-y-auto pr-2">
                    {watchlistError ? (
                      <div className="flex items-center justify-center h-full text-destructive">
                        {watchlistError}
                      </div>
                    ) : watchlistLoading ? (
                      <div className="grid grid-cols-1 gap-2 animate-pulse">
                        {[...Array(9)].map((_, i) => (
                          <div key={i} className="h-8 bg-muted rounded"></div>
                        ))}
                      </div>
                    ) : companies.length === 0 ? (
                      <div className="flex items-center justify-center h-full text-muted-foreground">
                        No companies in this watchlist
                      </div>
                    ) : (
                      <div className="grid grid-cols-1 gap-2">
                        {companies.map((company) => (
                          <div 
                            key={company.company_code}
                            className={`p-2 rounded-md text-sm cursor-pointer transition-colors
                              ${selectedCompany === company.company_code 
                                ? 'bg-primary text-primary-foreground shadow-md' 
                                : 'bg-secondary hover:bg-secondary/80'}`}
                            onClick={() => handleCompanyChange(company.company_code, company.exchange)}
                          >
                            <div className="font-medium truncate">{company.name}</div>
                            <div className="text-xs opacity-80 truncate">
                              {company.company_code} ({company.exchange})
                            </div>
                            {selectedCompany === company.company_code && (
                              <div className="text-xs mt-1 opacity-90">
                                {stockData.length > 0 ? `${stockData.length} data points loaded` : 'Click "Fetch All Data" to load'}
                              </div>
                            )}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                </CardContent>
              </Card> */}
            </>
          )}
        </div>
      </SidebarInset>
    </SidebarProvider>
  );
}


================================================================================
FILE: apps/frontend/app/market-data/page.tsx
CATEGORY: Reference Implementations
================================================================================

'use client';
import React, { useEffect, useState, useCallback } from 'react';
import { getSocket } from '@/lib/socket';
import dynamic from 'next/dynamic';
import { AppSidebar } from "../components/app-sidebar";
import {
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
  BreadcrumbSeparator,
} from "@/components/ui/breadcrumb";
import { Separator } from "@/components/ui/separator";
import {
  SidebarInset,
  SidebarProvider,
  SidebarTrigger,
} from "@/components/ui/sidebar";
import { ModeToggle } from "../components/toggleButton";
import { Card, CardContent } from "@/components/ui/card";
import { WatchlistSelector } from "../components/controllers/WatchlistSelector";
import { useWatchlist } from "@/hooks/useWatchlist";

const PlotlyChart = dynamic(() => import('./components/charts/PlotlyChart'), { 
  ssr: false,
  loading: () => (
    <div className="w-full h-full flex items-center justify-center bg-zinc-900">
      <div className="animate-pulse text-blue-500">Loading chart...</div>
    </div>
  )
});

interface MarketData {
  symbol: string;
  ltp: number;
  change?: number;
  changePercent?: number;
  open?: number;
  high?: number;
  low?: number;
  close?: number;
  volume?: number;
  bid?: number;
  ask?: number;
  timestamp: number;
  sma_20?: number;
  ema_9?: number;
  rsi_14?: number;
}

interface OHLCData {
  timestamp: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
}

interface TradingHours {
  start: string;
  end: string;
  current: string;
  isActive: boolean;
}

const MarketDataPage: React.FC = () => {
  const [isClient, setIsClient] = useState(false);
  const [selectedSymbol, setSelectedSymbol] = useState<string>('');
  const [selectedCompany, setSelectedCompany] = useState<string | null>(null);
  const [selectedExchange, setSelectedExchange] = useState<string | null>(null);
  const [selectedWatchlist, setSelectedWatchlist] = useState('A');
  
  const [marketData, setMarketData] = useState<Record<string, MarketData>>({});
  const [historicalData, setHistoricalData] = useState<Record<string, MarketData[]>>({});
  const [ohlcData, setOhlcData] = useState<Record<string, OHLCData[]>>({});
  
  const [socketStatus, setSocketStatus] = useState<string>('Disconnected');
  const [lastDataReceived, setLastDataReceived] = useState<Date | null>(null);
  const [dataCount, setDataCount] = useState<number>(0);
  const [tradingHours, setTradingHours] = useState<TradingHours>({
    start: '',
    end: '',
    current: '',
    isActive: false
  });

  const { 
    companies, 
    loading: watchlistLoading, 
    error: watchlistError,
    selectedWatchlist: currentWatchlist,
    setSelectedWatchlist: setWatchlist,
    exists: watchlistExists
  } = useWatchlist();

  const validateAndFormatSymbol = useCallback((companyCode: string, exchange: string, marker: string = 'EQ'): string => {
    const cleanSymbol = companyCode.replace(/[^A-Z0-9]/g, '').toUpperCase();
    
    if (!cleanSymbol || cleanSymbol.length === 0) {
      return '';
    }
    
    switch (exchange.toUpperCase()) {
      case 'NSE':
        return `NSE:${cleanSymbol}-${marker}`;
      case 'BSE':
        return `BSE:${cleanSymbol}-${marker}`;
      default:
        return `${exchange}:${cleanSymbol}-${marker}`;
    }
  }, []);

  const handleCompanyChange = useCallback((companyCode: string | null, exchange?: string, marker?: string) => {
    console.log(`[MarketData] Company selected: ${companyCode} (${exchange}, ${marker})`);
    
    setSelectedCompany(companyCode);
    setSelectedExchange(exchange || null);
    
    if (companyCode && exchange) {
      const formattedSymbol = validateAndFormatSymbol(companyCode, exchange, marker);
      console.log(`[MarketData] Formatted symbol: ${formattedSymbol}`);
      setSelectedSymbol(formattedSymbol);
    } else {
      setSelectedSymbol('');
    }
  }, [validateAndFormatSymbol]);

  const handleWatchlistChange = useCallback((watchlist: string) => {
    console.log(`[MarketData] Watchlist changed to: ${watchlist}`);
    setSelectedWatchlist(watchlist);
    setWatchlist(watchlist);
    setSelectedCompany(null);
    setSelectedSymbol('');
  }, [setWatchlist]);

  useEffect(() => {
    if (companies.length > 0 && !selectedCompany) {
      const firstCompany = companies[0];
      console.log(`[MarketData] Auto-selecting first company: ${firstCompany.company_code}`);
      handleCompanyChange(firstCompany.company_code, firstCompany.exchange, firstCompany.marker);
    }
  }, [companies, selectedCompany, handleCompanyChange]);

  useEffect(() => {
    setIsClient(true);
    console.log('Component mounted, isClient set to true');
  }, []);

  useEffect(() => {
    if (!isClient) return;

    console.log('Connecting to Python WebSocket server...');
    
    const socket = getSocket();

    socket.on('connect', () => {
      console.log('✅ Connected to Python WebSocket server');
      console.log('Socket ID:', socket.id);
      setSocketStatus('Connected');
      
      socket.emit('get_trading_status', {}, (response: any) => {
        console.log('Trading status:', response);
        setTradingHours({
          start: response.trading_start,
          end: response.trading_end,
          current: response.current_time,
          isActive: response.trading_active
        });
      });
      
      if (selectedSymbol && selectedSymbol.includes(':') && selectedSymbol.includes('-')) {
        console.log('Subscribing to validated symbol:', selectedSymbol);
        socket.emit('subscribe', { symbol: selectedSymbol });
      }
    });

    socket.on('connect_error', (error) => {
      console.error('❌ Connection error:', error.message);
      setSocketStatus(`Connection error: ${error.message}`);
    });

    socket.on('disconnect', (reason) => {
      console.log('❌ Disconnected from Python WebSocket server. Reason:', reason);
      setSocketStatus(`Disconnected: ${reason}`);
    });

    socket.on('marketData', (data: MarketData) => {
      console.log('📊 Received market data:', data);
      setLastDataReceived(new Date());
      setDataCount(prev => prev + 1);
      
      if (data && data.symbol) {
        setMarketData(prev => ({
          ...prev,
          [data.symbol]: data
        }));
        
        setHistoricalData(prev => {
          const symbol = data.symbol;
          const existingHistory = prev[symbol] || [];
          
          const exists = existingHistory.some(item => item.timestamp === data.timestamp);
          if (exists) return prev;
          
          const newHistory = [...existingHistory, data];
          newHistory.sort((a, b) => a.timestamp - b.timestamp);
          
          return {
            ...prev,
            [symbol]: newHistory
          };
        });
      }
    });
    
    socket.on('historicalData', (data: { symbol: string, data: MarketData[] }) => {
      console.log('📈 Received historical data:', data);
      
      if (data && data.symbol && Array.isArray(data.data)) {
        const sortedData = [...data.data].sort((a, b) => a.timestamp - b.timestamp);
        
        setHistoricalData(prev => ({
          ...prev,
          [data.symbol]: sortedData
        }));
        
        console.log(`Processed ${sortedData.length} historical data points for ${data.symbol}`);
        
        if (marketData[data.symbol] && sortedData.length > 0) {
          const lastHistorical = sortedData[sortedData.length - 1];
          const current = marketData[data.symbol];
          
          if (lastHistorical.timestamp > current.timestamp) {
            setMarketData(prev => ({
              ...prev,
              [data.symbol]: lastHistorical
            }));
          }
        } else if (sortedData.length > 0) {
          setMarketData(prev => ({
            ...prev,
            [data.symbol]: sortedData[sortedData.length - 1]
          }));
        }
      }
    });

    socket.on('ohlcData', (data: { symbol: string, data: OHLCData[] }) => {
      console.log('📊 Received OHLC data:', data);
      
      if (data && data.symbol && Array.isArray(data.data)) {
        const sortedData = [...data.data].sort((a, b) => a.timestamp - b.timestamp);
        
        setOhlcData(prev => ({
          ...prev,
          [data.symbol]: sortedData
        }));
        
        console.log(`Processed ${sortedData.length} OHLC data points for ${data.symbol}`);
      }
    });
    
    socket.on('heartbeat', (data: any) => {
      setTradingHours(prev => ({
        ...prev,
        current: new Date().toISOString(),
        isActive: data.trading_active
      }));
    });

    const dataCheckInterval = setInterval(() => {
      const now = new Date();
      const lastReceived = lastDataReceived;
      
      if (!lastReceived || now.getTime() - lastReceived.getTime() > 10000) {
        console.warn('⚠️ No market data received in the last 10 seconds');
        
        if (socket.connected && selectedSymbol) {
          console.log('🔄 Attempting to resubscribe to:', selectedSymbol);
          socket.emit('subscribe', { symbol: selectedSymbol });
        }
      }
    }, 5000);

    return () => {
      console.log('Component unmounting, cleaning up socket connection');
      clearInterval(dataCheckInterval);
      
      Object.keys(marketData).forEach(symbol => {
        console.log('🔕 Unsubscribing from:', symbol);
        socket.emit('unsubscribe', { symbol });
      });
    };
  }, [isClient, lastDataReceived, selectedSymbol]);

  useEffect(() => {
    if (!isClient) return;
    
    console.log('🔄 Symbol changed to:', selectedSymbol);
    const socket = getSocket();
    
    if (!socket.connected) {
      console.log('Socket not connected, waiting for connection...');
      return;
    }

    Object.keys(marketData).forEach(symbol => {
      if (symbol !== selectedSymbol) {
        console.log('🔕 Unsubscribing from:', symbol);
        socket.emit('unsubscribe', { symbol });
      }
    });
    
    if (selectedSymbol) {
      socket.emit('subscribe', { symbol: selectedSymbol });
      console.log('🔔 Subscribed to:', selectedSymbol);
    }
  }, [selectedSymbol, isClient]);

  const formatPrice = (price?: number) => {
    return price?.toFixed(2) || '0.00';
  };

  const formatChange = (change?: number, percent?: number) => {
    if ((!change && change !== 0) || (!percent && percent !== 0)) return '-';
    const sign = change >= 0 ? '+' : '';
    return `${sign}${change.toFixed(2)} (${sign}${percent.toFixed(2)}%)`;
  };

  const getChangeClass = (change?: number) => {
    if (!change && change !== 0) return '';
    return change >= 0 ? 'text-green-500' : 'text-red-500';
  };

  const currentData = marketData[selectedSymbol];
  const symbolHistory = historicalData[selectedSymbol] || [];
  const symbolOhlc = ohlcData[selectedSymbol] || [];

  if (!isClient) {
    return (
      <SidebarProvider>
        <AppSidebar />
        <SidebarInset>
          <header className="flex h-16 shrink-0 items-center gap-2 w-full">
            <div className="flex items-center gap-2 px-4">
              <SidebarTrigger className="-ml-1" />
              <Separator orientation="vertical" className="mr-2 h-4" />
              <Breadcrumb className="flex items-center justify-end gap-2">
                <BreadcrumbList>
                  <BreadcrumbItem className="hidden md:block">
                    <BreadcrumbLink href="#">
                      Building Your Application
                    </BreadcrumbLink>
                  </BreadcrumbItem>
                  <BreadcrumbSeparator className="hidden md:block" />
                  <BreadcrumbItem>
                    <BreadcrumbPage>Live Market Data</BreadcrumbPage>
                  </BreadcrumbItem>
                </BreadcrumbList>
                <ModeToggle />
              </Breadcrumb>
            </div>
          </header>
          <div className="flex flex-1 flex-col gap-4 p-4 pt-0">
            <div className="container mx-auto p-4 bg-zinc-900 text-white flex items-center justify-center h-[80vh]">
              <div className="text-xl animate-pulse">Loading market data...</div>
            </div>
          </div>
        </SidebarInset>
      </SidebarProvider>
    );
  }

  return (
    <SidebarProvider>
      <AppSidebar />
      <SidebarInset>
        <header className="flex h-16 shrink-0 items-center gap-2 w-full">
          <div className="flex items-center gap-2 px-4">
            <SidebarTrigger className="-ml-1" />
            <Separator orientation="vertical" className="mr-2 h-4" />
            <Breadcrumb className="flex items-center justify-end gap-2">
              <BreadcrumbList>
                <BreadcrumbItem className="hidden md:block">
                  <BreadcrumbLink href="#">
                    Building Your Application
                  </BreadcrumbLink>
                </BreadcrumbItem>
                <BreadcrumbSeparator className="hidden md:block" />
                <BreadcrumbItem>
                  <BreadcrumbPage>Live Market Data</BreadcrumbPage>
                </BreadcrumbItem>
              </BreadcrumbList>
              <ModeToggle />
            </Breadcrumb>
          </div>
        </header>
        
        <div className="flex flex-1 flex-col gap-4 p-4 pt-0">
          {/* Watchlist Selector Card - Same pattern as dashboard */}
          <Card className="w-full">
            <CardContent className="p-4">
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <h3 className="text-lg font-medium">Market Data Watchlist</h3>
                  <div className="flex items-center space-x-2">
                    <span className={`inline-block w-2 h-2 rounded-full ${
                      socketStatus.includes('Connected') ? 'bg-green-500' : 'bg-red-500'
                    }`}></span>
                    <span className="text-sm text-muted-foreground">{socketStatus}</span>
                  </div>
                </div>
                
                <WatchlistSelector
                  onCompanySelect={handleCompanyChange}
                  selectedWatchlist={selectedWatchlist}
                  onWatchlistChange={handleWatchlistChange}
                  showExchangeFilter={true}
                  showMarkerFilter={true}
                />
                
                {/* Status Information */}
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                  <div>
                    <span className="text-muted-foreground">Selected:</span>
                    <div className="font-medium">
                      {selectedCompany ? `${selectedCompany} (${selectedExchange})` : 'None'}
                    </div>
                  </div>
                  <div>
                    <span className="text-muted-foreground">Fyers Symbol:</span>
                    <div className="font-medium">{selectedSymbol || 'None'}</div>
                  </div>
                  <div>
                    <span className="text-muted-foreground">Market Status:</span>
                    <div className={`font-medium ${tradingHours.isActive ? 'text-green-500' : 'text-red-500'}`}>
                      {tradingHours.isActive ? 'Open' : 'Closed'}
                    </div>
                  </div>
                  <div>
                    <span className="text-muted-foreground">Data Points:</span>
                    <div className="font-medium">{symbolHistory.length} historical / {dataCount} updates</div>
                  </div>
                </div>

                {watchlistError && (
                  <div className="bg-red-50 border border-red-200 text-red-700 px-3 py-2 rounded-md text-sm">
                    ❌ {watchlistError}
                  </div>
                )}
              </div>
            </CardContent>
          </Card>

          {/* Market Data Display */}
          <div className="min-h-screen bg-zinc-900 text-zinc-100 rounded-lg">
            <div className="container mx-auto p-4">
              <div className="grid grid-cols-1 lg:grid-cols-4 gap-6 mb-6">
                <div className="lg:col-span-3">
                  <div className="bg-zinc-800 p-4 rounded-lg shadow-lg h-[600px]">
                    {symbolHistory.length > 0 ? (
                      <PlotlyChart 
                        symbol={selectedSymbol} 
                        data={currentData} 
                        historicalData={symbolHistory}
                        ohlcData={symbolOhlc}
                        tradingHours={tradingHours}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center">
                        <p className="text-zinc-400">
                          {selectedSymbol ? `Loading historical data for ${selectedSymbol}...` : 'Select a company to view market data'}
                        </p>
                      </div>
                    )}
                  </div>
                </div>
                
                {/* Market Data Panel */}
                <div className="bg-zinc-800 p-4 rounded-lg shadow-lg">
                  {currentData ? (
                    <>
                      <h2 className="text-xl font-semibold mb-2 text-white">{selectedSymbol}</h2>
                      <div className="text-3xl font-bold mb-2 text-white">₹{formatPrice(currentData.ltp)}</div>
                      <div className={`text-lg ${getChangeClass(currentData.change)}`}>
                        {formatChange(currentData.change, currentData.changePercent)}
                      </div>
                      
                      <div className="grid grid-cols-2 gap-4 mt-6">
                        <div className="bg-zinc-700 p-3 rounded">
                          <div className="text-xs text-zinc-400">Open</div>
                          <div className="text-lg">₹{formatPrice(currentData.open)}</div>
                        </div>
                        <div className="bg-zinc-700 p-3 rounded">
                          <div className="text-xs text-zinc-400">Prev Close</div>
                          <div className="text-lg">₹{formatPrice(currentData.close)}</div>
                        </div>
                        <div className="bg-zinc-700 p-3 rounded">
                          <div className="text-xs text-zinc-400">High</div>
                          <div className="text-lg">₹{formatPrice(currentData.high)}</div>
                        </div>
                        <div className="bg-zinc-700 p-3 rounded">
                          <div className="text-xs text-zinc-400">Low</div>
                          <div className="text-lg">₹{formatPrice(currentData.low)}</div>
                        </div>
                      </div>
                      
                      <div className="mt-6 border-t border-zinc-700 pt-4">
                        <div className="grid grid-cols-2 gap-y-2">
                          <div>
                            <div className="text-xs text-zinc-400">Bid</div>
                            <div>₹{formatPrice(currentData.bid)}</div>
                          </div>
                          <div>
                            <div className="text-xs text-zinc-400">Ask</div>
                            <div>₹{formatPrice(currentData.ask)}</div>
                          </div>
                          <div>
                            <div className="text-xs text-zinc-400">Volume</div>
                            <div>{currentData.volume?.toLocaleString() || '0'}</div>
                          </div>
                          <div>
                            <div className="text-xs text-zinc-400">Last Updated</div>
                            <div>{new Date(currentData.timestamp * 1000).toLocaleTimeString()}</div>
                          </div>
                        </div>
                      </div>
                      
                      {/* Technical Indicators */}
                      {(currentData.sma_20 || currentData.ema_9 || currentData.rsi_14) && (
                        <div className="mt-6 border-t border-zinc-700 pt-4">
                          <h3 className="text-sm font-medium mb-2 text-zinc-300">Technical Indicators</h3>
                          <div className="grid grid-cols-3 gap-2">
                            {currentData.sma_20 && (
                              <div className="bg-zinc-700 p-2 rounded">
                                <div className="text-xs text-orange-500">SMA 20</div>
                                <div className="text-sm">₹{formatPrice(currentData.sma_20)}</div>
                              </div>
                            )}
                            {currentData.ema_9 && (
                              <div className="bg-zinc-700 p-2 rounded">
                                <div className="text-xs text-purple-500">EMA 9</div>
                                <div className="text-sm">₹{formatPrice(currentData.ema_9)}</div>
                              </div>
                            )}
                            {currentData.rsi_14 && (
                              <div className="bg-zinc-700 p-2 rounded">
                                <div className="text-xs text-cyan-500">RSI 14</div>
                                <div className="text-sm">{currentData.rsi_14.toFixed(2)}</div>
                              </div>
                            )}
                          </div>
                        </div>
                      )}
                    </>
                  ) : (
                    <div className="text-center py-8">
                      <p className="text-zinc-400">
                        {selectedSymbol ? 'Waiting for market data...' : 'Select a company to view data'}
                      </p>
                    </div>
                  )}
                </div>
              </div>
              
              {/* Debug section */}
              <div className="mt-8 p-4 bg-zinc-800 rounded-lg shadow-lg">
                <div className="flex justify-between items-center mb-2">
                  <h3 className="text-lg font-semibold text-white">Raw Market Data</h3>
                  <div className="text-xs text-zinc-400">
                    {symbolHistory.length > 0 && tradingHours.start && (
                      <>
                        Trading Hours: {new Date(tradingHours.start).toLocaleTimeString()} - {new Date(tradingHours.end).toLocaleTimeString()}
                      </>
                    )}
                  </div>
                </div>
                {currentData ? (
                  <pre className="text-xs overflow-auto max-h-60 bg-zinc-900 p-4 rounded text-zinc-300">
                    {JSON.stringify(currentData, null, 2)}
                  </pre>
                ) : (
                  <p className="text-zinc-400">No data received yet. Check console for connection details.</p>
                )}
              </div>
            </div>
          </div>
        </div>
      </SidebarInset>
    </SidebarProvider>
  );
};

export default MarketDataPage;


================================================================================
FILE: apps/frontend/hooks/useLiveMarket.ts
CATEGORY: Hooks and Data Management
================================================================================

import { useState, useEffect, useCallback, useRef } from 'react';
import { io, Socket } from 'socket.io-client';

interface Company {
  company_code: string;
  name: string;
  exchange: string;
  marker: string;
  symbol: string;
}

interface MarketData {
  symbol: string;
  ltp: number;
  change?: number;
  changePercent?: number;
  open?: number;
  high?: number;
  low?: number;
  close?: number;
  volume?: number;
  timestamp: number;
}

interface MarketStatus {
  current_time: string;
  market_open: string;
  market_close: string;
  is_trading_hours: boolean;
  is_weekend: boolean;
  timezone: string;
}

export const useLiveMarket = () => {
  const [availableCompanies, setAvailableCompanies] = useState<Company[]>([]);
  const [selectedCompanies, setSelectedCompanies] = useState<Company[]>([]);
  const [marketData, setMarketData] = useState<Record<string, MarketData>>({});
  const [marketStatus, setMarketStatus] = useState<MarketStatus | null>(null);
  const [connectionStatus, setConnectionStatus] = useState<string>('Disconnected');
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [isConnected, setIsConnected] = useState<boolean>(false);

  const socketRef = useRef<Socket | null>(null);

  // Initialize socket connection
  useEffect(() => {
    const SOCKET_URL = process.env.NEXT_PUBLIC_LIVE_MARKET_SOCKET_URL || 'http://localhost:5010';
    
    console.log(`Connecting to Live Market WebSocket: ${SOCKET_URL}`);
    
    const socket = io(SOCKET_URL, {
      reconnectionAttempts: 5,
      reconnectionDelay: 2000,
      timeout: 10000,
      transports: ['websocket', 'polling']
    });

    socket.on('connect', () => {
      console.log('✅ Connected to Live Market WebSocket');
      setConnectionStatus('Connected');
      setIsConnected(true);
      setError(null);
    });

    socket.on('disconnect', (reason) => {
      console.log('❌ Disconnected from Live Market WebSocket:', reason);
      setConnectionStatus('Disconnected');
      setIsConnected(false);
    });

    socket.on('connect_error', (error) => {
      console.error('❌ Live Market WebSocket connection error:', error);
      setConnectionStatus('Connection Error');
      setIsConnected(false);
      setError(`Connection failed: ${error.message}`);
    });

    socket.on('availableSymbols', (data) => {
      console.log('📊 Received available symbols:', data);
      setAvailableCompanies(data.symbols || []);
      if (data.tradingHours) {
        setMarketStatus(data.tradingHours);
      }
    });

    socket.on('marketData', (data: MarketData) => {
      console.log('📈 Received market data:', data);
      setMarketData(prev => ({
        ...prev,
        [data.symbol]: data
      }));
    });

    socket.on('historicalData', (data: { symbol: string; data: MarketData[] }) => {
      console.log('📉 Received historical data:', data);
      // You can process historical data here if needed
    });

    socket.on('subscriptionConfirm', (data) => {
      console.log('✅ Subscription confirmed:', data);
      setLoading(false);
      setError(null);
    });

    socket.on('error', (data) => {
      console.error('❌ Server error:', data);
      setError(data.message);
      setLoading(false);
    });

    socket.on('heartbeat', (data) => {
      console.log('💓 Heartbeat:', data);
    });

    socket.on('fyersConnected', (data) => {
      console.log('🔗 Fyers connected:', data);
    });

    socket.on('fyersDisconnected', (data) => {
      console.log('🔗 Fyers disconnected:', data);
      setError('Fyers connection lost. Reconnecting...');
    });

    socketRef.current = socket;

    return () => {
      console.log('🧹 Cleaning up Live Market WebSocket connection');
      socket.disconnect();
      socketRef.current = null;
    };
  }, []);

  const subscribeToCompanies = useCallback((companyCodes: string[]) => {
    if (!socketRef.current || !socketRef.current.connected) {
      setError('Not connected to server');
      return;
    }

    setLoading(true);
    setError(null);

    console.log('📡 Subscribing to companies:', companyCodes);
    
    // Update selected companies
    const selectedComps = companyCodes.map(code => 
      availableCompanies.find(c => c.company_code === code)
    ).filter(Boolean) as Company[];
    
    setSelectedCompanies(selectedComps);

    // Send subscription request
    socketRef.current.emit('subscribe_companies', { companyCodes });
  }, [availableCompanies]);

  const unsubscribeAll = useCallback(() => {
    if (!socketRef.current || !socketRef.current.connected) {
      return;
    }

    console.log('📡 Unsubscribing from all companies');
    
    setSelectedCompanies([]);
    setMarketData({});
    
    socketRef.current.emit('unsubscribe_all', {});
  }, []);

  const getMarketStatus = useCallback(() => {
    if (!socketRef.current || !socketRef.current.connected) {
      return;
    }

    socketRef.current.emit('get_market_status', {});
  }, []);

  return {
    availableCompanies,
    selectedCompanies,
    marketData,
    marketStatus,
    connectionStatus,
    error,
    loading,
    isConnected,
    subscribeToCompanies,
    unsubscribeAll,
    getMarketStatus
  };
};


================================================================================
FILE: apps/frontend/hooks/useWatchlist.ts
CATEGORY: Hooks and Data Management
================================================================================

import { useState, useEffect, useRef, useCallback } from 'react';

interface MergedCompany {
  company_id?: number;
  company_code: string;
  name: string;
  exchange: string;
  marker: string;
  total_valid_days?: number;
  avg_daily_high_low_range?: number;
  median_daily_volume?: number;
  avg_trading_capital?: number;
  pe_ratio?: number;
  N1_Pattern_count?: number;
}

interface WatchlistResponse {
  companies: MergedCompany[];
  exists: boolean;
  total: number;
}

interface UseWatchlistOptions {
  externalWatchlist?: string;
}

export function useWatchlist(options: UseWatchlistOptions = {}) {
  const [selectedWatchlist, setSelectedWatchlist] = useState('A');
  const [companies, setCompanies] = useState<MergedCompany[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [exists, setExists] = useState(true);
  const [availableExchanges, setAvailableExchanges] = useState<string[]>([]);
  const [totalCompanies, setTotalCompanies] = useState(0);
  const [availableMarkers, setAvailableMarkers] = useState<string[]>([]);

  const prevExternalWatchlist = useRef(options.externalWatchlist);
  
  const activeWatchlist = options.externalWatchlist || selectedWatchlist;

  useEffect(() => {
    if (options.externalWatchlist && 
        options.externalWatchlist !== prevExternalWatchlist.current && 
        options.externalWatchlist !== selectedWatchlist) {
      console.log(`[useWatchlist] External watchlist changed from ${prevExternalWatchlist.current} to ${options.externalWatchlist}`);
      prevExternalWatchlist.current = options.externalWatchlist;
      setSelectedWatchlist(options.externalWatchlist);
    }
  }, [options.externalWatchlist, selectedWatchlist]);

  useEffect(() => {
    let isCancelled = false;
    
    async function fetchWatchlist() {
      console.log(`[useWatchlist] Starting to fetch watchlist: ${activeWatchlist}`);
      setLoading(true);
      setError(null);

      try {
        const today = "2025-06-05";
        const apiUrl = `http://localhost:5000/api/watchlist/${activeWatchlist}?date=${today}`;
        
        console.log(`[useWatchlist] Fetching from: ${apiUrl}`);

        try {
          const healthCheck = await fetch('http://localhost:5000/health', {
            method: 'GET',
            signal: AbortSignal.timeout(5000)
          });
          console.log(`[useWatchlist] Backend health check: ${healthCheck.status}`);
        } catch (healthError) {
          console.error(`[useWatchlist] Backend health check failed:`, healthError);
          throw new Error('Backend server is not running on localhost:3001. Please start the backend server.');
        }

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000);

        const response = await fetch(apiUrl, { 
          signal: controller.signal,
          method: 'GET',
          headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Cache-Control': 'no-cache'
          },
          mode: 'cors'
        });
        
        clearTimeout(timeoutId);

        console.log(`[useWatchlist] Response status: ${response.status}`);
        console.log(`[useWatchlist] Response headers:`, Object.fromEntries(response.headers.entries()));

        if (!response.ok) {
          const errorText = await response.text();
          console.error(`[useWatchlist] Error response body:`, errorText);
          
          if (response.status === 404) {
            throw new Error(`Watchlist ${activeWatchlist} not found for date ${today}. Check if the endpoint exists.`);
          } else if (response.status === 500) {
            throw new Error(`Server error (${response.status}): ${errorText || 'Internal server error'}`);
          } else {
            throw new Error(`HTTP error ${response.status}: ${errorText || response.statusText}`);
          }
        }

        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
          const responseText = await response.text();
          console.error(`[useWatchlist] Non-JSON response:`, responseText);
          throw new Error('Server returned non-JSON response. Check API endpoint.');
        }

        const data: WatchlistResponse = await response.json();
        
        if (isCancelled) return;
        
        console.log(`[useWatchlist] Raw API response for watchlist ${activeWatchlist}:`, data);

        if (!data || typeof data !== 'object') {
          throw new Error('Invalid response format from server');
        }

        if (!Array.isArray(data.companies)) {
          console.warn(`[useWatchlist] No companies array in response:`, data);
          setCompanies([]);
          setExists(false);
          setTotalCompanies(0);
          setAvailableExchanges([]);
          setAvailableMarkers([]);
          setError(`No companies found for watchlist ${activeWatchlist} on ${today}`);
          return;
        }

        const validCompanies = data.companies.filter((company: MergedCompany) => {
          const isValid = company.company_code && 
                          company.name && 
                          company.exchange &&
                          company.marker;
          
          if (!isValid) {
            console.warn(`[useWatchlist] Invalid company filtered out:`, company);
          }
          return isValid;
        });

        console.log(`[useWatchlist] Valid companies after filtering for ${activeWatchlist}: ${validCompanies.length} out of ${data.companies.length}`);

        setCompanies(validCompanies);
        setExists(data.exists !== false); // Default to true if not specified
        setTotalCompanies(data.total || validCompanies.length);
        
        const exchanges = [...new Set(validCompanies.map((c: MergedCompany) => c.exchange))];
        const markers = [...new Set(validCompanies.map((c: MergedCompany) => c.marker))];
        
        setAvailableExchanges(exchanges);
        setAvailableMarkers(markers);
        
        console.log(`[useWatchlist] Successfully loaded ${validCompanies.length} companies from watchlist ${activeWatchlist}`);
        console.log(`[useWatchlist] Available exchanges: ${exchanges.join(', ')}`);
        
      } catch (err: any) {
        if (isCancelled) return;
        
        console.error(`[useWatchlist] Error fetching watchlist ${activeWatchlist}:`, err);
        console.error(`[useWatchlist] Error details:`, {
          name: err.name,
          message: err.message,
          stack: err.stack
        });
        
        let errorMessage = 'Failed to fetch watchlist data.';
        
        if (err.name === 'AbortError') {
          errorMessage = 'Request timed out. Please try again.';
        } else if (err.message.includes('Backend server is not running')) {
          errorMessage = err.message;
        } else if (err.message.includes('Failed to fetch') || err.name === 'TypeError') {
          errorMessage = 'Cannot connect to backend server. Please ensure:\n1. Backend is running on http://localhost:3001\n2. No firewall blocking the connection\n3. CORS is properly configured';
        } else if (err.message.includes('not found')) {
          errorMessage = err.message;
        } else {
          errorMessage = `Error: ${err.message}`;
        }
        
        setError(errorMessage);
        setCompanies([]);
        setExists(false);
        setAvailableExchanges([]);
        setAvailableMarkers([]);
        setTotalCompanies(0);
      } finally {
        if (!isCancelled) {
          setLoading(false);
        }
      }
    }

    fetchWatchlist();
    
    return () => {
      isCancelled = true;
    };
  }, [activeWatchlist]);

  const getCompanyByCode = useCallback(async (companyCode: string, exchange?: string): Promise<MergedCompany | null> => {
    try {
      const queryParams = new URLSearchParams({ companyCode });
      if (exchange) {
        queryParams.append('exchange', exchange);
      }
      
      const response = await fetch(`http://localhost:5000/api/watchlist/company/${companyCode}?${queryParams}`);
      
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      
      const data = await response.json();
      return data.company;
    } catch (error) {
      console.error('[useWatchlist] Error fetching company by code:', error);
      return null;
    }
  }, []);

  const getFilteredCompanies = useCallback((filters: {
    exchange?: string;
    marker?: string;
    minValidDays?: number;
  }) => {
    return companies.filter(company => {
      if (filters.exchange && company.exchange.toUpperCase() !== filters.exchange.toUpperCase()) {
        return false;
      }
      if (filters.marker && company.marker.toUpperCase() !== filters.marker.toUpperCase()) {
        return false;
      }
      if (filters.minValidDays && (!company.total_valid_days || company.total_valid_days < filters.minValidDays)) {
        return false;
      }
      return true;
    });
  }, [companies]);

  return { 
    selectedWatchlist: activeWatchlist, 
    setSelectedWatchlist, 
    companies, 
    loading, 
    error, 
    exists,
    availableExchanges,
    availableMarkers,
    totalCompanies,
    getCompanyByCode,
    getFilteredCompanies
  };
}


================================================================================
FILE: apps/backend/src/live-market/live-market.controller.ts
CATEGORY: Backend API
================================================================================

import { Controller, Get, Post, Body, Param, Query } from '@nestjs/common';
import { LiveMarketService } from './live-market.service';
import { SubscribeCompaniesDto, UnsubscribeDto } from './dto/live-market.dto';

@Controller('live-market')
export class LiveMarketController {
  constructor(private readonly liveMarketService: LiveMarketService) {}

  @Get('available-companies')
  async getAvailableCompanies(@Query('watchlist') watchlist: string = 'A') {
    return this.liveMarketService.getAvailableCompanies(watchlist);
  }

  @Get('market-status')
  getMarketStatus() {
    return this.liveMarketService.getMarketStatus();
  }

  @Post('subscribe')
  async subscribeToCompanies(@Body() subscribeDto: SubscribeCompaniesDto) {
    return this.liveMarketService.subscribeToCompanies(subscribeDto);
  }

  @Post('unsubscribe')
  async unsubscribeFromCompanies(@Body() unsubscribeDto: UnsubscribeDto) {
    return this.liveMarketService.unsubscribeFromCompanies(unsubscribeDto);
  }

  @Get('historical/:symbol')
  async getHistoricalData(
    @Param('symbol') symbol: string,
    @Query('date') date?: string
  ) {
    return this.liveMarketService.getHistoricalData(symbol, date);
  }
}


================================================================================
FILE: apps/backend/src/live-market/live-market.service.ts
CATEGORY: Backend API
================================================================================

import { Injectable, Logger } from '@nestjs/common';
import { WatchlistService } from '../watchlist/watchlist.service';
import { SubscribeCompaniesDto, UnsubscribeDto } from './dto/live-market.dto';

@Injectable()
export class LiveMarketService {
  private readonly logger = new Logger(LiveMarketService.name);
  private readonly MAX_COMPANIES = 6;

  constructor(private readonly watchlistService: WatchlistService) {}

  async getAvailableCompanies(watchlist: string = 'A') {
    try {
      const companies = await this.watchlistService.getWatchlistData(watchlist);
      
      const availableCompanies = companies.map(company => ({
        company_code: company.company_code,
        name: company.name,
        exchange: company.exchange,
        marker: company.marker,
        symbol: `${company.exchange}:${company.company_code}-${company.marker}`,
        metadata: {
          total_valid_days: company.total_valid_days,
          avg_daily_high_low_range: company.avg_daily_high_low_range,
          median_daily_volume: company.median_daily_volume,
          pe_ratio: company.pe_ratio
        }
      }));

      return {
        success: true,
        companies: availableCompanies,
        total: availableCompanies.length,
        maxSelection: this.MAX_COMPANIES,
        watchlist
      };
    } catch (error) {
      this.logger.error(`Error fetching available companies: ${error.message}`);
      return {
        success: false,
        error: error.message,
        companies: [],
        total: 0,
        maxSelection: this.MAX_COMPANIES,
        watchlist
      };
    }
  }

  getMarketStatus() {
    const now = new Date();
    const istNow = new Date(now.getTime() + (5.5 * 60 * 60 * 1000)); // Convert to IST
    
    const marketOpen = new Date(istNow);
    marketOpen.setHours(9, 15, 0, 0);
    
    const marketClose = new Date(istNow);
    marketClose.setHours(15, 30, 0, 0);
    
    const isWeekend = istNow.getDay() === 0 || istNow.getDay() === 6;
    const isMarketHours = !isWeekend && istNow >= marketOpen && istNow <= marketClose;

    return {
      current_time: istNow.toISOString(),
      market_open: marketOpen.toISOString(),
      market_close: marketClose.toISOString(),
      is_trading_hours: isMarketHours,
      is_weekend: isWeekend,
      timezone: 'Asia/Kolkata'
    };
  }

  async subscribeToCompanies(subscribeDto: SubscribeCompaniesDto) {
    try {
      const { companyCodes, clientId } = subscribeDto;

      if (!Array.isArray(companyCodes)) {
        throw new Error('companyCodes must be an array');
      }

      if (companyCodes.length === 0) {
        throw new Error('At least 1 company must be selected');
      }

      if (companyCodes.length > this.MAX_COMPANIES) {
        throw new Error(`Maximum ${this.MAX_COMPANIES} companies allowed`);
      }

      // Validate company codes exist in watchlist
      const availableCompanies = await this.getAvailableCompanies();

      // Solution 1: Check the 'success' property before accessing 'companies'
      if (!availableCompanies.success) {
        throw new Error(`Failed to get available companies: ${availableCompanies.error}`);
      }

      const validCompanyCodes = availableCompanies.companies.map(c => c.company_code);

      const invalidCodes = companyCodes.filter(code => !validCompanyCodes.includes(code));
      if (invalidCodes.length > 0) {
        throw new Error(`Invalid company codes: ${invalidCodes.join(', ')}`);
      }

      // Build symbols
      const symbols = companyCodes.map(code => {
        const company = availableCompanies.companies.find(c => c.company_code === code);
        return company?.symbol;
      }).filter(Boolean);

      return {
        success: true,
        message: `Subscribed to ${symbols.length} companies`,
        symbols,
        companyCodes,
        clientId
      };
    } catch (error) {
      this.logger.error(`Error subscribing to companies: ${error.message}`);
      return {
        success: false,
        error: error.message
      };
    }
  }

  async unsubscribeFromCompanies(unsubscribeDto: UnsubscribeDto) {
    try {
      const { clientId } = unsubscribeDto;

      return {
        success: true,
        message: 'Unsubscribed from all companies',
        clientId
      };
    } catch (error) {
      this.logger.error(`Error unsubscribing: ${error.message}`);
      return {
        success: false,
        error: error.message
      };
    }
  }

  async getHistoricalData(symbol: string, date?: string) {
    try {
      // This would typically fetch from your data source
      // For now, return a placeholder response
      return {
        success: true,
        symbol,
        date: date || new Date().toISOString().split('T')[0],
        data: [],
        message: 'Historical data endpoint - connect to your data source'
      };
    } catch (error) {
      this.logger.error(`Error fetching historical data: ${error.message}`);
      return {
        success: false,
        error: error.message
      };
    }
  }
}


================================================================================
FILE: apps/backend/src/watchlist/watchlist.controller.ts
CATEGORY: Backend API
================================================================================

import { Controller, Get, Param, Query, Post } from '@nestjs/common';
import { WatchlistService, MergedCompany } from './watchlist.service';

@Controller('api/watchlist')
export class WatchlistController {
  constructor(private readonly watchlistService: WatchlistService) {}

  @Get(':watchlist')
  async getWatchlist(
    @Param('watchlist') watchlist: string,
    @Query('date') date?: string,
    @Query('exchange') exchange?: string,
  ): Promise<{ companies: MergedCompany[], exists: boolean, total: number }> {
    try {
      const allCompanies = await this.watchlistService.getAllCompaniesWithExchange(watchlist, date);
      
      // Filter by exchange if specified
      let companies = allCompanies;
      if (exchange) {
        const exchanges = exchange.split(',').map(ex => ex.trim().toUpperCase());
        companies = allCompanies.filter(company => 
          exchanges.includes(company.exchange.toUpperCase())
        );
      }
      
      console.log(`Retrieved ${companies.length} companies from watchlist ${watchlist} for exchanges: ${exchange || 'ALL'}`);
      return { 
        companies, 
        exists: true, 
        total: companies.length 
      };
    } catch (error) {
      console.error(`Error fetching watchlist ${watchlist}:`, error);
      return { 
        companies: [], 
        exists: false, 
        total: 0 
      };
    }
  }

  @Get(':watchlist/check')
  async checkWatchlist(
    @Param('watchlist') watchlist: string,
    @Query('date') date?: string,
  ): Promise<{ exists: boolean }> {
    const exists = await this.watchlistService.checkWatchlistExists(watchlist, date);
    return { exists };
  }

  @Get(':watchlist/exchanges')
  async getWatchlistExchanges(
    @Param('watchlist') watchlist: string,
    @Query('date') date?: string,
  ): Promise<{ exchanges: string[] }> {
    try {
      const companies = await this.watchlistService.getWatchlistData(watchlist, date);
      const exchanges = [...new Set(companies.map(c => c.exchange).filter(Boolean))];
      return { exchanges };
    } catch (error) {
      return { exchanges: [] };
    }
  }

  @Get()
  async getAvailableWatchlists(): Promise<{ watchlists: string[] }> {
    const watchlists = await this.watchlistService.getAvailableWatchlists();
    return { watchlists };
  }

  @Get('company/:companyCode')
  async getCompanyByCode(
    @Param('companyCode') companyCode: string,
    @Query('exchange') exchange?: string,
  ): Promise<{ company: MergedCompany | null }> {
    const company = await this.watchlistService.getCompanyByCode(companyCode, exchange);
    return { company };
  }

  @Post('refresh-cache')
  async refreshCache(): Promise<{ message: string }> {
    await this.watchlistService.refreshCompanyMasterCache();
    return { message: 'Company master cache refreshed successfully' };
  }
}


================================================================================
END OF LIVE MARKET AND WATCHLIST FILES EXTRACTION
================================================================================
