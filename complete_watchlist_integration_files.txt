================================================================================
COMPLETE WATCHLIST INTEGRATION - ALL FILES
Generated on: 10-06-2025  9:01:53.40
================================================================================

CATEGORIES:
1. Backend Files (5 files)
2. Frontend Files (6 files)
3. Configuration Files (2 files)

TOTAL: 13 FILES
================================================================================


################################################################################
SECTION 1: BACKEND FILES
################################################################################

================================================================================
FILE: apps/backend/src/watchlist/watchlist.controller.ts
PURPOSE: API endpoints for watchlist data
================================================================================

import { Controller, Get, Param, Query, Post } from '@nestjs/common';
import { WatchlistService, MergedCompany } from './watchlist.service';

@Controller('api/watchlist')
export class WatchlistController {
  constructor(private readonly watchlistService: WatchlistService) {}

  @Get(':watchlist')
  async getWatchlist(
    @Param('watchlist') watchlist: string,
    @Query('date') date?: string,
    @Query('exchange') exchange?: string,
  ): Promise<{ companies: MergedCompany[], exists: boolean, total: number }> {
    try {
      const allCompanies = await this.watchlistService.getAllCompaniesWithExchange(watchlist, date);
      
      // Filter by exchange if specified
      let companies = allCompanies;
      if (exchange) {
        const exchanges = exchange.split(',').map(ex => ex.trim().toUpperCase());
        companies = allCompanies.filter(company => 
          exchanges.includes(company.exchange.toUpperCase())
        );
      }
      
      console.log(`Retrieved ${companies.length} companies from watchlist ${watchlist} for exchanges: ${exchange || 'ALL'}`);
      return { 
        companies, 
        exists: true, 
        total: companies.length 
      };
    } catch (error) {
      console.error(`Error fetching watchlist ${watchlist}:`, error);
      return { 
        companies: [], 
        exists: false, 
        total: 0 
      };
    }
  }

  @Get(':watchlist/check')
  async checkWatchlist(
    @Param('watchlist') watchlist: string,
    @Query('date') date?: string,
  ): Promise<{ exists: boolean }> {
    const exists = await this.watchlistService.checkWatchlistExists(watchlist, date);
    return { exists };
  }

  @Get(':watchlist/exchanges')
  async getWatchlistExchanges(
    @Param('watchlist') watchlist: string,
    @Query('date') date?: string,
  ): Promise<{ exchanges: string[] }> {
    try {
      const companies = await this.watchlistService.getWatchlistData(watchlist, date);
      const exchanges = [...new Set(companies.map(c => c.exchange).filter(Boolean))];
      return { exchanges };
    } catch (error) {
      return { exchanges: [] };
    }
  }

  @Get()
  async getAvailableWatchlists(): Promise<{ watchlists: string[] }> {
    const watchlists = await this.watchlistService.getAvailableWatchlists();
    return { watchlists };
  }

  @Get('company/:companyCode')
  async getCompanyByCode(
    @Param('companyCode') companyCode: string,
    @Query('exchange') exchange?: string,
  ): Promise<{ company: MergedCompany | null }> {
    const company = await this.watchlistService.getCompanyByCode(companyCode, exchange);
    return { company };
  }

  @Post('refresh-cache')
  async refreshCache(): Promise<{ message: string }> {
    await this.watchlistService.refreshCompanyMasterCache();
    return { message: 'Company master cache refreshed successfully' };
  }
}


================================================================================
FILE: apps/backend/src/watchlist/watchlist.service.ts
PURPOSE: Business logic for handling watchlist operations
================================================================================

import { Injectable, NotFoundException, Logger } from '@nestjs/common';
import * as fs from 'fs';
import * as path from 'path';
import { parse } from 'csv-parse';
import * as moment from 'moment';

export interface CompanyMaster {
  company_id: number;
  company_code: string;
  name: string;
  exchange: string;
  marker: string;
}

export interface CompanyData {
  company_code: string;
  name: string;
  exchange: string;
  total_valid_days?: number;
  avg_daily_high_low_range?: number;
  median_daily_volume?: number;
  avg_trading_capital?: number;
  pe_ratio?: number;
  N1_Pattern_count?: number;
}

export interface MergedCompany {
  company_id?: number;
  company_code: string;
  name: string;
  exchange: string;
  marker: string;
  total_valid_days?: number;
  avg_daily_high_low_range?: number;
  median_daily_volume?: number;
  avg_trading_capital?: number;
  pe_ratio?: number;
  N1_Pattern_count?: number;
}

@Injectable()
export class WatchlistService {
  private readonly logger = new Logger(WatchlistService.name);
  private readonly basePath = path.resolve(process.cwd(), 'data', 'watchlists');
  private readonly masterDataPath = path.resolve(process.cwd(), 'data', 'company_master.csv');
  
  private companyMasterCache: CompanyMaster[] = [];
  private cacheLastUpdated: number = 0;
  private readonly cacheValidityMs = 30 * 60 * 1000;

  async getWatchlistData(watchlist: string, date?: string): Promise<MergedCompany[]> {
    const targetDate = date || moment().format('YYYY-MM-DD');
    
    try {
      const companyMaster = await this.loadCompanyMaster();
      const watchlistData = await this.loadWatchlistCSV(watchlist, targetDate);
      const mergedData = this.mergeCompanyData(companyMaster, watchlistData);
      
      this.logger.log(`Merged ${mergedData.length} companies for watchlist ${watchlist}`);
      return mergedData;
      
    } catch (error) {
      this.logger.error(`Error loading watchlist ${watchlist}:`, error);
      throw new NotFoundException(`Failed to load watchlist ${watchlist}: ${error.message}`);
    }
  }

  private async loadCompanyMaster(): Promise<CompanyMaster[]> {
    const now = Date.now();
    if (this.companyMasterCache.length > 0 && (now - this.cacheLastUpdated) < this.cacheValidityMs) {
      return this.companyMasterCache;
    }

    return new Promise((resolve, reject) => {
      if (!fs.existsSync(this.masterDataPath)) {
        this.logger.error(`Company master file not found: ${this.masterDataPath}`);
        return reject(new Error('Company master data file not found'));
      }

      const results: CompanyMaster[] = [];

      fs.createReadStream(this.masterDataPath)
        .pipe(parse({
          delimiter: ',',
          columns: true,
          skip_empty_lines: true,
          trim: true,
        }))
        .on('data', (data) => {
          try {
            // Handle both possible column name formats
            const company: CompanyMaster = {
              company_id: parseInt(data.company_id) || 0,
              company_code: String(data.company_code || '').trim().toUpperCase(),
              name: String(data['NAME OF COMPANY'] || data.name || '').trim(),
              exchange: String(data.Exchange || data.exchange || 'NSE').trim().toUpperCase(),
              marker: String(data.Marker || data.marker || 'EQ').trim().toUpperCase()
            };

            if (company.company_code && company.name) {
              results.push(company);
              this.logger.debug(`Loaded company: ${company.company_code} - ${company.name}`);
            }
          } catch (error) {
            this.logger.warn(`Skipping invalid company master row: ${JSON.stringify(data)}`);
          }
        })
        .on('end', () => {
          this.companyMasterCache = results;
          this.cacheLastUpdated = Date.now();
          this.logger.log(`Loaded ${results.length} companies from master data`);
          resolve(results);
        })
        .on('error', (error) => {
          this.logger.error(`Error reading company master CSV: ${error}`);
          reject(error);
        });
    });
  }

  private async loadWatchlistCSV(watchlist: string, date: string): Promise<CompanyData[]> {
    const fileName = `watchlist_${watchlist}_${date}.csv`;
    const filePath = path.join(this.basePath, fileName);

    return new Promise((resolve, reject) => {
      if (!fs.existsSync(filePath)) {
        this.logger.warn(`Watchlist file not found: ${filePath}, trying fallback dates...`);
        
        const fallbackDates = this.generateFallbackDates(date);
        this.tryFallbackDates(watchlist, fallbackDates)
          .then(resolve)
          .catch(reject);
        return;
      }

      const results: CompanyData[] = [];

      fs.createReadStream(filePath)
        .pipe(parse({
          delimiter: ',',
          columns: true,
          skip_empty_lines: true,
          trim: true,
        }))
        .on('data', (data) => {
          try {
            const company: CompanyData = {
              company_code: String(data.company_code || '').trim().toUpperCase(),
              name: String(data.name || '').trim(),
              exchange: String(data.exchange || 'NSE').trim().toUpperCase(),
              total_valid_days: data.total_valid_days ? Number(data.total_valid_days) : undefined,
              avg_daily_high_low_range: data.avg_daily_high_low_range ? Number(data.avg_daily_high_low_range) : undefined,
              median_daily_volume: data.median_daily_volume ? Number(data.median_daily_volume) : undefined,
              avg_trading_capital: data.avg_trading_capital ? Number(data.avg_trading_capital) : undefined,
              pe_ratio: data.pe_ratio ? Number(data.pe_ratio) : undefined,
              N1_Pattern_count: data.N1_Pattern_count ? Number(data.N1_Pattern_count) : undefined
            };

            if (company.company_code) {
              results.push(company);
              this.logger.debug(`Loaded watchlist company: ${company.company_code} - ${company.name}`);
            }
          } catch (error) {
            this.logger.warn(`Skipping invalid watchlist row: ${JSON.stringify(data)}`);
          }
        })
        .on('end', () => {
          this.logger.log(`Loaded ${results.length} companies from watchlist CSV: ${fileName}`);
          resolve(results);
        })
        .on('error', (error) => {
          this.logger.error(`Error reading watchlist CSV: ${error}`);
          reject(error);
        });
    });
  }

  private async tryFallbackDates(watchlist: string, fallbackDates: string[]): Promise<CompanyData[]> {
    for (const fallbackDate of fallbackDates) {
      const fileName = `watchlist_${watchlist}_${fallbackDate}.csv`;
      const filePath = path.join(this.basePath, fileName);
      
      if (fs.existsSync(filePath)) {
        this.logger.log(`Using fallback date ${fallbackDate} for watchlist ${watchlist}`);
        return this.loadWatchlistCSV(watchlist, fallbackDate);
      }
    }
    
    throw new Error(`No watchlist data found for ${watchlist} on any fallback dates`);
  }

  private generateFallbackDates(targetDate: string): string[] {
    const date = moment(targetDate);
    const fallbacks: string[] = [];
    
    for (let i = 1; i <= 10; i++) {
      fallbacks.push(date.clone().subtract(i, 'days').format('YYYY-MM-DD'));
    }
    
    return fallbacks;
  }

  private mergeCompanyData(masterData: CompanyMaster[], watchlistData: CompanyData[]): MergedCompany[] {
    const mergedResults: MergedCompany[] = [];
    const masterMap = new Map<string, CompanyMaster[]>();

    // Create a map of master data by company_code
    masterData.forEach(master => {
      const key = master.company_code;
      if (!masterMap.has(key)) {
        masterMap.set(key, []);
      }
      masterMap.get(key)!.push(master);
    });

    this.logger.log(`Master data map has ${masterMap.size} unique company codes`);

    // Merge watchlist data with master data
    watchlistData.forEach(watchlistItem => {
      const masterEntries = masterMap.get(watchlistItem.company_code) || [];
      
      if (masterEntries.length === 0) {
        // No master data found, create entry with default marker
        const merged: MergedCompany = {
          company_code: watchlistItem.company_code,
          name: watchlistItem.name,
          exchange: watchlistItem.exchange,
          marker: 'EQ', // Default marker
          total_valid_days: watchlistItem.total_valid_days,
          avg_daily_high_low_range: watchlistItem.avg_daily_high_low_range,
          median_daily_volume: watchlistItem.median_daily_volume,
          avg_trading_capital: watchlistItem.avg_trading_capital,
          pe_ratio: watchlistItem.pe_ratio,
          N1_Pattern_count: watchlistItem.N1_Pattern_count
        };
        mergedResults.push(merged);
        this.logger.warn(`No master data found for company_code: ${watchlistItem.company_code}`);
      } else {
        // Find exact exchange match or use first available
        let masterEntry = masterEntries.find(m => m.exchange === watchlistItem.exchange);
        if (!masterEntry) {
          masterEntry = masterEntries[0];
        }

        const merged: MergedCompany = {
          company_id: masterEntry.company_id,
          company_code: watchlistItem.company_code,
          name: masterEntry.name || watchlistItem.name,
          exchange: watchlistItem.exchange,
          marker: masterEntry.marker,
          total_valid_days: watchlistItem.total_valid_days,
          avg_daily_high_low_range: watchlistItem.avg_daily_high_low_range,
          median_daily_volume: watchlistItem.median_daily_volume,
          avg_trading_capital: watchlistItem.avg_trading_capital,
          pe_ratio: watchlistItem.pe_ratio,
          N1_Pattern_count: watchlistItem.N1_Pattern_count
        };
        
        mergedResults.push(merged);
        this.logger.debug(`Merged: ${merged.company_code} with marker ${merged.marker}`);
      }
    });

    return mergedResults.sort((a, b) => a.name.localeCompare(b.name));
  }

  async getAllCompaniesWithExchange(watchlist: string, date?: string): Promise<MergedCompany[]> {
    const companies = await this.getWatchlistData(watchlist, date);
    
    return companies.filter(company => 
      company.company_code && 
      company.name && 
      company.exchange &&
      ['NSE', 'BSE'].includes(company.exchange.toUpperCase())
    );
  }

  async checkWatchlistExists(watchlist: string, date?: string): Promise<boolean> {
    const targetDate = date || moment().format('YYYY-MM-DD');
    const fileName = `watchlist_${watchlist}_${targetDate}.csv`;
    const filePath = path.join(this.basePath, fileName);
    
    if (fs.existsSync(filePath)) {
      return true;
    }
    
    const fallbackDates = this.generateFallbackDates(targetDate);
    return fallbackDates.some(fallbackDate => {
      const fallbackFileName = `watchlist_${watchlist}_${fallbackDate}.csv`;
      const fallbackPath = path.join(this.basePath, fallbackFileName);
      return fs.existsSync(fallbackPath);
    });
  }

  async getAvailableWatchlists(): Promise<string[]> {
    try {
      const files = fs.readdirSync(this.basePath);
      const watchlistPattern = /^watchlist_([A-Z])_\d{4}-\d{2}-\d{2}\.csv$/;
      const watchlists = new Set<string>();
      
      files.forEach(file => {
        const match = file.match(watchlistPattern);
        if (match) {
          watchlists.add(match[1]);
        }
      });
      
      return Array.from(watchlists).sort();
    } catch (error) {
      this.logger.error('Error reading watchlist directory:', error);
      return [];
    }
  }

  async refreshCompanyMasterCache(): Promise<void> {
    this.companyMasterCache = [];
    this.cacheLastUpdated = 0;
    await this.loadCompanyMaster();
  }

  async getCompanyByCode(companyCode: string, exchange?: string): Promise<MergedCompany | null> {
    const masterData = await this.loadCompanyMaster();
    
    let matches = masterData.filter(company => 
      company.company_code.toUpperCase() === companyCode.toUpperCase()
    );
    
    if (exchange) {
      const exchangeMatch = matches.find(company => 
        company.exchange.toUpperCase() === exchange.toUpperCase()
      );
      if (exchangeMatch) {
        return {
          company_id: exchangeMatch.company_id,
          company_code: exchangeMatch.company_code,
          name: exchangeMatch.name,
          exchange: exchangeMatch.exchange,
          marker: exchangeMatch.marker
        };
      }
    }
    
    if (matches.length > 0) {
      const match = matches[0];
      return {
        company_id: match.company_id,
        company_code: match.company_code,
        name: match.name,
        exchange: match.exchange,
        marker: match.marker
      };
    }
    
    return null;
  }
}


================================================================================
FILE: apps/backend/data/watchlists/watchlist_A_2025-02-16.csv (HEADER + 5 LINES)
PURPOSE: Sample data structure - Watchlist A
================================================================================

[FILE NOT FOUND OR EMPTY] 


================================================================================
FILE: apps/backend/data/watchlists/watchlist_B_2025-02-16.csv (HEADER + 5 LINES)
PURPOSE: Sample data structure - Watchlist B
================================================================================

[FILE NOT FOUND OR EMPTY] 


================================================================================
FILE: apps/backend/data/watchlists/watchlist_C_2025-02-16.csv (HEADER + 5 LINES)
PURPOSE: Sample data structure - Watchlist C
================================================================================

[FILE NOT FOUND OR EMPTY] 


################################################################################
SECTION 2: FRONTEND FILES
################################################################################

================================================================================
FILE: apps/frontend/app/components/controllers/WatchlistSelector/WatchlistSelector.tsx
PURPOSE: Main watchlist selector component
================================================================================

'use client'
import * as React from "react";
import { useWatchlist } from "@/hooks/useWatchlist";
import { RadioGroupDemo } from "./RadioGroup";
import { SelectScrollable } from "./SelectScrollable";

interface WatchlistSelectorProps {
  onCompanySelect?: (companyCode: string | null, exchange?: string, marker?: string) => void;
  selectedWatchlist?: string;
  onWatchlistChange?: (watchlist: string) => void;
  showExchangeFilter?: boolean;
  showMarkerFilter?: boolean;
}

export function WatchlistSelector({ 
  onCompanySelect,
  selectedWatchlist: externalSelectedWatchlist,
  onWatchlistChange,
  showExchangeFilter = true,
  showMarkerFilter = true
}: WatchlistSelectorProps) {
  const {
    selectedWatchlist: internalSelectedWatchlist,
    setSelectedWatchlist: internalSetSelectedWatchlist,
    companies,
    loading,
    error,
    exists,
    availableExchanges,
    availableMarkers,
    totalCompanies,
    getFilteredCompanies
  } = useWatchlist();
  
  const [selectedExchange, setSelectedExchange] = React.useState<string>('');
  const [selectedMarker, setSelectedMarker] = React.useState<string>('');
  
  const effectiveWatchlist = externalSelectedWatchlist || internalSelectedWatchlist;
  
  const handleWatchlistChange = (value: string) => {
    // Reset filters when watchlist changes
    setSelectedExchange('');
    setSelectedMarker('');
    
    if (onWatchlistChange) {
      onWatchlistChange(value);
    } else {
      internalSetSelectedWatchlist(value);
    }
  };

  const handleCompanySelect = (companyCode: string | null) => {
    if (!companyCode) {
      if (onCompanySelect) {
        onCompanySelect(null);
      }
      return;
    }

    // Find the selected company to get its exchange and marker
    const selectedCompany = companies.find(c => c.company_code === companyCode);
    
    console.log(`Selected company: ${companyCode}`, selectedCompany);
    
    if (onCompanySelect && selectedCompany) {
      onCompanySelect(companyCode, selectedCompany.exchange, selectedCompany.marker);
    }
  };

  // Get filtered companies based on current filters
  const filteredCompanies = React.useMemo(() => {
    const filters: any = {};
    if (selectedExchange) filters.exchange = selectedExchange;
    if (selectedMarker) filters.marker = selectedMarker;
    
    return getFilteredCompanies(filters);
  }, [companies, selectedExchange, selectedMarker, getFilteredCompanies]);

  return (
    <div className="flex gap-4">
      {/* Watchlist Selection */}
      <div className="flex gap-5 items-center">
        <div className="flex flex-col gap-1">
          <label className="text-sm font-medium">Watchlist</label>
          <RadioGroupDemo
            value={effectiveWatchlist} 
            onChange={handleWatchlistChange}
          />
        </div>
        
        {/* Status Information */}
        <div className="flex flex-col gap-1">
          <div className="text-xs text-muted-foreground">
            {loading && 'Loading...'}
            {!loading && exists && `${totalCompanies} companies`}
            {!loading && !exists && 'No data available'}
          </div>
          {availableExchanges.length > 0 && (
            <div className="text-xs text-muted-foreground">
              Exchanges: {availableExchanges.join(', ')}
            </div>
          )}
        </div>
      </div>

      {/* Filters */}
      {(showExchangeFilter || showMarkerFilter) && availableExchanges.length > 0 && (
        <div className="flex gap-4 items-center">
          {/* Exchange Filter */}
          {showExchangeFilter && (
            <div className="flex flex-col gap-1">
              <label className="text-xs font-medium">Exchange</label>
              <select
                value={selectedExchange}
                onChange={(e) => setSelectedExchange(e.target.value)}
                className="px-2 py-1 text-xs border rounded"
              >
                <option value="">All Exchanges</option>
                {availableExchanges.map(exchange => (
                  <option key={exchange} value={exchange}>
                    {exchange}
                  </option>
                ))}
              </select>
            </div>
          )}

          {/* Marker Filter */}
          {showMarkerFilter && availableMarkers.length > 0 && (
            <div className="flex flex-col gap-1">
              <label className="text-xs font-medium">Marker</label>
              <select
                value={selectedMarker}
                onChange={(e) => setSelectedMarker(e.target.value)}
                className="px-2 py-1 text-xs border rounded"
              >
                <option value="">All Markers</option>
                {availableMarkers.map(marker => (
                  <option key={marker} value={marker}>
                    {marker}
                  </option>
                ))}
              </select>
            </div>
          )}

          {/* Filter Results Count */}
          <div className="text-xs text-muted-foreground">
            {filteredCompanies.length !== companies.length && (
              `${filteredCompanies.length} of ${companies.length} shown`
            )}
          </div>
        </div>
      )}

      {/* Error Display */}
      {error && (
        <div className="text-destructive text-xs bg-destructive/10 px-2 py-1 rounded">
          {error}
        </div>
      )}
      
      {/* Company Selection */}
      <div>
        <SelectScrollable
          companies={filteredCompanies}
          loading={loading}
          exists={exists}
          onCompanySelect={handleCompanySelect}
        />
      </div>
    </div>
  );
}


================================================================================
FILE: apps/frontend/app/components/controllers/WatchlistSelector/RadioGroup.tsx
PURPOSE: Radio button implementation
================================================================================

// src/components/WatchlistSelector/RadioGroup.tsx
import { Label } from "@/components/ui/label";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";

interface RadioGroupDemoProps {
  value: string;
  onChange: (value: string) => void;
}

export function RadioGroupDemo({ value, onChange }: RadioGroupDemoProps) {
  return (
    <RadioGroup className="flex" value={value} onValueChange={onChange}>
      <div className="flex items-center space-x-2">
        <RadioGroupItem value="A" id="r1" />
        <Label htmlFor="r1">A</Label>
      </div>
      <div className="flex items-center space-x-2">
        <RadioGroupItem value="B" id="r2" />
        <Label htmlFor="r2">B</Label>
      </div>
      <div className="flex items-center space-x-2">
        <RadioGroupItem value="C" id="r3" />
        <Label htmlFor="r3">C</Label>
      </div>
    </RadioGroup>
  );
}


================================================================================
FILE: apps/frontend/app/components/controllers/WatchlistSelector/index.tsx
PURPOSE: Component entry point
================================================================================

// src/components/WatchlistSelector/index.tsx
export { WatchlistSelector } from './WatchlistSelector';


================================================================================
FILE: apps/frontend/app/market-data/components/WatchlistManager.tsx
PURPOSE: Watchlist management component
================================================================================

'use client';

import React, { useState, useEffect } from 'react';
import { Card, CardHeader, CardTitle, CardContent } from '../../../components/ui/card';
import { Button } from '../../../components/ui/button';
import { Input } from '../../../components/ui/input';

interface WatchlistManagerProps {
  subscribedSymbols: string[];
  onSymbolSelect: (symbol: string) => void;
  onAddSymbol: (symbol: string) => void;
  onRemoveSymbol: (symbol: string) => void;
}

// Predefined watchlists
const predefinedWatchlists = {
  'Indices': [
    'NSE:NIFTY50-INDEX',
    'NSE:BANKNIFTY-INDEX',
    'NSE:FINNIFTY-INDEX',
    'NSE:NIFTYIT-INDEX',
    'NSE:NIFTYPHARMA-INDEX',
  ],
  'Large Cap': [
    'NSE:RELIANCE-EQ',
    'NSE:TCS-EQ',
    'NSE:HDFCBANK-EQ',
    'NSE:INFY-EQ',
    'NSE:ICICIBANK-EQ',
  ],
  'IT Stocks': [
    'NSE:TCS-EQ',
    'NSE:INFY-EQ',
    'NSE:WIPRO-EQ',
    'NSE:HCLTECH-EQ',
    'NSE:TECHM-EQ',
  ],
};

const WatchlistManager: React.FC<WatchlistManagerProps> = ({
  subscribedSymbols,
  onSymbolSelect,
  onAddSymbol,
  onRemoveSymbol,
}) => {
  const [newSymbol, setNewSymbol] = useState('');
  const [savedWatchlists, setSavedWatchlists] = useState<Record<string, string[]>>({});
  const [newWatchlistName, setNewWatchlistName] = useState('');
  const [showSaveDialog, setShowSaveDialog] = useState(false);

  // Load saved watchlists from localStorage
  useEffect(() => {
    const saved = localStorage.getItem('marketDataWatchlists');
    if (saved) {
      setSavedWatchlists(JSON.parse(saved));
    }
  }, []);

  const handleAddSymbol = (e: React.FormEvent) => {
    e.preventDefault();
    if (newSymbol && !subscribedSymbols.includes(newSymbol)) {
      onAddSymbol(newSymbol);
      setNewSymbol('');
    }
  };

  const handleSaveWatchlist = () => {
    if (newWatchlistName) {
      const updatedWatchlists = {
        ...savedWatchlists,
        [newWatchlistName]: [...subscribedSymbols],
      };
      
      setSavedWatchlists(updatedWatchlists);
      localStorage.setItem('marketDataWatchlists', JSON.stringify(updatedWatchlists));
      setNewWatchlistName('');
      setShowSaveDialog(false);
    }
  };

  const handleLoadWatchlist = (watchlist: string[]) => {
    // Remove all current symbols
    subscribedSymbols.forEach(symbol => onRemoveSymbol(symbol));
    
    // Add all symbols from the selected watchlist
    watchlist.forEach(symbol => onAddSymbol(symbol));
  };

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Add Symbol</CardTitle>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleAddSymbol} className="space-y-4">
            <div className="flex gap-2">
              <Input
                type="text"
                placeholder="NSE:SYMBOL-EQ"
                value={newSymbol}
                onChange={(e) => setNewSymbol(e.target.value)}
                className="flex-1"
              />
              <Button type="submit">Add</Button>
            </div>
            <div className="text-sm text-muted-foreground">
              Format: Exchange:Symbol-Type (e.g., NSE:RELIANCE-EQ)
            </div>
          </form>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Predefined Watchlists</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {Object.entries(predefinedWatchlists).map(([name, symbols]) => (
            <div key={name} className="flex justify-between items-center">
              <div>
                <div className="font-medium">{name}</div>
                <div className="text-sm text-muted-foreground">
                  {symbols.length} symbols
                </div>
              </div>
              <Button 
                variant="outline" 
                size="sm"
                onClick={() => handleLoadWatchlist(symbols)}
              >
                Load
              </Button>
            </div>
          ))}
        </CardContent>
      </Card>

      {Object.keys(savedWatchlists).length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle>Your Watchlists</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            {Object.entries(savedWatchlists).map(([name, symbols]) => (
              <div key={name} className="flex justify-between items-center">
                <div>
                  <div className="font-medium">{name}</div>
                  <div className="text-sm text-muted-foreground">
                    {symbols.length} symbols
                  </div>
                </div>
                <div className="flex gap-2">
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={() => handleLoadWatchlist(symbols)}
                  >
                    Load
                  </Button>
                  <Button 
                    variant="outline" 
                    size="sm"
                    className="text-red-500"
                    onClick={() => {
                      const { [name]: _, ...rest } = savedWatchlists;
                      setSavedWatchlists(rest);
                      localStorage.setItem('marketDataWatchlists', JSON.stringify(rest));
                    }}
                  >
                    Delete
                  </Button>
                </div>
              </div>
            ))}
          </CardContent>
        </Card>
      )}

      <Card>
        <CardHeader>
          <CardTitle>Manage Watchlist</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <Button 
            variant="outline" 
            className="w-full"
            onClick={() => setShowSaveDialog(!showSaveDialog)}
          >
            Save Current Watchlist
          </Button>
          
          {showSaveDialog && (
            <div className="space-y-2">
              <Input
                type="text"
                placeholder="Watchlist name"
                value={newWatchlistName}
                onChange={(e) => setNewWatchlistName(e.target.value)}
              />
              <div className="flex gap-2">
                <Button 
                  variant="default" 
                  className="flex-1"
                  onClick={handleSaveWatchlist}
                >
                  Save
                </Button>
                <Button 
                  variant="outline" 
                  onClick={() => setShowSaveDialog(false)}
                >
                  Cancel
                </Button>
              </div>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
};

export default WatchlistManager;


================================================================================
FILE: apps/frontend/hooks/useWatchlist.ts
PURPOSE: Custom hook for watchlist state management
================================================================================

import { useState, useEffect } from 'react';

interface MergedCompany {
  company_id?: number;
  company_code: string;
  name: string;
  exchange: string;
  marker: string;
  total_valid_days?: number;
  avg_daily_high_low_range?: number;
  median_daily_volume?: number;
  avg_trading_capital?: number;
  pe_ratio?: number;
  N1_Pattern_count?: number;
}

interface WatchlistResponse {
  companies: MergedCompany[];
  exists: boolean;
  total: number;
}

export function useWatchlist() {
  const [selectedWatchlist, setSelectedWatchlist] = useState('A');
  const [companies, setCompanies] = useState<MergedCompany[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [exists, setExists] = useState(true);
  const [availableExchanges, setAvailableExchanges] = useState<string[]>([]);
  const [totalCompanies, setTotalCompanies] = useState(0);
  const [availableMarkers, setAvailableMarkers] = useState<string[]>([]);

  useEffect(() => {
    async function fetchWatchlist() {
      console.log(`[useWatchlist] Starting to fetch watchlist: ${selectedWatchlist}`);
      setLoading(true);
      setError(null);

      try {
        const today = new Date().toISOString().split('T')[0];
        const apiUrl = `/api/watchlist/${selectedWatchlist}?date=${today}`;
        
        console.log(`[useWatchlist] Fetching from: ${apiUrl}`);

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000);

        const response = await fetch(apiUrl, { 
          signal: controller.signal,
          headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json'
          }
        });
        clearTimeout(timeoutId);

        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }

        const data: WatchlistResponse = await response.json();
        console.log(`[useWatchlist] Raw API response:`, data);

        const validCompanies = (data.companies || []).filter((company: MergedCompany) => {
          const isValid = company.company_code && 
                          company.name && 
                          company.exchange &&
                          company.marker;
          
          if (!isValid) {
            console.warn(`[useWatchlist] Invalid company filtered out:`, company);
          }
          return isValid;
        });

        console.log(`[useWatchlist] Valid companies after filtering:`, validCompanies);

        setCompanies(validCompanies);
        setExists(data.exists);
        setTotalCompanies(data.total || validCompanies.length);
        
        const exchanges = [...new Set(validCompanies.map((c: MergedCompany) => c.exchange))];
        const markers = [...new Set(validCompanies.map((c: MergedCompany) => c.marker))];
        
        setAvailableExchanges(exchanges);
        setAvailableMarkers(markers);
        
        console.log(`[useWatchlist] Loaded ${validCompanies.length} companies from watchlist ${selectedWatchlist}`);
        console.log(`[useWatchlist] Available exchanges: ${exchanges.join(', ')}`);
        console.log(`[useWatchlist] Available markers: ${markers.join(', ')}`);
        
      } catch (err) {
        console.error('[useWatchlist] Error fetching watchlist data:', err);
        
        if (err.name === 'AbortError') {
          setError('Request timed out. Please try again.');
        } else {
          setError('Failed to fetch watchlist data. Please check your connection and try again.');
        }
        
        setCompanies([]);
        setExists(false);
        setAvailableExchanges([]);
        setAvailableMarkers([]);
        setTotalCompanies(0);
      } finally {
        setLoading(false);
      }
    }

    fetchWatchlist();
  }, [selectedWatchlist]);

  const getCompanyByCode = async (companyCode: string, exchange?: string): Promise<MergedCompany | null> => {
    try {
      const queryParams = new URLSearchParams({ companyCode });
      if (exchange) {
        queryParams.append('exchange', exchange);
      }
      
      const response = await fetch(`/api/watchlist/company/${companyCode}?${queryParams}`);
      
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      
      const data = await response.json();
      return data.company;
    } catch (error) {
      console.error('[useWatchlist] Error fetching company by code:', error);
      return null;
    }
  };

  const filterByExchange = (exchange: string) => {
    return companies.filter(company => 
      company.exchange.toUpperCase() === exchange.toUpperCase()
    );
  };

  const filterByMarker = (marker: string) => {
    return companies.filter(company => 
      company.marker.toUpperCase() === marker.toUpperCase()
    );
  };

  const getFilteredCompanies = (filters: {
    exchange?: string;
    marker?: string;
    minValidDays?: number;
  }) => {
    return companies.filter(company => {
      if (filters.exchange && company.exchange.toUpperCase() !== filters.exchange.toUpperCase()) {
        return false;
      }
      if (filters.marker && company.marker.toUpperCase() !== filters.marker.toUpperCase()) {
        return false;
      }
      if (filters.minValidDays && (!company.total_valid_days || company.total_valid_days < filters.minValidDays)) {
        return false;
      }
      return true;
    });
  };

  return { 
    selectedWatchlist, 
    setSelectedWatchlist, 
    companies, 
    loading, 
    error, 
    exists,
    availableExchanges,
    availableMarkers,
    totalCompanies,
    getCompanyByCode,
    filterByExchange,
    filterByMarker,
    getFilteredCompanies
  };
}


================================================================================
FILE: apps/frontend/hooks/useMarketData.ts
PURPOSE: Market data hook (may contain watchlist logic)
================================================================================

import { useState, useEffect, useCallback } from 'react';
import { getSocket } from '../lib/socket';

interface MarketData {
  ltp: number;
  change: number;
  changePercent: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
  timestamp: number;
}

interface UseMarketDataReturn {
  data: Record<string, MarketData>;
  isLoading: boolean;
  error: Error | null;
  subscribeToSymbol: (symbol: string) => void;
  unsubscribeFromSymbol: (symbol: string) => void;
}

export const useMarketData = (initialSymbols: string[] = []): UseMarketDataReturn => {
  const [data, setData] = useState<Record<string, MarketData>>({});
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<Error | null>(null);
  const [subscribedSymbols, setSubscribedSymbols] = useState<Set<string>>(
    new Set(initialSymbols)
  );

  const subscribeToSymbol = useCallback((symbol: string) => {
    setSubscribedSymbols((prev) => {
      const newSet = new Set(prev);
      newSet.add(symbol);
      return newSet;
    });
    
    getSocket().emit('subscribe', { symbol });
  }, []);

  const unsubscribeFromSymbol = useCallback((symbol: string) => {
    setSubscribedSymbols((prev) => {
      const newSet = new Set(prev);
      newSet.delete(symbol);
      return newSet;
    });
    
    getSocket().emit('unsubscribe', { symbol });
    
    setData((prev) => {
      const newData = { ...prev };
      delete newData[symbol];
      return newData;
    });
  }, []);

  useEffect(() => {
    const socket = getSocket();
    
    const handleMarketData = (message: { symbol: string; data: MarketData }) => {
      setData((prev) => ({
        ...prev,
        [message.symbol]: message.data,
      }));
      
      setIsLoading(false);
    };
    
    socket.on('marketData', handleMarketData);
    
    initialSymbols.forEach((symbol) => {
      socket.emit('subscribe', { symbol });
    });
    
    return () => {
      socket.off('marketData', handleMarketData);
      
      subscribedSymbols.forEach((symbol) => {
        socket.emit('unsubscribe', { symbol });
      });
    };
  }, [initialSymbols]);

  return {
    data,
    isLoading,
    error,
    subscribeToSymbol,
    unsubscribeFromSymbol,
  };
};


################################################################################
SECTION 3: CONFIGURATION FILES
################################################################################

================================================================================
FILE: apps/frontend/lib/socket.ts
PURPOSE: WebSocket configuration (watchlists update via WebSocket)
================================================================================


import { io, Socket } from 'socket.io-client';

let socket: Socket | null = null;
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;

export const getSocket = (): Socket => {
  if (!socket) {
    const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL || 'http://localhost:5001';
    console.log(`Connecting to WebSocket server at ${SOCKET_URL}`);
    
    socket = io(SOCKET_URL, {
      reconnectionAttempts: MAX_RECONNECT_ATTEMPTS,
      reconnectionDelay: 1000,
      timeout: 10000,
      transports: ['websocket', 'polling']
    });
    
    socket.on('connect', () => {
      console.log(`Connected to WebSocket server with ID: ${socket?.id}`);
      reconnectAttempts = 0;
    });
    
    socket.on('connect_error', (error) => {
      console.error('Socket connection error:', error.message);
      reconnectAttempts++;
    });
    
    socket.on('disconnect', (reason) => {
      console.log(`Disconnected from WebSocket server. Reason: ${reason}`);
    });
    
    socket.on('error', (error) => {
      console.error('Socket error:', error);
    });
    
    socket.on('heartbeat', (data) => {
      console.log('Heartbeat received:', data);
    });
  }
  
  return socket;
};

export const disconnectSocket = (): void => {
  if (socket) {
    console.log('Manually disconnecting socket');
    socket.disconnect();
    socket = null;
  }
};


================================================================================
FILE: apps/backend/src/market-data/market-data.service.ts
PURPOSE: May contain watchlist filtering logic
================================================================================


import { Injectable, Logger } from '@nestjs/common';

@Injectable()
export class MarketDataService {
  private readonly logger = new Logger(MarketDataService.name);
  private marketData = new Map<string, any>();

  getAccessToken(): string {
    const token = process.env.FYERS_ACCESS_TOKEN;
    if (!token) {
      this.logger.error('FYERS_ACCESS_TOKEN is not defined in environment');
      throw new Error('Missing Fyers access token');
    }
    return token;
  }

  updateMarketData(symbol: string, data: any) {
    this.marketData.set(symbol, data);
    this.logger.debug(`Updated market data for ${symbol}`);
  }

  getMarketData(symbol: string) {
    return this.marketData.get(symbol) || null;
  }

  isMarketCurrentlyOpen(): boolean {
    const today = new Date().getDay();
    if (today === 0 || today === 6) {
      this.logger.warn('Today is a weekend. Markets are closed.');
      return false;
    }
    
    const now = new Date();
    const hours = now.getHours();
    const minutes = now.getMinutes();
    const currentTime = hours * 100 + minutes;
    
    if (currentTime < 915 || currentTime > 1530) {
      this.logger.warn('Outside market hours (9:15 AM - 3:30 PM IST). Real-time data may not be available.');
      return false;
    }
    
    return true;
  }
}


################################################################################
END OF COMPLETE WATCHLIST INTEGRATION EXTRACTION
################################################################################

EXTRACTION SUMMARY:
===================
Backend Files: 5 files (2 TypeScript + 3 CSV samples)
Frontend Files: 6 files
Configuration Files: 2 files

TOTAL FILES PROCESSED: 13 FILES
################################################################################
