================================================================================
CORE WATCHLIST SYSTEM - COMPLETE FILE EXTRACTION
Generated on: 09-06-2025 23:17:15.49
================================================================================

CATEGORIES:
1. Core Watchlist Files (3 files)
2. Data and Entity Files (4 files)
3. Data Processing Files (2 files + CSV samples)
4. Frontend Watchlist Management (3 files)
5. Frontend Data Hooks (3 files)
6. Frontend Display Components (2 files)

TOTAL: 17 FILES + CSV SAMPLES
================================================================================


################################################################################
SECTION 1: CORE WATCHLIST FILES
################################################################################

================================================================================
FILE: apps/backend/src/watchlist/watchlist.service.ts
PURPOSE: Main service for combining data from both sources
================================================================================

import { Injectable, NotFoundException } from '@nestjs/common';
import * as fs from 'fs';
import * as path from 'path';
import { parse } from 'csv-parse';
import * as moment from 'moment';

export interface Company {
  company_code: string;           
  name: string;                 
  exchange: string;             
  total_valid_days?: number;      
  avg_daily_high_low?: number;
  median_daily_volume?: number;
  avg_trading_ratio?: number;
  N1_Pattern_count?: number;
  avg_daily_high_low_range?: number;
  avg_daily_volume?: number;
  avg_trading_capital?: number;
  instrument_token?: string;
  tradingsymbol?: string;
}

@Injectable()
export class WatchlistService {
  private readonly basePath = path.resolve(process.cwd(), 'data', 'watchlists');

  async getWatchlistData(watchlist: string, date?: string): Promise<Company[]> {
    return new Promise((resolve, reject) => {
      const targetDate = date || moment().format('YYYY-MM-DD');
      
      const fileName = `watchlist_${watchlist}_${targetDate}.csv`;
      const filePath = path.join(this.basePath, fileName);
      
      console.log(`Attempting to read watchlist from: ${filePath}`);
      
      if (!fs.existsSync(filePath)) {
        console.error(`Watchlist file not found: ${filePath}`);
        return reject(new NotFoundException(`Watchlist ${watchlist} not found for date ${targetDate}`));
      }
      
      const results: Company[] = [];
      
      fs.createReadStream(filePath)
        .pipe(parse({
          delimiter: ',',
          columns: true,
          skip_empty_lines: true,
          trim: true,
        }))
        .on('data', (data) => {
          const cleanData: Company = {
            company_code: String(data.company_code).trim(),
            name: String(data.name || data.tradingsymbol || '').trim(),
            exchange: String(data.exchange || 'NSE').trim(),
            // Map new CSV fields
            total_valid_days: data.total_valid_days ? Number(data.total_valid_days) : undefined,
            avg_daily_high_low: data.avg_daily_high_low ? Number(data.avg_daily_high_low) : undefined,
            median_daily_volume: data.median_daily_volume ? Number(data.median_daily_volume) : undefined,
            avg_trading_ratio: data.avg_trading_ratio ? Number(data.avg_trading_ratio) : undefined,
            N1_Pattern_count: data.N1_Pattern_count ? Number(data.N1_Pattern_count) : undefined,
            // Legacy fields for backward compatibility
            avg_daily_high_low_range: data.avg_daily_high_low_range ? Number(data.avg_daily_high_low_range) : undefined,
            avg_daily_volume: data.avg_daily_volume ? Number(data.avg_daily_volume) : undefined,
            avg_trading_capital: data.avg_trading_capital ? Number(data.avg_trading_capital) : undefined,
            instrument_token: data.instrument_token,
            tradingsymbol: data.tradingsymbol,
          };
          
          results.push(cleanData);
        })
        .on('end', () => {
          console.log(`Successfully loaded ${results.length} companies from watchlist ${watchlist}`);
          resolve(results);
        })
        .on('error', (error) => {
          console.error(`Error reading watchlist CSV: ${error}`);
          reject(error);
        });
    });
  }

  async getAllCompaniesWithExchange(watchlist: string, date?: string): Promise<Company[]> {
    const companies = await this.getWatchlistData(watchlist, date);
    
    // Filter and enhance companies with exchange information
    return companies.filter(company => 
      company.company_code && 
      company.name && 
      company.exchange &&
      ['NSE', 'BSE'].includes(company.exchange.toUpperCase())
    );
  }

  async checkWatchlistExists(watchlist: string, date?: string): Promise<boolean> {
    const targetDate = date || moment().format('YYYY-MM-DD');
    const fileName = `watchlist_${watchlist}_${targetDate}.csv`;
    const filePath = path.join(this.basePath, fileName);
    
    return fs.existsSync(filePath);
  }
}


================================================================================
FILE: apps/backend/src/watchlist/watchlist.controller.ts
PURPOSE: API endpoints for watchlist operations
================================================================================

import { Controller, Get, Param, Query } from '@nestjs/common';
import { WatchlistService, Company } from './watchlist.service';

@Controller('api/watchlist')
export class WatchlistController {
  constructor(private readonly watchlistService: WatchlistService) {}

  @Get(':watchlist')
  async getWatchlist(
    @Param('watchlist') watchlist: string,
    @Query('date') date?: string,
    @Query('exchange') exchange?: string,
  ): Promise<{ companies: Company[], exists: boolean }> {
    try {
      const allCompanies = await this.watchlistService.getAllCompaniesWithExchange(watchlist, date);
      
      // Filter by exchange if specified
      let companies = allCompanies;
      if (exchange) {
        const exchanges = exchange.split(',').map(ex => ex.trim().toUpperCase());
        companies = allCompanies.filter(company => 
          exchanges.includes(company.exchange.toUpperCase())
        );
      }
      
      console.log(`Retrieved ${companies.length} companies from watchlist ${watchlist} for exchanges: ${exchange || 'ALL'}`);
      return { companies, exists: true };
    } catch (error) {
      console.error(`Error fetching watchlist ${watchlist}:`, error);
      return { companies: [], exists: false };
    }
  }

  @Get(':watchlist/check')
  async checkWatchlist(
    @Param('watchlist') watchlist: string,
    @Query('date') date?: string,
  ): Promise<{ exists: boolean }> {
    const exists = await this.watchlistService.checkWatchlistExists(watchlist, date);
    return { exists };
  }

  @Get(':watchlist/exchanges')
  async getWatchlistExchanges(
    @Param('watchlist') watchlist: string,
    @Query('date') date?: string,
  ): Promise<{ exchanges: string[] }> {
    try {
      const companies = await this.watchlistService.getWatchlistData(watchlist, date);
      const exchanges = [...new Set(companies.map(c => c.exchange).filter(Boolean))];
      return { exchanges };
    } catch (error) {
      return { exchanges: [] };
    }
  }
}


================================================================================
FILE: apps/backend/src/watchlist/watchlist.module.ts
PURPOSE: Module configuration
================================================================================

// src/watchlist/watchlist.module.ts
import { Module } from '@nestjs/common';
import { WatchlistController } from './watchlist.controller';
import { WatchlistService } from './watchlist.service';

@Module({
  controllers: [WatchlistController],
  providers: [WatchlistService],
})
export class WatchlistModule {}


################################################################################
SECTION 2: DATA AND ENTITY FILES
################################################################################

================================================================================
FILE: apps/backend/src/stock/entities/stock.entity.ts
PURPOSE: Entity with marker field and company_code/exchange mapping
================================================================================

import { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';

@Entity({ name: 'stock_prices' }) 
export class StockData {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'varchar', length: 50 }) 
  company_code: string;  

  @Column({ type: 'varchar', length: 10 })
  exchange: string;  

  @Column('timestamp') 
  date: Date;

  @Column('float')
  open: number;

  @Column('float')
  high: number;

  @Column('float')
  low: number;

  @Column('float')
  close: number;

  @Column('int')
  volume: number;

  @Column('timestamp')
  start_date: Date;

  @Column('timestamp')
  end_date: Date;
}


================================================================================
FILE: apps/backend/src/stock/dto/stock-data.dto.ts
PURPOSE: DTOs for new data structure
================================================================================

export class StockDataRequestDto {
  companyCode: string;  
  exchange?: string;
  startDate?: Date;
  endDate?: Date;
  interval: string;
  indicators: string[];
  firstFifteenMinutes?: boolean;
}

export class StockDataDto {
  interval_start: Date;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
}


================================================================================
FILE: apps/backend/src/stock/dto/stock-filter.dto.ts
PURPOSE: Filtering capabilities for markers
================================================================================



================================================================================
FILE: apps/backend/src/stock/stocks.service.ts
PURPOSE: Data merging logic
================================================================================

import { Injectable, InternalServerErrorException, RequestTimeoutException, Logger, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { StockData } from './entities/stock.entity';
import { StockDataDto, StockDataRequestDto } from './dto/stock-data.dto';
import { exec } from 'child_process';
import * as path from 'path';

interface CacheEntry {
  data: StockDataDto[];
  timestamp: number;
  startDate: Date;
  endDate: Date;
  interval: string;
  companyCode: string;
}

interface DataGap {
  start: Date;
  end: Date;
  type: 'before' | 'after' | 'within';
}

@Injectable()
export class StockService {
  private readonly logger = new Logger(StockService.name);
  private readonly dataCache = new Map<string, CacheEntry>();
  private readonly cacheTTL = 5 * 60 * 1000; // 5 minutes cache TTL
  private readonly maxCacheSize = 100; // Maximum cache entries
  private readonly pendingRequests = new Map<string, Promise<StockDataDto[]>>();

  constructor(
    @InjectRepository(StockData)
    private stockRepository: Repository<StockData>,
  ) {
    // Clean up cache periodically
    setInterval(() => this.cleanupCache(), 60 * 1000); // Every minute
  }

  /**
   * Existing method - Get top 5 companies by average close price
   */
  async getTop5Companies() {
    return this.stockRepository
      .createQueryBuilder('stock')
      .select('stock.company_code', 'companyCode')
      .addSelect('stock.exchange', 'exchange')
      .addSelect('AVG(stock.close)', 'averageClose')
      .where('stock.exchange IN (:...exchanges)', { exchanges: ['NSE', 'BSE'] })
      .groupBy('stock.company_code, stock.exchange')
      .orderBy('"averageClose"', 'DESC')
      .limit(5)
      .getRawMany();
  }

  /**
   * Existing method - Get company historical data from database
   */
  async getCompanyHistory(companyCode: string, exchange?: string) {
    const queryBuilder = this.stockRepository
      .createQueryBuilder('stock')
      .where('stock.company_code = :companyCode', { companyCode });
    
    if (exchange) {
      queryBuilder.andWhere('stock.exchange = :exchange', { exchange });
    } else {
      queryBuilder.andWhere('stock.exchange IN (:...exchanges)', { exchanges: ['NSE', 'BSE'] });
    }
    
    return queryBuilder
      .orderBy('stock.date', 'ASC')
      .getMany();
  }

  /**
   * Enhanced method to get stock data with intelligent caching and optimization
   */
  async getStockDataFromPython(params: StockDataRequestDto): Promise<StockDataDto[]> {
    try {
      this.validateRequest(params);
      
      const startTime = Date.now();
      this.logger.log(`Fetching stock data for ${params.companyCode} from ${params.startDate} to ${params.endDate}`);

      // Check if we can serve from cache
      const cachedData = this.getCachedData(params);
      if (cachedData) {
        this.logger.log(`Serving data from cache for ${params.companyCode}`);
        return cachedData;
      }

      // Check for pending requests to avoid duplicates
      const requestKey = this.generateRequestKey(params);
      const pendingRequest = this.pendingRequests.get(requestKey);
      if (pendingRequest) {
        this.logger.log(`Request already pending for ${requestKey}, waiting...`);
        return await pendingRequest;
      }

      // Create and execute the data fetch promise
      const dataPromise = this.executeStockDataFetch(params);
      this.pendingRequests.set(requestKey, dataPromise);

      try {
        const data = await dataPromise;
        
        // Cache the result
        this.setCachedData(params, data);
        
        this.logger.log(`Successfully fetched ${data.length} data points for ${params.companyCode} in ${Date.now() - startTime}ms`);
        return data;
        
      } finally {
        this.pendingRequests.delete(requestKey);
      }

    } catch (error) {
      this.logger.error(`Error fetching stock data for ${params.companyCode}:`, error);
      throw error;
    }
  }

  /**
   * Core method to execute stock data fetch from Python - FIXED stderr handling
   */
  private async executeStockDataFetch(params: StockDataRequestDto): Promise<StockDataDto[]> {
    return new Promise((resolve, reject) => {
      const scriptPath = path.resolve(__dirname, '../../data/data_fetch.py');
      
      let command = `python ${scriptPath} --company_code=${params.companyCode} --interval=${params.interval}`;
      
      // Exchange handling
      if (params.exchange) {
        command += ` --exchange=${params.exchange}`;
      } else {
        command += ` --exchange=NSE,BSE`;
      }
      
      // Enhanced date range handling
      if (params.startDate && params.endDate) {
        // Convert to IST for better compatibility
        const startIST = new Date(params.startDate.getTime() + 5.5 * 60 * 60 * 1000);
        const endIST = new Date(params.endDate.getTime() + 5.5 * 60 * 60 * 1000);
        
        command += ` --start_date="${startIST.toISOString()}" --end_date="${endIST.toISOString()}"`;
        command += ' --optimize_for_range=true'; // Range optimization flag
        
        // Add buffer for smooth scrolling
        const bufferMinutes = this.getBufferMinutes(params.interval);
        command += ` --buffer_minutes=${bufferMinutes}`;
        
        if (params.firstFifteenMinutes) {
          command += ' --first_fifteen_minutes=true';
        }
      } else {
        command += ' --fetch_all_data=true';
        command += ' --limit=10000'; // Prevent excessive data
      }
      
      // Performance optimizations
      command += ' --enable_cache=true';
      command += ' --compression=true';
      command += ' --validate_data=true';
      
      // Add indicators support
      if (params.indicators && params.indicators.length > 0) {
        command += ` --indicators="${params.indicators.join(',')}"`;
      }
      
      this.logger.debug(`Executing optimized command: ${command}`);
      
      const timeout = this.getTimeoutForRange(params);
      
      const timeoutId = setTimeout(() => {
        this.logger.error(`Python script execution timed out after ${timeout}ms`);
        reject(new RequestTimeoutException('Data fetch request timed out. Please try a smaller date range.'));
      }, timeout);
      
      const childProcess = exec(command, { 
        maxBuffer: 1024 * 1024 * 100, // 100MB buffer for large datasets
        timeout: timeout,
        cwd: path.resolve(__dirname, '../../data')
      }, (error, stdout, stderr) => {
        clearTimeout(timeoutId);
        
        if (error) {
          this.logger.error(`Python script execution failed: ${error.message}`);
          
          // Fix #2: Proper type handling for error.code
          if (typeof error.code === 'string' && error.code === 'ENOENT') {
            return reject(new InternalServerErrorException('Python environment not configured properly'));
          }
          
          if (error.signal === 'SIGTERM') {
            return reject(new RequestTimeoutException('Request was cancelled due to timeout'));
          }
          
          return reject(new InternalServerErrorException(`Failed to fetch stock data: ${error.message}`));
        }
        
        // ENHANCED stderr handling - properly categorize messages
        if (stderr) {
          const lines = stderr.split('\n').filter(line => line.trim());
          
          // Categorize stderr output intelligently
        const actualErrors: string[] = [];
const warnings: string[] = [];
const infoMessages: string[] = [];

          
          for (const line of lines) {
            const lowerLine = line.toLowerCase();
            
            // Actual error patterns that should fail the request
            if (lowerLine.includes('error:') || 
                lowerLine.includes('traceback') || 
                lowerLine.includes('exception:') ||
                lowerLine.includes('failed:') ||
                lowerLine.includes('critical:') ||
                lowerLine.includes('database connection failed') ||
                lowerLine.includes('no company found') ||
                lowerLine.startsWith('error ')) {
              actualErrors.push(line);
            }
            // Warning patterns
            else if (lowerLine.includes('warning') || 
                     lowerLine.includes('userwarning') ||
                     lowerLine.includes('deprecation') ||
                     lowerLine.includes('skipped') && lowerLine.includes('invalid')) {
              warnings.push(line);
            }
            // Informational messages (should NOT cause failures)
            else if (lowerLine.includes('fetching') ||
                     lowerLine.includes('data range:') ||
                     lowerLine.includes('successfully') ||
                     lowerLine.includes('query executed') ||
                     lowerLine.includes('found') && lowerLine.includes('company') ||
                     lowerLine.includes('looking up') ||
                     lowerLine.includes('applied') && lowerLine.includes('buffer') ||
                     lowerLine.includes('processing') ||
                     lowerLine.includes('completed') ||
                     lowerLine.includes('data points') ||
                     lowerLine.includes('querying') ||
                     lowerLine.includes('filtered to') ||
                     lowerLine.includes('adjusted for') ||
                     lowerLine.includes('records for company') ||
                     lowerLine.includes('in ') && lowerLine.includes('s')) {
              infoMessages.push(line);
            }
            // Default: treat unknown stderr as potential warning, not error
            else if (line.trim()) {
              warnings.push(line);
            }
          }
          
          // Log different types appropriately
          if (infoMessages.length > 0) {
            this.logger.log(`Python script info: ${infoMessages.join('; ')}`);
          }
          
          if (warnings.length > 0) {
            this.logger.warn(`Python script warnings: ${warnings.join('; ')}`);
          }
          
          // ONLY fail on ACTUAL errors, not informational messages or warnings
          if (actualErrors.length > 0) {
            this.logger.error(`Python script errors: ${actualErrors.join('; ')}`);
            return reject(new InternalServerErrorException('Data processing failed with errors'));
          }
        }
        
        try {
          const results = this.parseOptimizedOutput(stdout, params);
          
          if (results.length === 0) {
            this.logger.warn(`No data found for ${params.companyCode} in the specified range`);
            return resolve([]);
          }
          
          // Validate and process data
          const processedResults = this.processAndValidateData(results, params);
          
          this.logger.log(`Successfully processed ${processedResults.length} data points for ${params.companyCode}`);
          resolve(processedResults);
          
        } catch (parseError) {
          this.logger.error(`Error parsing Python script output:`, parseError);
          this.logger.debug(`Raw stdout: ${stdout.substring(0, 1000)}...`);
          reject(new InternalServerErrorException('Failed to parse stock data. Data format may be invalid.'));
        }
      });
      
      // Handle process errors
      childProcess.on('error', (error) => {
        clearTimeout(timeoutId);
        this.logger.error(`Child process error: ${error.message}`);
        reject(new InternalServerErrorException(`Data fetch process failed: ${error.message}`));
      });
      
      // Handle process exit codes
      childProcess.on('exit', (code, signal) => {
        if (code !== 0 && code !== null) {
          this.logger.error(`Python script exited with code ${code}`);
        }
        if (signal) {
          this.logger.warn(`Python script terminated by signal ${signal}`);
        }
      });
    });
  }

  /**
   * Enhanced parsing with comprehensive error handling
   */
  private parseOptimizedOutput(stdout: string, params: StockDataRequestDto): StockDataDto[] {
    const lines = stdout.trim().split('\n');
    const results: StockDataDto[] = [];
    let errorCount = 0;
    const maxErrors = 10; // Maximum parsing errors to tolerate
    
    for (const line of lines) {
      if (line.startsWith('Interval:')) {
        try {
          const parts = line.split(',');
          
          if (parts.length < 6) {
            throw new Error(`Insufficient data fields: expected 6, got ${parts.length}`);
          }
          
          const intervalPart = parts[0].replace('Interval:', '').trim();
          const openPart = parseFloat(parts[1].replace('Open:', '').trim());
          const highPart = parseFloat(parts[2].replace('High:', '').trim());
          const lowPart = parseFloat(parts[3].replace('Low:', '').trim());
          const closePart = parseFloat(parts[4].replace('Close:', '').trim());
          const volumePart = parts[5] ? parseFloat(parts[5].replace('Volume:', '').trim()) : 0;
          
          // Comprehensive data validation
          if (isNaN(openPart) || isNaN(highPart) || isNaN(lowPart) || isNaN(closePart)) {
            throw new Error('Invalid numeric values detected');
          }
          
          // Business logic validation
          if (highPart < Math.max(openPart, closePart) || lowPart > Math.min(openPart, closePart)) {
            throw new Error('Invalid OHLC relationship');
          }
          
          // Validate timestamp
          const timestamp = new Date(intervalPart);
          if (isNaN(timestamp.getTime())) {
            throw new Error('Invalid timestamp format');
          }
          
          // Check if timestamp is within expected range
          if (params.startDate && params.endDate) {
            if (timestamp < params.startDate || timestamp > params.endDate) {
              continue; // Skip data outside requested range
            }
          }
          
          results.push({
            interval_start: timestamp,
            open: this.roundToDecimalPlaces(openPart, 2),
            high: this.roundToDecimalPlaces(highPart, 2),
            low: this.roundToDecimalPlaces(lowPart, 2),
            close: this.roundToDecimalPlaces(closePart, 2),
            volume: Math.max(0, Math.round(volumePart)), // Ensure non-negative integer
          });
          
        } catch (err) {
          errorCount++;
          this.logger.warn(`Skipping invalid data line (${errorCount}/${maxErrors}): ${line.substring(0, 100)} - Error: ${(err as Error).message}`);
          
          if (errorCount >= maxErrors) {
            throw new Error(`Too many parsing errors (${errorCount}). Data quality may be poor.`);
          }
        }
      } else if (line.startsWith('ERROR:') || line.startsWith('FATAL:')) {
        throw new Error(`Python script error: ${line}`);
      }
    }
    
    if (errorCount > 0) {
      this.logger.warn(`Parsed data with ${errorCount} errors for ${params.companyCode}`);
    }
    
    return results;
  }

  /**
   * Process and validate data with first fifteen minutes filter
   */
  private processAndValidateData(data: StockDataDto[], params: StockDataRequestDto): StockDataDto[] {
    if (data.length === 0) return data;
    
    // Sort by timestamp
    data.sort((a, b) => a.interval_start.getTime() - b.interval_start.getTime());
    
    // Remove duplicates
    const uniqueData = data.filter((item, index, array) => 
      index === 0 || item.interval_start.getTime() !== array[index - 1].interval_start.getTime()
    );
    
    // Apply first fifteen minutes filter if requested
    if (params.firstFifteenMinutes && uniqueData.length > 0) {
      const startTime = new Date(uniqueData[0].interval_start);
      const endTime = new Date(startTime.getTime() + 15 * 60 * 1000); // 15 minutes
      
      const filteredResults = uniqueData.filter(item => {
        const itemTime = new Date(item.interval_start);
        return itemTime >= startTime && itemTime <= endTime;
      });
      
      this.logger.log(`Filtered to first 15 minutes: ${filteredResults.length} data points`);
      return filteredResults;
    }
    
    // Detect and log data gaps
    const gaps = this.detectDataGaps(uniqueData, params.interval);
    if (gaps.length > 0) {
      this.logger.warn(`Detected ${gaps.length} data gaps for ${params.companyCode}`);
    }
    
    return uniqueData;
  }

  /**
   * Cache management methods
   */
  private generateRequestKey(params: StockDataRequestDto): string {
    const dateKey = params.startDate && params.endDate 
      ? `${params.startDate.getTime()}-${params.endDate.getTime()}`
      : 'all';
    
    const firstFifteenKey = params.firstFifteenMinutes ? '_first15' : '';
    const indicatorsKey = params.indicators?.length > 0 ? `_${params.indicators.join(',')}` : '';
    
    return `${params.companyCode}_${params.interval}_${params.exchange || 'NSE-BSE'}_${dateKey}${firstFifteenKey}${indicatorsKey}`;
  }

  private getCachedData(params: StockDataRequestDto): StockDataDto[] | null {
    const key = this.generateRequestKey(params);
    const cached = this.dataCache.get(key);
    
    if (!cached) return null;
    
    // Check if cache is still valid
    if (Date.now() - cached.timestamp > this.cacheTTL) {
      this.dataCache.delete(key);
      return null;
    }
    
    // Check if cached data covers the requested range
    if (params.startDate && params.endDate) {
      if (cached.startDate > params.startDate || cached.endDate < params.endDate) {
        return null; // Cache doesn't cover full range
      }
    }
    
    return cached.data;
  }

  private setCachedData(params: StockDataRequestDto, data: StockDataDto[]): void {
    if (data.length === 0) return;
    
    const key = this.generateRequestKey(params);
    
    // Implement LRU cache eviction
    if (this.dataCache.size >= this.maxCacheSize) {
      const oldestKey = this.dataCache.keys().next().value;
      this.dataCache.delete(oldestKey);
    }
    
    const cacheEntry: CacheEntry = {
      data,
      timestamp: Date.now(),
      startDate: params.startDate || data[0].interval_start,
      endDate: params.endDate || data[data.length - 1].interval_start,
      interval: params.interval,
      companyCode: params.companyCode
    };
    
    this.dataCache.set(key, cacheEntry);
  }

  private cleanupCache(): void {
    const now = Date.now();
    const keysToDelete: string[] = [];
    
    for (const [key, entry] of this.dataCache.entries()) {
      if (now - entry.timestamp > this.cacheTTL) {
        keysToDelete.push(key);
      }
    }
    
    keysToDelete.forEach(key => this.dataCache.delete(key));
    
    if (keysToDelete.length > 0) {
      this.logger.debug(`Cleaned up ${keysToDelete.length} expired cache entries`);
    }
  }

  /**
   * Data analysis and validation methods
   */
  private detectDataGaps(data: StockDataDto[], interval: string): DataGap[] {
    if (data.length < 2) return [];
    
    const gaps: DataGap[] = [];
    const expectedInterval = this.getIntervalInMs(interval);
    
    for (let i = 1; i < data.length; i++) {
      const timeDiff = data[i].interval_start.getTime() - data[i-1].interval_start.getTime();
      
      if (timeDiff > expectedInterval * 1.5) { // Allow 50% tolerance
        gaps.push({
          start: data[i-1].interval_start,
          end: data[i].interval_start,
          type: 'within'
        });
      }
    }
    
    return gaps;
  }

  /**
   * Utility methods
   */
  private validateRequest(params: StockDataRequestDto): void {
    if (!params.companyCode) {
      throw new BadRequestException('Company code is required');
    }
    
    if (!params.interval) {
      throw new BadRequestException('Interval is required');
    }
    
    if (params.startDate && params.endDate && params.startDate >= params.endDate) {
      throw new BadRequestException('Start date must be before end date');
    }
    
    // Validate date range is not too large
    if (params.startDate && params.endDate) {
      const daysDiff = (params.endDate.getTime() - params.startDate.getTime()) / (1000 * 60 * 60 * 24);
      const maxDays = this.getMaxDaysForInterval(params.interval);
      
      if (daysDiff > maxDays) {
        throw new BadRequestException(`Date range too large for interval ${params.interval}. Maximum ${maxDays} days allowed.`);
      }
    }
  }

  private getBufferMinutes(interval: string): number {
    const bufferMap: { [key: string]: number } = {
      '1m': 15,
      '5m': 60,
      '15m': 180,
      '1h': 720,
      '1d': 1440
    };
    return bufferMap[interval] || 30;
  }

  private getTimeoutForRange(params: StockDataRequestDto): number {
    const baseTimeout = 60000; // 60 seconds (reduced from original 300 seconds)
    
    if (!params.startDate || !params.endDate) {
      return 300000; // 5 minutes for full data (keeping original timeout)
    }
    
    const daysDiff = (params.endDate.getTime() - params.startDate.getTime()) / (1000 * 60 * 60 * 24);
    return Math.round(Math.min(baseTimeout + (daysDiff * 2000), 300000));
  }

  private getMaxDaysForInterval(interval: string): number {
    const maxDaysMap: { [key: string]: number } = {
      '1m': 365,
      '5m': 365,
      '15m': 365,
      '1h': 365,
      '1d': 1825 // 5 years
    };
    return maxDaysMap[interval] || 30;
  }

  private getIntervalInMs(interval: string): number {
    const intervalMap: { [key: string]: number } = {
      '1m': 60 * 1000,
      '5m': 5 * 60 * 1000,
      '15m': 15 * 60 * 1000,
      '1h': 60 * 60 * 1000,
      '1d': 24 * 60 * 60 * 1000
    };
    return intervalMap[interval] || 60 * 1000;
  }

  private roundToDecimalPlaces(value: number, places: number): number {
    return Math.round(value * Math.pow(10, places)) / Math.pow(10, places);
  }

  /**
   * Public utility methods for cache management and monitoring
   */
  public clearCache(): void {
    this.dataCache.clear();
    this.pendingRequests.clear();
    this.logger.log('Stock data cache and pending requests cleared');
  }

  public getCacheStats(): any {
    return {
      size: this.dataCache.size,
      maxSize: this.maxCacheSize,
      ttl: this.cacheTTL,
      pendingRequests: this.pendingRequests.size,
      entries: Array.from(this.dataCache.entries()).map(([key, entry]) => ({
        key,
        companyCode: entry.companyCode,
        interval: entry.interval,
        dataPoints: entry.data.length,
        age: Date.now() - entry.timestamp,
        dateRange: `${entry.startDate.toISOString()} - ${entry.endDate.toISOString()}`
      }))
    };
  }

  /**
   * Method to support incremental data loading for chart scrolling
   */
  async getIncrementalData(
    companyCode: string,
    startDate: Date,
    endDate: Date,
    interval: string,
    exchange?: string,
    indicators: string[] = []
  ): Promise<StockDataDto[]> {
    const params: StockDataRequestDto = {
      companyCode,
      startDate,
      endDate,
      interval,
      exchange,
      firstFifteenMinutes: false,
      indicators
    };

    return this.getStockDataFromPython(params);
  }
}


################################################################################
SECTION 3: DATA PROCESSING FILES
################################################################################

================================================================================
FILE: apps/backend/data/data_fetch.py
PURPOSE: Merging two data sources
================================================================================

import psycopg2
from psycopg2.extras import RealDictCursor
from datetime import datetime, timedelta
import argparse
import sys
import json
import time
import logging

# Configure logging with proper levels
logging.basicConfig(
    level=logging.INFO,
    format='INFO: %(message)s',
    stream=sys.stderr
)

logger = logging.getLogger(__name__)

def main():
    parser = argparse.ArgumentParser(description='Fetch and aggregate stock data.')
    parser.add_argument('--company_code', type=str, required=True, help='Company code to fetch data for')
    parser.add_argument('--exchange', type=str, default='NSE,BSE', help='Exchange filter (NSE, BSE, or NSE,BSE)')
    parser.add_argument('--start_date', type=str, default='2024-02-22 00:00:00', help='Start date and time (ISO format or YYYY-MM-DD HH:MM:SS)')
    parser.add_argument('--end_date', type=str, default='2024-04-16 00:00:00', help='End date and time (ISO format or YYYY-MM-DD HH:MM:SS)')
    parser.add_argument('--interval', type=str, default='10m', help='Interval for aggregation (e.g., 1m, 5m, 10m, 15m, 30m, 1h)')
    parser.add_argument('--first_fifteen_minutes', type=str, default='false', 
                       choices=['true', 'false'],
                       help='Filter to first 15 minutes of trading day')
    parser.add_argument('--fetch_all_data', type=str, default='false',
                       choices=['true', 'false'],
                       help='Fetch all available data for the company (ignores date range)')
    
    # Enhanced arguments for the new StockService
    parser.add_argument('--limit', type=int, default=10000, help='Maximum number of records to return')
    parser.add_argument('--enable_cache', type=str, default='false', 
                       choices=['true', 'false'],
                       help='Enable caching (future feature)')
    parser.add_argument('--compression', type=str, default='false',
                       choices=['true', 'false'], 
                       help='Enable compression (future feature)')
    parser.add_argument('--validate_data', type=str, default='true',
                       choices=['true', 'false'],
                       help='Enable data validation')
    parser.add_argument('--optimize_for_range', type=str, default='false',
                       choices=['true', 'false'],
                       help='Optimize query for date range requests')
    parser.add_argument('--buffer_minutes', type=int, default=30,
                       help='Buffer minutes to add around date range')
    parser.add_argument('--indicators', type=str, default='',
                       help='Comma-separated list of indicators (future feature)')
    parser.add_argument('--parallel_processing', type=str, default='false',
                       choices=['true', 'false'],
                       help='Enable parallel processing (future feature)')
    
    args = parser.parse_args()
    
    # Parse boolean arguments
    first_fifteen_minutes = args.first_fifteen_minutes.lower() == 'true'
    fetch_all_data = args.fetch_all_data.lower() == 'true'
    enable_cache = args.enable_cache.lower() == 'true'
    compression = args.compression.lower() == 'true'
    validate_data = args.validate_data.lower() == 'true'
    optimize_for_range = args.optimize_for_range.lower() == 'true'
    parallel_processing = args.parallel_processing.lower() == 'true'
    
    # Parse indicators
    indicators = [ind.strip() for ind in args.indicators.split(',') if ind.strip()] if args.indicators else []
    
    if fetch_all_data:
        start_date = None
        end_date = None
        logger.info(f"Fetching all available data for company_code={args.company_code} on exchanges={args.exchange} (limit={args.limit})")
    else:
        try:
            start_date = parse_date_string(args.start_date)
            end_date = parse_date_string(args.end_date)
            
            # Apply buffer for range optimization
            if optimize_for_range and args.buffer_minutes > 0:
                buffer_delta = timedelta(minutes=args.buffer_minutes)
                start_date = start_date - buffer_delta
                end_date = end_date + buffer_delta
                logger.info(f"Applied {args.buffer_minutes}min buffer: {start_date} to {end_date}")
            
            if first_fifteen_minutes:
                start_date, end_date = adjust_for_first_fifteen_minutes(start_date, end_date)
                
        except ValueError as e:
            logger.error(f"Date parsing error: {e}")
            sys.exit(1)
    
    # Interval mapping with enhanced support
    interval_map = {
        '1m': 1,
        '5m': 5,
        '10m': 10,
        '15m': 15,
        '30m': 30,
        '1h': 60,
        '2h': 120,
        '4h': 240,
        '1d': 1440
    }
    
    interval_minutes = interval_map.get(args.interval, 10)
    
    # Database connection parameters
    db_params = {
        'dbname': 'company_hist_db',
        'user': 'readonly_user',
        'password': 'db_read_5432',
        'host': '100.93.172.21',
        'port': '5432',
    }

    start_time = time.time()
    
    try:
        # Connect to database with improved error handling
        try:
            conn = psycopg2.connect(**db_params)
            cur = conn.cursor(cursor_factory=RealDictCursor)
        except psycopg2.Error as e:
            logger.error(f"Database connection failed: {e}")
            sys.exit(1)

        # Set timezone
        cur.execute("SET TIME ZONE 'Asia/Kolkata';")

        # Parse exchanges
        exchanges = [ex.strip() for ex in args.exchange.split(',') if ex.strip()]
        exchange_placeholders = ','.join(['%s'] * len(exchanges))

        # Company lookup with enhanced error handling
        company_lookup_query = f"""
        SELECT company_id, company_code, name, exchange
        FROM companies
        WHERE company_code = %s
        AND exchange IN ({exchange_placeholders})
        """
        
        company_params = [args.company_code] + exchanges
        logger.info(f"Looking up company: {args.company_code} on exchanges: {args.exchange}")
        
        cur.execute(company_lookup_query, company_params)
        company_records = cur.fetchall()
        
        if not company_records:
            logger.error(f"No company found with code '{args.company_code}' on exchanges {args.exchange}")
            sys.exit(1)
        
        company_ids = [record['company_id'] for record in company_records]
        company_id_placeholders = ','.join(['%s'] * len(company_ids))
        
        logger.info(f"Found {len(company_records)} company records")
        for record in company_records:
            logger.info(f"  - {record['company_code']} ({record['name']}) on {record['exchange']} [ID: {record['company_id']}]")

        # Build optimized query based on request type
        if fetch_all_data:
            if optimize_for_range:
                # Optimized query for large datasets
                stock_data_query = f"""
                SELECT timestamp, open, high, low, close, volume, company_id
                FROM company_data
                WHERE company_id IN ({company_id_placeholders})
                ORDER BY timestamp DESC
                LIMIT %s
                """
                query_params = company_ids + [args.limit]
                logger.info(f"Querying RECENT {args.limit} records for company_ids: {company_ids}")
            else:
                stock_data_query = f"""
                SELECT timestamp, open, high, low, close, volume, company_id
                FROM company_data
                WHERE company_id IN ({company_id_placeholders})
                ORDER BY timestamp
                """
                query_params = company_ids
                logger.info(f"Querying ALL stock data for company_ids: {company_ids}")
        else:
            if optimize_for_range:
                # Optimized range query with indexes
                stock_data_query = f"""
                SELECT timestamp, open, high, low, close, volume, company_id
                FROM company_data
                WHERE company_id IN ({company_id_placeholders})
                AND timestamp >= %s
                AND timestamp < %s
                ORDER BY timestamp
                LIMIT %s
                """
                query_params = company_ids + [start_date, end_date, args.limit]
            else:
                stock_data_query = f"""
                SELECT timestamp, open, high, low, close, volume, company_id
                FROM company_data
                WHERE company_id IN ({company_id_placeholders})
                AND timestamp >= %s
                AND timestamp < %s
                ORDER BY timestamp
                """
                query_params = company_ids + [start_date, end_date]
            
            logger.info(f"Querying stock data for company_ids: {company_ids}, date range: {start_date} to {end_date}")
        
        # Execute query with timing
        query_start = time.time()
        cur.execute(stock_data_query, query_params)
        rows = cur.fetchall()
        query_time = time.time() - query_start
        
        logger.info(f"Query executed in {query_time:.2f}s, fetched {len(rows)} raw records")
        
        if not rows:
            if fetch_all_data:
                logger.info(f"No stock data found for company_code='{args.company_code}' on exchanges={args.exchange}")
            else:
                logger.info(f"No stock data found for company_code='{args.company_code}' on exchanges={args.exchange} in date range {start_date} to {end_date}")
            sys.exit(0)

        # Apply limit for all data requests (if not already limited in query)
        if fetch_all_data and not optimize_for_range and len(rows) > args.limit:
            logger.info(f"Large dataset detected ({len(rows)} records). Limiting to most recent {args.limit} records.")
            rows = rows[-args.limit:]

        # Data aggregation with enhanced error handling
        def get_interval_start(dt):
            minute = dt.minute
            interval_minute = (minute // interval_minutes) * interval_minutes
            return dt.replace(minute=interval_minute, second=0, microsecond=0)

        # Process data into intervals
        processing_start = time.time()
        interval_data = {}
        invalid_records = 0
        
        for row in rows:
            # Data validation if enabled
            if validate_data:
                if not validate_ohlcv_data(row):
                    invalid_records += 1
                    continue
            
            interval_start = get_interval_start(row['timestamp'])
            if interval_start not in interval_data:
                interval_data[interval_start] = []
            interval_data[interval_start].append(row)

        if invalid_records > 0:
            logging.warning(f"Skipped {invalid_records} invalid records during validation")

        # Aggregate intervals
        results = []
        for interval_start in sorted(interval_data.keys()):
            interval_rows = interval_data[interval_start]
            if interval_rows:
                interval_rows.sort(key=lambda x: x['timestamp'])
                
                try:
                    open_price = float(interval_rows[0]['open'])
                    high_price = max(float(row['high']) for row in interval_rows)
                    low_price = min(float(row['low']) for row in interval_rows)
                    close_price = float(interval_rows[-1]['close'])
                    volume_sum = sum(int(row['volume']) for row in interval_rows)
                    
                    # Additional validation for aggregated data
                    if validate_data and not validate_aggregated_ohlc(open_price, high_price, low_price, close_price):
                        logging.warning(f"Invalid OHLC relationship at {interval_start}, skipping")
                        continue
                    
                    results.append({
                        'interval_start': interval_start,
                        'open': round(open_price, 2),
                        'high': round(high_price, 2),
                        'low': round(low_price, 2),
                        'close': round(close_price, 2),
                        'volume': volume_sum
                    })
                except (ValueError, TypeError) as e:
                    logging.warning(f"Error processing interval {interval_start}: {e}")
                    continue

        processing_time = time.time() - processing_start
        logger.info(f"Data processing completed in {processing_time:.2f}s")

        # Apply first fifteen minutes filter for all data requests
        if first_fifteen_minutes and fetch_all_data:
            filtered_results = []
            for result in results:
                timestamp = result['interval_start']
                if timestamp.hour == 9 and 15 <= timestamp.minute <= 30:
                    filtered_results.append(result)
            results = filtered_results
            logger.info(f"Filtered to first 15 minutes: {len(results)} data points")

        # Sort results by timestamp (important for chart rendering)
        results.sort(key=lambda x: x['interval_start'])

        # Output results in the expected format
        for result in results:
            print(f"Interval:{result['interval_start'].isoformat()},Open:{result['open']},High:{result['high']},Low:{result['low']},Close:{result['close']},Volume:{result['volume']}")
        
        total_time = time.time() - start_time
        
        if fetch_all_data:
            logger.info(f"Successfully fetched ALL available data: {len(results)} data points in {total_time:.2f}s")
        else:
            logger.info(f"Successfully fetched {len(results)} data points for date range in {total_time:.2f}s")

        # Performance statistics
        if len(results) > 0:
            logger.info(f"Data range: {results[0]['interval_start']} to {results[-1]['interval_start']}")
            
        # Future: Indicator calculations
        if indicators:
            logger.info(f"Note: Indicators requested but not yet implemented: {indicators}")

    except psycopg2.Error as e:
        logger.error(f"Database error: {e}")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        import traceback
        traceback.print_exc(file=sys.stderr)
        sys.exit(1)
    finally:
        if 'cur' in locals():
            cur.close()
        if 'conn' in locals():
            conn.close()

def parse_date_string(date_str):
    """Parse date string in various formats with enhanced support"""
    try:
        # Handle ISO format with timezone
        if 'T' in date_str:
            if date_str.endswith('Z'):
                date_str = date_str[:-1] + '+00:00'
            # Try to parse with timezone info
            try:
                dt = datetime.fromisoformat(date_str)
                # Convert to naive datetime in IST
                if dt.tzinfo is not None:
                    import pytz
                    ist = pytz.timezone('Asia/Kolkata')
                    dt = dt.astimezone(ist).replace(tzinfo=None)
                return dt
            except:
                # Fallback to naive parsing
                return datetime.fromisoformat(date_str.replace('+00:00', '').replace('Z', ''))
        else:
            return datetime.strptime(date_str, '%Y-%m-%d %H:%M:%S')
    except ValueError:
        # Try multiple formats
        formats = [
            '%Y-%m-%d',
            '%Y-%m-%dT%H:%M:%S',
            '%Y-%m-%dT%H:%M:%S.%f',
            '%Y-%m-%d %H:%M',
            '%d/%m/%Y %H:%M:%S',
            '%d-%m-%Y %H:%M:%S'
        ]
        
        for fmt in formats:
            try:
                return datetime.strptime(date_str, fmt)
            except ValueError:
                continue
        
        raise ValueError(f"Unable to parse date string: {date_str}")

def adjust_for_first_fifteen_minutes(start_date, end_date):
    """Adjust dates for first 15 minutes of trading day with enhanced logic"""
    # Handle timezone conversion
    if start_date.tzinfo is not None:
        ist_offset = timedelta(hours=5, minutes=30)
        start_date = start_date.replace(tzinfo=None) + ist_offset
    
    # Market opens at 9:15 AM, so first 15 minutes is 9:15 to 9:30
    market_start = start_date.replace(hour=9, minute=15, second=0, microsecond=0)
    market_end = market_start + timedelta(minutes=15)  # Corrected: 15 minutes, not 375
    
    logger.info(f"Adjusted for first 15 minutes: {market_start} to {market_end}")
    
    return market_start, market_end

def validate_ohlcv_data(row):
    """Validate individual OHLCV data record"""
    try:
        open_price = float(row['open'])
        high_price = float(row['high'])
        low_price = float(row['low'])
        close_price = float(row['close'])
        volume = int(row['volume'])
        
        # Basic validation rules
        if any(x <= 0 for x in [open_price, high_price, low_price, close_price]):
            return False
        
        if volume < 0:
            return False
            
        if high_price < max(open_price, close_price) or low_price > min(open_price, close_price):
            return False
            
        # Check for extreme values (possible data errors)
        if high_price / low_price > 2.0:  # More than 100% intraday move
            return False
            
        return True
    except (ValueError, TypeError, KeyError):
        return False

def validate_aggregated_ohlc(open_price, high_price, low_price, close_price):
    """Validate aggregated OHLC data"""
    try:
        # High must be >= max(open, close)
        if high_price < max(open_price, close_price):
            return False
            
        # Low must be <= min(open, close)
        if low_price > min(open_price, close_price):
            return False
            
        # All prices must be positive
        if any(x <= 0 for x in [open_price, high_price, low_price, close_price]):
            return False
            
        return True
    except (ValueError, TypeError):
        return False

if __name__ == "__main__":
    main()


================================================================================
FILE: apps/backend/data/2.py
PURPOSE: Data processing modifications
================================================================================


import psycopg2
from psycopg2.extras import RealDictCursor
from datetime import datetime

db_params = {
    'dbname': 'temp_db',
    'user': 'temp_raghav',
    'password': 'password',
    'host': '100.93.172.21',
    'port': '5432'
}


try:
    conn = psycopg2.connect(**db_params)
    cur = conn.cursor(cursor_factory=RealDictCursor)

    cur.execute("SET TIME ZONE 'Asia/Kolkata';")

    query = """
    SELECT timestamp, open, high, low, close, volume
    FROM company_data
    WHERE company_id = %s
    AND timestamp >= %s
    AND timestamp < %s
    ORDER BY timestamp
    """
    cur.execute(query, (2, '2024-02-22 00:00:00', '2024-04-16 00:00:00'))

    rows = cur.fetchall()
    if not rows:
        print("No data found for company_id = 2 in the specified date range.")
        exit()

    def get_interval_start(dt):
        minute = dt.minute
        interval_minute = (minute // 10) * 10  # Floor to nearest 10
        return dt.replace(minute=interval_minute, second=0, microsecond=0)

    interval_data = {}
    for row in rows:
        interval_start = get_interval_start(row['timestamp'])
        if interval_start not in interval_data:
            interval_data[interval_start] = []
        interval_data[interval_start].append(row)

    results = []
    for interval_start in sorted(interval_data.keys()):
        rows = interval_data[interval_start]
        if rows:
            open_price = rows[0]['open']               # First open
            high_price = max(row['high'] for row in rows)  # Max high
            low_price = min(row['low'] for row in rows)    # Min low
            close_price = rows[-1]['close']            # Last close
            volume_sum = sum(row['volume'] for row in rows)  # Sum volume
            results.append({
                'interval_start': interval_start,
                'open': open_price,
                'high': high_price,
                'low': low_price,
                'close': close_price,
                'volume': volume_sum
            })

    for result in results:
        print(f"Interval: {result['interval_start']}, "
              f"Open: {result['open']}, High: {result['high']}, "
              f"Low: {result['low']}, Close: {result['close']}, "
              f"Volume: {result['volume']}")

except psycopg2.Error as e:
    print(f"Database error: {e}")

finally:
    # Clean up
    if 'cur' in locals():
        cur.close()
    if 'conn' in locals():
        conn.close()

================================================================================
FILE: apps/backend/data/watchlists/watchlist_A_2025-02-16.csv (HEADER + 5 LINES)
PURPOSE: Sample CSV format with marker data
================================================================================

[CSV HEADER AND SAMPLE DATA] 
1:company_code,avg_daily_high_low_range,avg_daily_volume,avg_trading_capital,instrument_token,tradingsymbol,name,exchange
2:2955,6.96127308680475724790,22353730.800000000000,12111357243.77500000,756481,KALYANKJIL,KALYAN JEWELLERS IND,NSE
3:19585,5.24230377747259599650,2147206.500000000000,11693857868.80500000,5013761,BSE,BSE,NSE
4:10604,3.01386922348941073060,6911231.200000000000,11476234362.46000000,2714625,BHARTIARTL,BHARTI AIRTEL,NSE
5:5097,4.15256276148238892340,50692164.700000000000,11437428969.97700000,1304833,ZOMATO,ZOMATO,NSE
6:509,5.70257852059927256650,5117698.200000000000,11259823337.91000000,130305,MAZDOCK,MAZAGON DOCK SHIPBUIL,NSE


################################################################################
SECTION 4: FRONTEND WATCHLIST MANAGEMENT
################################################################################

================================================================================
FILE: apps/frontend/app/market-data/components/WatchlistManager.tsx
PURPOSE: UI for new data structure management
================================================================================

'use client';

import React, { useState, useEffect } from 'react';
import { Card, CardHeader, CardTitle, CardContent } from '../../../components/ui/card';
import { Button } from '../../../components/ui/button';
import { Input } from '../../../components/ui/input';

interface WatchlistManagerProps {
  subscribedSymbols: string[];
  onSymbolSelect: (symbol: string) => void;
  onAddSymbol: (symbol: string) => void;
  onRemoveSymbol: (symbol: string) => void;
}

// Predefined watchlists
const predefinedWatchlists = {
  'Indices': [
    'NSE:NIFTY50-INDEX',
    'NSE:BANKNIFTY-INDEX',
    'NSE:FINNIFTY-INDEX',
    'NSE:NIFTYIT-INDEX',
    'NSE:NIFTYPHARMA-INDEX',
  ],
  'Large Cap': [
    'NSE:RELIANCE-EQ',
    'NSE:TCS-EQ',
    'NSE:HDFCBANK-EQ',
    'NSE:INFY-EQ',
    'NSE:ICICIBANK-EQ',
  ],
  'IT Stocks': [
    'NSE:TCS-EQ',
    'NSE:INFY-EQ',
    'NSE:WIPRO-EQ',
    'NSE:HCLTECH-EQ',
    'NSE:TECHM-EQ',
  ],
};

const WatchlistManager: React.FC<WatchlistManagerProps> = ({
  subscribedSymbols,
  onSymbolSelect,
  onAddSymbol,
  onRemoveSymbol,
}) => {
  const [newSymbol, setNewSymbol] = useState('');
  const [savedWatchlists, setSavedWatchlists] = useState<Record<string, string[]>>({});
  const [newWatchlistName, setNewWatchlistName] = useState('');
  const [showSaveDialog, setShowSaveDialog] = useState(false);

  // Load saved watchlists from localStorage
  useEffect(() => {
    const saved = localStorage.getItem('marketDataWatchlists');
    if (saved) {
      setSavedWatchlists(JSON.parse(saved));
    }
  }, []);

  const handleAddSymbol = (e: React.FormEvent) => {
    e.preventDefault();
    if (newSymbol && !subscribedSymbols.includes(newSymbol)) {
      onAddSymbol(newSymbol);
      setNewSymbol('');
    }
  };

  const handleSaveWatchlist = () => {
    if (newWatchlistName) {
      const updatedWatchlists = {
        ...savedWatchlists,
        [newWatchlistName]: [...subscribedSymbols],
      };
      
      setSavedWatchlists(updatedWatchlists);
      localStorage.setItem('marketDataWatchlists', JSON.stringify(updatedWatchlists));
      setNewWatchlistName('');
      setShowSaveDialog(false);
    }
  };

  const handleLoadWatchlist = (watchlist: string[]) => {
    // Remove all current symbols
    subscribedSymbols.forEach(symbol => onRemoveSymbol(symbol));
    
    // Add all symbols from the selected watchlist
    watchlist.forEach(symbol => onAddSymbol(symbol));
  };

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Add Symbol</CardTitle>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleAddSymbol} className="space-y-4">
            <div className="flex gap-2">
              <Input
                type="text"
                placeholder="NSE:SYMBOL-EQ"
                value={newSymbol}
                onChange={(e) => setNewSymbol(e.target.value)}
                className="flex-1"
              />
              <Button type="submit">Add</Button>
            </div>
            <div className="text-sm text-muted-foreground">
              Format: Exchange:Symbol-Type (e.g., NSE:RELIANCE-EQ)
            </div>
          </form>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Predefined Watchlists</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {Object.entries(predefinedWatchlists).map(([name, symbols]) => (
            <div key={name} className="flex justify-between items-center">
              <div>
                <div className="font-medium">{name}</div>
                <div className="text-sm text-muted-foreground">
                  {symbols.length} symbols
                </div>
              </div>
              <Button 
                variant="outline" 
                size="sm"
                onClick={() => handleLoadWatchlist(symbols)}
              >
                Load
              </Button>
            </div>
          ))}
        </CardContent>
      </Card>

      {Object.keys(savedWatchlists).length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle>Your Watchlists</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            {Object.entries(savedWatchlists).map(([name, symbols]) => (
              <div key={name} className="flex justify-between items-center">
                <div>
                  <div className="font-medium">{name}</div>
                  <div className="text-sm text-muted-foreground">
                    {symbols.length} symbols
                  </div>
                </div>
                <div className="flex gap-2">
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={() => handleLoadWatchlist(symbols)}
                  >
                    Load
                  </Button>
                  <Button 
                    variant="outline" 
                    size="sm"
                    className="text-red-500"
                    onClick={() => {
                      const { [name]: _, ...rest } = savedWatchlists;
                      setSavedWatchlists(rest);
                      localStorage.setItem('marketDataWatchlists', JSON.stringify(rest));
                    }}
                  >
                    Delete
                  </Button>
                </div>
              </div>
            ))}
          </CardContent>
        </Card>
      )}

      <Card>
        <CardHeader>
          <CardTitle>Manage Watchlist</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <Button 
            variant="outline" 
            className="w-full"
            onClick={() => setShowSaveDialog(!showSaveDialog)}
          >
            Save Current Watchlist
          </Button>
          
          {showSaveDialog && (
            <div className="space-y-2">
              <Input
                type="text"
                placeholder="Watchlist name"
                value={newWatchlistName}
                onChange={(e) => setNewWatchlistName(e.target.value)}
              />
              <div className="flex gap-2">
                <Button 
                  variant="default" 
                  className="flex-1"
                  onClick={handleSaveWatchlist}
                >
                  Save
                </Button>
                <Button 
                  variant="outline" 
                  onClick={() => setShowSaveDialog(false)}
                >
                  Cancel
                </Button>
              </div>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
};

export default WatchlistManager;


================================================================================
FILE: apps/frontend/app/components/controllers/WatchlistSelector/WatchlistSelector.tsx
PURPOSE: Selector for new format
================================================================================

'use client'
import * as React from "react";
import { useWatchlist } from "@/hooks/useWatchlist";
import { RadioGroupDemo } from "./RadioGroup";
import { SelectScrollable } from "./SelectScrollable";

interface WatchlistSelectorProps {
  onCompanySelect?: (companyCode: string | null, exchange?: string) => void;
  selectedWatchlist?: string;
  onWatchlistChange?: (watchlist: string) => void;
}

export function WatchlistSelector({ 
  onCompanySelect,
  selectedWatchlist: externalSelectedWatchlist,
  onWatchlistChange
}: WatchlistSelectorProps) {
  const {
    selectedWatchlist: internalSelectedWatchlist,
    setSelectedWatchlist: internalSetSelectedWatchlist,
    companies,
    loading,
    error,
    exists,
    availableExchanges,
  } = useWatchlist();
  
  const effectiveWatchlist = externalSelectedWatchlist || internalSelectedWatchlist;
  
  const handleWatchlistChange = (value: string) => {
    if (onWatchlistChange) {
      onWatchlistChange(value);
    } else {
      internalSetSelectedWatchlist(value);
    }
  };

  const handleCompanySelect = (companyCode: string | null, exchange?: string) => {
    console.log(`Selected company: ${companyCode} on exchange: ${exchange}`);
    if (onCompanySelect) {
      onCompanySelect(companyCode, exchange);
    }
  };

  return (
    <div className="flex gap-5 items-center">
      <div>
        <RadioGroupDemo
          value={effectiveWatchlist} 
          onChange={handleWatchlistChange}
        />
      </div>
      
      {error && (
        <div className="text-destructive text-xs bg-destructive/10 px-2 py-1 rounded">
          {error}
        </div>
      )}
      
      {availableExchanges.length > 0 && (
        <div className="text-xs text-muted-foreground">
          Exchanges: {availableExchanges.join(', ')}
        </div>
      )}
      
      <div>
        <SelectScrollable
          companies={companies}
          loading={loading}
          exists={exists}
          onCompanySelect={handleCompanySelect}
        />
      </div>
    </div>
  );
}


================================================================================
FILE: apps/frontend/app/components/controllers/WatchlistSelector/index.tsx
PURPOSE: Main component wrapper
================================================================================

// src/components/WatchlistSelector/index.tsx
export { WatchlistSelector } from './WatchlistSelector';


################################################################################
SECTION 5: FRONTEND DATA HOOKS
################################################################################

================================================================================
FILE: apps/frontend/hooks/useWatchlist.ts
PURPOSE: New data structure and API calls
================================================================================

import { useState, useEffect } from 'react';

interface Company {
  company_code: string;          
  name: string;                   
  exchange: string;              
  total_valid_days?: number;     
  avg_daily_high_low?: number;
  median_daily_volume?: number;
  avg_trading_ratio?: number;
  N1_Pattern_count?: number;
  avg_daily_high_low_range?: number;
  avg_daily_volume?: number;
  avg_trading_capital?: number;
  instrument_token?: string;
  tradingsymbol?: string;
}

export function useWatchlist() {
  const [selectedWatchlist, setSelectedWatchlist] = useState('A');
  const [companies, setCompanies] = useState<Company[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [exists, setExists] = useState(true);
  const [availableExchanges, setAvailableExchanges] = useState<string[]>([]);

  useEffect(() => {
    async function fetchWatchlist() {
      setLoading(true);
      setError(null);

      try {
        const today = '2025-06-05'; 
        
        const apiUrl = `/api/watchlist/${selectedWatchlist}?date=${today}`;
        
        console.log('Fetching watchlist data from:', apiUrl);

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000); 

        const response = await fetch(apiUrl, { signal: controller.signal });
        clearTimeout(timeoutId);

        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }

        const data = await response.json();
        console.log('Watchlist data received:', data);

        const validCompanies = (data.companies || []).filter((company: Company) => 
          company.company_code && 
          company.name && 
          company.exchange
        );

        setCompanies(validCompanies);
        setExists(data.exists);
        
        const exchanges = [...new Set(validCompanies.map((c: Company) => c.exchange))];
        setAvailableExchanges(exchanges);
        
        console.log(`Loaded ${validCompanies.length} companies from watchlist ${selectedWatchlist}`);
        
      } catch (err) {
        console.error('Error fetching watchlist data:', err);
        setError('Failed to fetch watchlist data');
        setCompanies([]);
        setExists(false);
        setAvailableExchanges([]);
      } finally {
        setLoading(false);
      }
    }

    fetchWatchlist();
  }, [selectedWatchlist]);

  return { 
    selectedWatchlist, 
    setSelectedWatchlist, 
    companies, 
    loading, 
    error, 
    exists,
    availableExchanges
  };
}


================================================================================
FILE: apps/frontend/hooks/useStockData.ts
PURPOSE: company_code and marker fields support
================================================================================

// Enhanced useStockData.ts with incremental loading support
import { useState, useCallback, useRef, useEffect } from 'react';

interface StockDataPoint {
  interval_start: string;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
}

interface DataCache {
  [key: string]: StockDataPoint[];
}

interface UseStockDataParams {
  companyCode: string | null;
  exchange?: string;
  interval?: string;
  indicators?: string[];
  enableIncrementalLoading?: boolean;
}

export function useStockData({ 
  companyCode,
  exchange = 'NSE',
  interval = '1m',
  indicators = [],
  enableIncrementalLoading = true
}: UseStockDataParams) {
  const [data, setData] = useState<StockDataPoint[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [dataRange, setDataRange] = useState<{ start: Date | null; end: Date | null }>({ start: null, end: null });
  
  const abortControllerRef = useRef<AbortController | null>(null);
  const cacheRef = useRef<DataCache>({});
  const loadingQueueRef = useRef<Set<string>>(new Set());

  // Generate cache key
  const getCacheKey = useCallback((company: string, start: Date, end: Date, interval: string) => {
    return `${company}_${interval}_${start.getTime()}_${end.getTime()}`;
  }, []);

  // Check if data exists in cache
  const getCachedData = useCallback((start: Date, end: Date) => {
    const key = getCacheKey(companyCode || '', start, end, interval);
    return cacheRef.current[key] || null;
  }, [getCacheKey, companyCode, interval]);

  // Store data in cache
  const setCachedData = useCallback((start: Date, end: Date, data: StockDataPoint[]) => {
    const key = getCacheKey(companyCode || '', start, end, interval);
    cacheRef.current[key] = data;
  }, [getCacheKey, companyCode, interval]);

  // Enhanced fetch with caching and queue management
  const fetchData = useCallback(async (
    startDate?: Date, 
    endDate?: Date, 
    options: { 
      fetchAllData?: boolean;
      merge?: boolean;
      priority?: 'high' | 'normal';
    } = {}
  ) => {
    if (!companyCode) {
      setError('No company selected');
      return [];
    }

    const { fetchAllData = false, merge = false, priority = 'normal' } = options;

    if (!startDate && !fetchAllData) {
      setError('Either provide a start date or set fetchAllData to true');
      return [];
    }

    // Generate request key for queue management
    const requestKey = `${companyCode}_${startDate?.getTime()}_${endDate?.getTime()}`;
    
    if (loadingQueueRef.current.has(requestKey)) {
      console.log('Request already in progress, skipping duplicate:', requestKey);
      return [];
    }

    // Check cache first
    if (startDate && endDate && enableIncrementalLoading) {
      const cachedData = getCachedData(startDate, endDate);
      if (cachedData) {
        console.log('Returning cached data for range:', startDate, endDate);
        if (merge) {
          setData(prevData => mergeData(prevData, cachedData));
        } else {
          setData(cachedData);
        }
        return cachedData;
      }
    }

    // Abort previous request if not high priority
    if (abortControllerRef.current && priority !== 'high') {
      abortControllerRef.current.abort();
    }

    loadingQueueRef.current.add(requestKey);
    setLoading(true);
    setError(null);

    try {
      abortControllerRef.current = new AbortController();
      
      const queryParams = new URLSearchParams({
        exchange,
        interval,
        ...indicators.length > 0 && { indicators: indicators.join(',') }
      });

      if (startDate) {
        queryParams.append('startDate', startDate.toISOString());
        queryParams.append('endDate', endDate?.toISOString() || new Date(startDate.getTime() + 6.25 * 60 * 60 * 1000).toISOString());
      } else {
        queryParams.append('fetchAllData', 'true');
      }

      const url = `/api/companies/${companyCode}/ohlcv?${queryParams.toString()}`;
      console.log(`Fetching stock data: ${url}`);

      const response = await fetch(url, { 
        signal: abortControllerRef.current.signal,
        headers: {
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache'
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      
      const jsonData = await response.json() as StockDataPoint[];
      console.log(`Successfully fetched ${jsonData.length} data points`);

      // Cache the data
      if (startDate && endDate && enableIncrementalLoading) {
        setCachedData(startDate, endDate, jsonData);
      }

      // Update data range
      if (jsonData.length > 0) {
        const newStart = new Date(jsonData[0].interval_start);
        const newEnd = new Date(jsonData[jsonData.length - 1].interval_start);
        
        setDataRange(prev => ({
          start: prev.start ? (newStart < prev.start ? newStart : prev.start) : newStart,
          end: prev.end ? (newEnd > prev.end ? newEnd : prev.end) : newEnd
        }));
      }

      // Merge or replace data
      if (merge) {
        setData(prevData => mergeData(prevData, jsonData));
      } else {
        setData(jsonData);
      }

      return jsonData;
    } catch (err: any) {
      if (err.name === 'AbortError') {
        console.log('Request was aborted');
        return [];
      }
      console.error('Error fetching stock data:', err);
      setError(`Failed to fetch stock data: ${err.message}`);
      return [];
    } finally {
      loadingQueueRef.current.delete(requestKey);
      setLoading(false);
    }
  }, [companyCode, exchange, interval, indicators, enableIncrementalLoading, getCachedData, setCachedData]);

  // Merge data helper function
  const mergeData = useCallback((existing: StockDataPoint[], newData: StockDataPoint[]): StockDataPoint[] => {
    const combined = [...existing, ...newData];
    const uniqueMap = new Map<string, StockDataPoint>();
    
    combined.forEach(item => {
      uniqueMap.set(item.interval_start, item);
    });
    
    return Array.from(uniqueMap.values()).sort((a, b) => 
      new Date(a.interval_start).getTime() - new Date(b.interval_start).getTime()
    );
  }, []);

  // Fetch incremental data
  const fetchIncrementalData = useCallback(async (start: Date, end: Date) => {
    return fetchData(start, end, { merge: true, priority: 'high' });
  }, [fetchData]);

  // Fetch all data
  const fetchAllData = useCallback(async () => {
    return fetchData(undefined, undefined, { fetchAllData: true });
  }, [fetchData]);

  // Clear data and cache
  const clearData = useCallback(() => {
    setData([]);
    setError(null);
    setDataRange({ start: null, end: null });
    cacheRef.current = {};
    loadingQueueRef.current.clear();
  }, []);

  // Smart data loading based on visible range
  const loadDataForRange = useCallback(async (visibleStart: Date, visibleEnd: Date) => {
    if (!enableIncrementalLoading) return;

    const buffer = 30 * 60 * 1000; // 30 minutes buffer
    const expandedStart = new Date(visibleStart.getTime() - buffer);
    const expandedEnd = new Date(visibleEnd.getTime() + buffer);

    const gaps = [];

    // Check if we need data before current range
    if (!dataRange.start || expandedStart < dataRange.start) {
      gaps.push({
        start: expandedStart,
        end: dataRange.start || visibleStart
      });
    }

    // Check if we need data after current range
    if (!dataRange.end || expandedEnd > dataRange.end) {
      gaps.push({
        start: dataRange.end || visibleEnd,
        end: expandedEnd
      });
    }

    // Fetch missing data
    for (const gap of gaps) {
      await fetchIncrementalData(gap.start, gap.end);
    }
  }, [enableIncrementalLoading, dataRange, fetchIncrementalData]);

  // Clear cache on company change
  useEffect(() => {
    clearData();
  }, [companyCode, clearData]);

  return { 
    data, 
    loading, 
    error, 
    dataRange,
    fetchData, 
    fetchAllData, 
    fetchIncrementalData,
    loadDataForRange,
    clearData 
  };
}


================================================================================
FILE: apps/frontend/hooks/useMarketData.ts
PURPOSE: New data format support
================================================================================

import { useState, useEffect, useCallback } from 'react';
import { getSocket } from '../lib/socket';

interface MarketData {
  ltp: number;
  change: number;
  changePercent: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
  timestamp: number;
}

interface UseMarketDataReturn {
  data: Record<string, MarketData>;
  isLoading: boolean;
  error: Error | null;
  subscribeToSymbol: (symbol: string) => void;
  unsubscribeFromSymbol: (symbol: string) => void;
}

export const useMarketData = (initialSymbols: string[] = []): UseMarketDataReturn => {
  const [data, setData] = useState<Record<string, MarketData>>({});
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<Error | null>(null);
  const [subscribedSymbols, setSubscribedSymbols] = useState<Set<string>>(
    new Set(initialSymbols)
  );

  const subscribeToSymbol = useCallback((symbol: string) => {
    setSubscribedSymbols((prev) => {
      const newSet = new Set(prev);
      newSet.add(symbol);
      return newSet;
    });
    
    getSocket().emit('subscribe', { symbol });
  }, []);

  const unsubscribeFromSymbol = useCallback((symbol: string) => {
    setSubscribedSymbols((prev) => {
      const newSet = new Set(prev);
      newSet.delete(symbol);
      return newSet;
    });
    
    getSocket().emit('unsubscribe', { symbol });
    
    setData((prev) => {
      const newData = { ...prev };
      delete newData[symbol];
      return newData;
    });
  }, []);

  useEffect(() => {
    const socket = getSocket();
    
    const handleMarketData = (message: { symbol: string; data: MarketData }) => {
      setData((prev) => ({
        ...prev,
        [message.symbol]: message.data,
      }));
      
      setIsLoading(false);
    };
    
    socket.on('marketData', handleMarketData);
    
    initialSymbols.forEach((symbol) => {
      socket.emit('subscribe', { symbol });
    });
    
    return () => {
      socket.off('marketData', handleMarketData);
      
      subscribedSymbols.forEach((symbol) => {
        socket.emit('unsubscribe', { symbol });
      });
    };
  }, [initialSymbols]);

  return {
    data,
    isLoading,
    error,
    subscribeToSymbol,
    unsubscribeFromSymbol,
  };
};


################################################################################
SECTION 6: FRONTEND DISPLAY COMPONENTS
################################################################################

================================================================================
FILE: apps/frontend/app/market-data/components/MarketDataTable.tsx
PURPOSE: Table with marker and company information
================================================================================

import React from 'react';

interface MarketData {
  ltp: number;
  change: number;
  changePercent: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
  timestamp: number;
}

interface MarketDataTableProps {
  data: Record<string, MarketData>;
  onSymbolSelect: (symbol: string) => void;
  onRemoveSymbol: (symbol: string) => void;
  selectedSymbol: string;
}

const MarketDataTable: React.FC<MarketDataTableProps> = ({
  data,
  onSymbolSelect,
  onRemoveSymbol,
  selectedSymbol,
}) => {
  return (
    <div className="overflow-x-auto">
      <table className="w-full">
        <thead>
          <tr className="border-b">
            <th className="text-left py-2">Symbol</th>
            <th className="text-right py-2">LTP</th>
            <th className="text-right py-2">Change</th>
            <th className="text-right py-2">%Change</th>
            <th className="text-right py-2">Volume</th>
            <th className="text-center py-2">Actions</th>
          </tr>
        </thead>
        <tbody>
          {Object.entries(data).map(([symbol, marketData]) => (
            <tr 
              key={symbol}
              className={`border-b hover:bg-muted/50 cursor-pointer ${
                selectedSymbol === symbol ? 'bg-muted' : ''
              }`}
              onClick={() => onSymbolSelect(symbol)}
            >
              <td className="py-3 font-medium">{symbol}</td>
              <td className="text-right py-3">{marketData.ltp.toFixed(2)}</td>
              <td 
                className={`text-right py-3 ${
                  marketData.change >= 0 ? 'text-green-500' : 'text-red-500'
                }`}
              >
                {marketData.change >= 0 ? '+' : ''}
                {marketData.change.toFixed(2)}
              </td>
              <td 
                className={`text-right py-3 ${
                  marketData.changePercent >= 0 ? 'text-green-500' : 'text-red-500'
                }`}
              >
                {marketData.changePercent >= 0 ? '+' : ''}
                {marketData.changePercent.toFixed(2)}%
              </td>
              <td className="text-right py-3">{marketData.volume.toLocaleString()}</td>
              <td className="text-center py-3">
                <button
                  className="text-red-500 hover:text-red-700"
                  onClick={(e) => {
                    e.stopPropagation();
                    onRemoveSymbol(symbol);
                  }}
                >
                  Remove
                </button>
              </td>
            </tr>
          ))}
          
          {Object.keys(data).length === 0 && (
            <tr>
              <td colSpan={6} className="py-4 text-center text-muted-foreground">
                No symbols in watchlist. Add symbols to get started.
              </td>
            </tr>
          )}
        </tbody>
      </table>
    </div>
  );
};

export default MarketDataTable;


================================================================================
FILE: apps/frontend/app/components/charts/StockChart.tsx
PURPOSE: Chart with new data structure support
================================================================================

'use client'
import React, { useMemo, useState, useEffect, useRef, useCallback } from 'react';
import dynamic from 'next/dynamic';
import { 
  LineChart, 
  CandlestickChart, 
  BarChart3, 
  TrendingUp, 
  Settings, 
  Palette,
  Grid3X3,
  MousePointer,
  Eraser,
  Circle,
  Square,
  Minus,
  ZoomIn,
  ZoomOut,
  RotateCcw,
  Sun,
  Moon,
  Eye,
  EyeOff,
  Clock,
  Maximize2,
  Minimize2,
  Monitor,
  Smartphone
} from 'lucide-react';

const Plot = dynamic(() => import('react-plotly.js'), { ssr: false });

const CHART_PERFORMANCE_CONFIG = {
  MAX_VISIBLE_POINTS: 2000,
  CHUNK_SIZE: 1000,
  WEBGL_THRESHOLD: 5000,
  MARKET_OPEN_MINUTES: 9 * 60 + 15,
  MARKET_CLOSE_MINUTES: 15 * 60 + 30,
  IST_OFFSET: 5.5 * 60 * 60 * 1000,
  ZOOM_WINDOW_MINUTES: 15,
  PRICE_PADDING_PERCENT: 0.08,
  SIDEBAR_WIDTH: 280,
  MIN_CHART_WIDTH: 400,
  MIN_CHART_HEIGHT: 300,
  RESIZE_DEBOUNCE_MS: 150,
  AUTO_RESIZE_ENABLED: true,
  RESPONSIVE_BREAKPOINTS: {
    MOBILE: 768,
    TABLET: 1024,
    DESKTOP: 1440
  },
  ASPECT_RATIOS: {
    WIDESCREEN: 16/9,
    STANDARD: 4/3,
    SQUARE: 1/1
  },
  RELAYOUT_DEBOUNCE: 500,
  UPDATE_DEBOUNCE: 500,
  STABLE_UI_REVISION: 'stable-v1',
  PRICE_CHART_HEIGHT_RATIO: 0.60, 
  VOLUME_CHART_HEIGHT_RATIO: 0.40, 
  INDICATOR_CHART_HEIGHT: 120, 
  CHART_GAP: 2 
};

const MARKET_HOLIDAYS_2025 = [
  '2025-01-26',
  '2025-03-14',
  '2025-08-15',
  '2025-10-02',
  '2025-11-01',
  '2025-12-25'
];

const STABLE_RANGEBREAKS = [
  { 
    bounds: ['sat', 'mon'], 
    pattern: 'day of week' 
  },
  { 
    bounds: [15.5, 9.25], 
    pattern: 'hour' 
  },
  {
    values: MARKET_HOLIDAYS_2025
  }
];

const availableIndicators = [
  { id: 'ma', name: 'Moving Average', periods: [5, 9, 20, 50, 100, 200], color: '#ffffff' },
  { id: 'ema', name: 'Exponential MA', periods: [5, 9, 20, 50, 100, 200], color: '#ffffff' },
  { id: 'bollinger', name: 'Bollinger Bands', period: 20, stdDev: 2, color: '#ffffff' },
  { id: 'rsi', name: 'RSI', period: 14, color: '#ffffff' },
  { id: 'macd', name: 'MACD', fastPeriod: 12, slowPeriod: 26, signalPeriod: 9, color: '#ffffff' },
];

const chartTypes = [
  { id: 'candlestick', name: 'Candlestick', icon: CandlestickChart },
  { id: 'ohlc', name: 'OHLC', icon: BarChart3 },
  { id: 'line', name: 'Line', icon: LineChart },
  { id: 'area', name: 'Area', icon: TrendingUp },
  { id: 'heiken-ashi', name: 'Heiken Ashi', icon: CandlestickChart }
];

const timeIntervals = [
  { id: '1m', name: '1m' },
  { id: '5m', name: '5m' },
  { id: '10m', name: '10m' },
  { id: '15m', name: '15m' },
  { id: '30m', name: '30m' },
  { id: '1h', name: '1h' },
  { id: '1d', name: '1D' }
];

const drawingTools = [
  { id: 'drawline', name: 'Trend Line', icon: Minus },
  { id: 'drawrect', name: 'Rectangle', icon: Square },
  { id: 'drawcircle', name: 'Circle', icon: Circle },
  { id: 'drawopenpath', name: 'Free Draw', icon: MousePointer },
  { id: 'eraseshape', name: 'Eraser', icon: Eraser }
];

interface StockDataPoint {
  interval_start: string;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
}

interface StockChartProps {
  companyId: string | null;
  data?: StockDataPoint[];
  startDate?: Date;
  endDate?: Date;
  interval?: string;
  indicators?: string[];
  loading?: boolean;
  error?: string | null;
  height?: number;
  width?: number;
  defaultChartType?: string;
  showControls?: boolean;
  theme?: 'light' | 'dark';
  onThemeChange?: (theme: 'light' | 'dark') => void;
  onIntervalChange?: (interval: string) => void;
  onRangeChange?: (startDate: Date, endDate: Date) => Promise<void>;
}

const LoadingIndicator = ({ show }: { show: boolean }) => {
  if (!show) return null;
  
  return (
    <div 
      className="fixed top-4 right-4 z-50 bg-gradient-to-r from-blue-500 to-blue-600 text-white px-6 py-3 rounded-lg shadow-2xl"
      style={{
        animation: 'slideInScale 0.3s ease-out forwards',
        transformOrigin: 'top right'
      }}
    >
      <div className="flex items-center space-x-3">
        <div 
          className="w-5 h-5 border-2 border-white border-t-transparent rounded-full"
          style={{
            animation: 'spin 1s linear infinite'
          }}
        ></div>
        <div className="flex flex-col">
          <span className="text-sm font-semibold">Loading Chart Data</span>
          <span className="text-xs opacity-90">Expanding timeline...</span>
        </div>
      </div>
      
      <div className="mt-2 w-full bg-blue-300 bg-opacity-30 rounded-full h-1">
        <div 
          className="bg-white h-1 rounded-full"
          style={{
            animation: 'progress 2s ease-in-out infinite'
          }}
        ></div>
      </div>
    </div>
  );
};

const isMarketHours = (date: Date): boolean => {
  const day = date.getDay();
  const hours = date.getHours();
  const minutes = date.getMinutes();
  const timeInMinutes = hours * 60 + minutes;
  
  if (day === 0 || day === 6) return false;
  
  return timeInMinutes >= CHART_PERFORMANCE_CONFIG.MARKET_OPEN_MINUTES && 
         timeInMinutes <= CHART_PERFORMANCE_CONFIG.MARKET_CLOSE_MINUTES;
};

const filterMarketHoursData = (data: StockDataPoint[]): StockDataPoint[] => {
  if (!data || !data.length) return [];
  
  return data.filter(item => {
    const date = new Date(item.interval_start);
    return isMarketHours(date);
  });
};

const generateMarketTimeline = (startDate: Date, endDate: Date, intervalMinutes: number): Date[] => {
  const timeline: Date[] = [];
  const current = new Date(startDate);
  
  while (current <= endDate) {
    if (isMarketHours(current)) {
      timeline.push(new Date(current));
    }
    current.setMinutes(current.getMinutes() + intervalMinutes);
  }
  
  return timeline;
};

export function StockChart({
  companyId,
  data = [],
  startDate,
  endDate,
  interval = '1m',
  indicators = [],
  loading = false,
  error = null,
  height = 1000,
  width = 1200,
  defaultChartType = 'candlestick',
  showControls = true,
  theme = 'dark',
  onThemeChange,
  onIntervalChange,
  onRangeChange
}: StockChartProps) {
  
  const [selectedInterval, setSelectedInterval] = useState(interval);
  const [selectedChartType, setSelectedChartType] = useState(defaultChartType);
  const [activeIndicators, setActiveIndicators] = useState<string[]>(indicators);
  const [selectedMAperiods, setSelectedMAperiods] = useState<number[]>([20, 50]);
  const [selectedEMAperiods, setSelectedEMAperiods] = useState<number[]>([9, 21]);
  const [showVolume, setShowVolume] = useState(true);
  const [showGridlines, setShowGridlines] = useState(true);
  const [logScale, setLogScale] = useState(false);
  const [crosshair, setCrosshair] = useState(true);
  const [sidebarVisible, setSidebarVisible] = useState(showControls);
  const [chartTheme, setChartTheme] = useState<'light' | 'dark'>(theme);
  
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [autoResize, setAutoResize] = useState(CHART_PERFORMANCE_CONFIG.AUTO_RESIZE_ENABLED);
  const [responsiveMode, setResponsiveMode] = useState<'auto' | 'manual'>('auto');
  const [aspectRatio, setAspectRatio] = useState<keyof typeof CHART_PERFORMANCE_CONFIG.ASPECT_RATIOS>('WIDESCREEN');
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 });
  const [chartDimensions, setChartDimensions] = useState({ width: 0, height: 0 });
  const [viewportSize, setViewportSize] = useState({ width: 0, height: 0 });
  const [deviceType, setDeviceType] = useState<'mobile' | 'tablet' | 'desktop'>('desktop');
  
  const [drawingMode, setDrawingMode] = useState<string | null>(null);
  const [annotations, setAnnotations] = useState<any[]>([]);
  const [autoRefresh, setAutoRefresh] = useState(false);
  const [refreshInterval, setRefreshInterval] = useState(5000);
  const [alertsEnabled, setAlertsEnabled] = useState(false);
  const [priceAlerts, setPriceAlerts] = useState<any[]>([]);
  
  const [priceChartHeight, setPriceChartHeight] = useState(0);
  const [volumeChartHeight, setVolumeChartHeight] = useState(0);
  const [rsiChartHeight, setRsiChartHeight] = useState(0);
  const [macdChartHeight, setMacdChartHeight] = useState(0);
  const [syncedXRange, setSyncedXRange] = useState<[string, string] | null>(null);
  
  const priceChartRef = useRef<any>(null);
  const volumeChartRef = useRef<any>(null);
  const rsiChartRef = useRef<any>(null);
  const macdChartRef = useRef<any>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const chartContainerRef = useRef<HTMLDivElement>(null);
  const resizeObserverRef = useRef<ResizeObserver | null>(null);
  const resizeTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  
  const [isLoadingMoreData, setIsLoadingMoreData] = useState(false);
  const [loadingStartTime, setLoadingStartTime] = useState<number | null>(null);
  const [showLoadingIndicator, setShowLoadingIndicator] = useState(false);
  const [dataRange, setDataRange] = useState<{ start: Date | null; end: Date | null }>({ start: null, end: null });
  const [allData, setAllData] = useState<StockDataPoint[]>([]);
  const loadingTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const lastFetchRangeRef = useRef<{ start: Date; end: Date } | null>(null);
  const [xRange, setXRange] = useState<[string, string] | null>(null);
  const [yRange, setYRange] = useState<[number, number] | null>(null);
  
  const loadingControllerRef = useRef<AbortController | null>(null);
  const minimumLoadingTimeRef = useRef<NodeJS.Timeout | null>(null);
  const stableTimelineRef = useRef<Date[]>([]);
  const relayoutTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const [isUserInteracting, setIsUserInteracting] = useState(false);
  const interactionTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    const loadingStyles = `
      @keyframes slideInScale {
        0% {
          opacity: 0;
          transform: translateX(100%) scale(0.8);
        }
        100% {
          opacity: 1;
          transform: translateX(0) scale(1);
        }
      }
      
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      
      @keyframes progress {
        0% { width: 0%; }
        50% { width: 70%; }
        100% { width: 100%; }
      }
    `;
    
    const styleSheet = document.createElement('style');
    styleSheet.textContent = loadingStyles;
    document.head.appendChild(styleSheet);
    
    return () => {
      if (document.head.contains(styleSheet)) {
        document.head.removeChild(styleSheet);
      }
    };
  }, []);

  const getIntervalInMs = useCallback((intervalStr: string): number => {
    const intervalMap: { [key: string]: number } = {
      '1m': 60 * 1000,
      '5m': 5 * 60 * 1000,
      '10m': 10 * 60 * 1000,
      '15m': 15 * 60 * 1000,
      '30m': 30 * 60 * 1000,
      '1h': 60 * 60 * 1000,
      '1d': 24 * 60 * 60 * 1000
    };
    return intervalMap[intervalStr] || 60 * 1000;
  }, []);

  const detectDataGaps = useCallback((visibleRange: [string, string]) => {
    if (!allData || allData.length === 0) {
      return null;
    }
    
    try {
      const [visibleStartStr, visibleEndStr] = visibleRange;
      const visibleStart = new Date(visibleStartStr);
      const visibleEnd = new Date(visibleEndStr);
      
      if (isNaN(visibleStart.getTime()) || isNaN(visibleEnd.getTime())) {
        return null;
      }
      
      const dataStart = new Date(allData[0].interval_start);
      const dataEnd = new Date(allData[allData.length - 1].interval_start);
      
      const gaps = [];
      const bufferTime = 30 * 60 * 1000;
      
      if (visibleStart < dataStart) {
        const gapStart = new Date(visibleStart.getTime() - bufferTime);
        gaps.push({
          type: 'before',
          start: gapStart,
          end: dataStart,
          priority: 'high'
        });
      }
      
      if (visibleEnd > dataEnd) {
        const gapEnd = new Date(visibleEnd.getTime() + bufferTime);
        gaps.push({
          type: 'after',
          start: dataEnd,
          end: gapEnd,
          priority: 'high'
        });
      }
      
      if (allData.length > 1) {
        const intervalMs = getIntervalInMs(selectedInterval);
        const maxGap = intervalMs * 3;
        
        for (let i = 1; i < allData.length; i++) {
          const currentTime = new Date(allData[i].interval_start).getTime();
          const previousTime = new Date(allData[i - 1].interval_start).getTime();
          const actualGap = currentTime - previousTime;
          
          if (actualGap > maxGap) {
            gaps.push({
              type: 'internal',
              start: new Date(previousTime + intervalMs),
              end: new Date(currentTime - intervalMs),
              priority: 'medium'
            });
          }
        }
      }
      
      return gaps.length > 0 ? gaps : null;
      
    } catch (error) {
      console.error('Error in detectDataGaps:', error);
      return null;
    }
  }, [allData, selectedInterval, getIntervalInMs]);

  const fetchMissingData = useCallback(async (gaps: Array<{type: string, start: Date, end: Date, priority?: string}>) => {
    if (!companyId || isLoadingMoreData) {
      console.log('Skipping fetch: no companyId or already loading');
      return;
    }
    
    const startTime = Date.now();
    setLoadingStartTime(startTime);
    setIsLoadingMoreData(true);
    
    const loadingDelay = setTimeout(() => {
      setShowLoadingIndicator(true);
    }, 300);
    
    if (loadingControllerRef.current) {
      loadingControllerRef.current.abort();
    }
    loadingControllerRef.current = new AbortController();
    
    try {
      console.log('Fetching data for gaps:', gaps);
      
      const fetchPromises = gaps.map(async (gap) => {
        if (lastFetchRangeRef.current) {
          const overlap = gap.start >= lastFetchRangeRef.current.start && 
                         gap.end <= lastFetchRangeRef.current.end;
          if (overlap) {
            console.log('Skipping duplicate fetch for gap:', gap);
            return [];
          }
        }
        
        try {
          const params = new URLSearchParams({
            exchange: 'NSE',
            startDate: gap.start.toISOString(),
            endDate: gap.end.toISOString(),
            interval: selectedInterval,
            indicators: activeIndicators.join(','),
            fetchType: 'incremental',
            gapType: gap.type || 'unknown'
          });
          
          const apiUrl = `/api/companies/${companyId}/ohlcv?${params}`;
          console.log('Fetching from:', apiUrl);
          
          const response = await fetch(apiUrl, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json',
              'Cache-Control': 'no-cache',
              'Accept': 'application/json'
            },
            signal: loadingControllerRef.current?.signal
          });
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error(`API Error ${response.status}:`, errorText);
            
            if (response.status === 404) {
              console.warn('API endpoint not found - check your backend');
              return [];
            } else if (response.status === 429) {
              console.warn('Rate limited - backing off');
              await new Promise(resolve => setTimeout(resolve, 1000));
              return [];
            }
            
            throw new Error(`API Error ${response.status}: ${errorText}`);
          }
          
          const responseData = await response.json();
          console.log('API Response:', responseData);
          
          let newData = [];
          if (Array.isArray(responseData)) {
            newData = responseData;
          } else if (responseData.data && Array.isArray(responseData.data)) {
            newData = responseData.data;
          } else if (responseData.results && Array.isArray(responseData.results)) {
            newData = responseData.results;
          } else if (responseData.ohlcv && Array.isArray(responseData.ohlcv)) {
            newData = responseData.ohlcv;
          } else {
            console.warn('Unexpected API response format:', responseData);
            return [];
          }
          
          if (newData.length === 0) {
            console.warn('No data returned from API for gap:', gap);
            return [];
          }
          
          lastFetchRangeRef.current = { start: gap.start, end: gap.end };
          
          const normalizedData = newData
            .map((item: any) => {
              try {
                return {
                  interval_start: typeof item.interval_start === 'string' 
                    ? item.interval_start 
                    : new Date(item.interval_start || item.timestamp || item.time).toISOString(),
                  open: Number(item.open || item.o) || 0,
                  high: Number(item.high || item.h) || 0,
                  low: Number(item.low || item.l) || 0,
                  close: Number(item.close || item.c) || 0,
                  volume: Number(item.volume || item.v) || 0
                };
              } catch (error) {
                console.error('Error normalizing data item:', item, error);
                return null;
              }
            })
            .filter((item): item is StockDataPoint => item !== null);
          
          console.log(`Normalized ${normalizedData.length} data points for gap:`, gap);
          
          return filterMarketHoursData(normalizedData);
          
        } catch (error) {
          if (error.name === 'AbortError') {
            console.log('Fetch aborted');
            return [];
          }
          console.error(`Error fetching gap data for ${gap.type}:`, error);
          
          return [];
        }
      });
      
      const results = await Promise.all(fetchPromises);
      const newDataPoints = results.flat();
      
      console.log(`Total new data points fetched: ${newDataPoints.length}`);
      
      if (newDataPoints.length > 0) {
        setAllData(prevData => {
          const combined = [...prevData, ...newDataPoints];
          
          const uniqueMap = new Map();
          combined.forEach(item => {
            const key = item.interval_start;
            const date = new Date(item.interval_start);
            
            if (!uniqueMap.has(key) || 
                (item.volume > 0 && uniqueMap.get(key).volume === 0)) {
              uniqueMap.set(key, item);
            }
          });
          
          const sortedData = Array.from(uniqueMap.values()).sort((a, b) => 
            new Date(a.interval_start).getTime() - new Date(b.interval_start).getTime()
          );
          
          console.log(`Final data array length: ${sortedData.length}`);
          return sortedData;
        });
        
        setDataRange(prev => {
          const allDates = newDataPoints.map(d => new Date(d.interval_start));
          const newStart = new Date(Math.min(...allDates.map(d => d.getTime())));
          const newEnd = new Date(Math.max(...allDates.map(d => d.getTime())));
          
          return {
            start: prev.start ? (newStart < prev.start ? newStart : prev.start) : newStart,
            end: prev.end ? (newEnd > prev.end ? newEnd : prev.end) : newEnd
          };
        });
      } else {
        console.warn('No new data points were fetched');
      }
      
    } catch (error) {
      if (error.name === 'AbortError') {
        console.log('Fetch operation aborted');
        return;
      }
      console.error('Error in fetchMissingData:', error);
      
      if (error.message.includes('fetch')) {
        console.error('Network error - check your API endpoint');
      }
    } finally {
      const elapsedTime = Date.now() - startTime;
      const minLoadingTime = 500;
      
      clearTimeout(loadingDelay);
      
      const finishLoading = () => {
        setIsLoadingMoreData(false);
        setShowLoadingIndicator(false);
        setLoadingStartTime(null);
      };
      
      if (elapsedTime < minLoadingTime) {
        minimumLoadingTimeRef.current = setTimeout(finishLoading, minLoadingTime - elapsedTime);
      } else {
        finishLoading();
      }
    }
  }, [companyId, selectedInterval, activeIndicators, isLoadingMoreData, getIntervalInMs]);

  const syncChartRanges = useCallback((newXRange: [string, string], sourceChart: string) => {
    setSyncedXRange(newXRange);
    setXRange(newXRange);
    
    const charts = [
      { ref: priceChartRef, name: 'price' },
      { ref: volumeChartRef, name: 'volume' },
      { ref: rsiChartRef, name: 'rsi' },
      { ref: macdChartRef, name: 'macd' }
    ];
    
    charts.forEach(chart => {
      if (sourceChart !== chart.name && chart.ref.current) {
        try {
          chart.ref.current.relayout({ 'xaxis.range': newXRange });
        } catch (error) {
          console.warn(`Failed to sync ${chart.name} chart range:`, error);
        }
      }
    });
  }, []);

  const handlePriceChartRelayout = useCallback((eventData: any) => {
    if (isLoadingMoreData) {
      console.log('Skipping price chart relayout handling - already loading');
      return;
    }

    setIsUserInteracting(true);
    
    if (interactionTimeoutRef.current) {
      clearTimeout(interactionTimeoutRef.current);
    }
    
    let newXRange = null;
    let newYRange = null;
    
    if (eventData['xaxis.range[0]'] && eventData['xaxis.range[1]']) {
      newXRange = [eventData['xaxis.range[0]'], eventData['xaxis.range[1]']];
    } else if (eventData['xaxis.range']) {
      newXRange = eventData['xaxis.range'];
    }
    
    if (eventData['yaxis.range[0]'] && eventData['yaxis.range[1]']) {
      newYRange = [eventData['yaxis.range[0]'], eventData['yaxis.range[1]']];
    }
    
    console.log('Price chart relayout event:', { newXRange, newYRange });
    
    if (newXRange) {
      syncChartRanges(newXRange, 'price');
    }
    if (newYRange) {
      setYRange(newYRange);
    }
    
    if (eventData['xaxis.autorange'] === true) {
      setSyncedXRange(null);
      setXRange(null);
    }
    if (eventData['yaxis.autorange'] === true) {
      setYRange(null);
    }
    
    if (relayoutTimeoutRef.current) {
      clearTimeout(relayoutTimeoutRef.current);
    }
    
    relayoutTimeoutRef.current = setTimeout(() => {
      if (!isLoadingMoreData && newXRange) {
        try {
          console.log('Checking for gaps in price chart range:', newXRange);
          const gaps = detectDataGaps(newXRange);
          if (gaps && gaps.length > 0) {
            console.log('Found gaps, fetching data:', gaps);
            fetchMissingData(gaps);
          } else {
            console.log('No gaps detected');
          }
        } catch (error) {
          console.error('Error in price chart gap detection:', error);
        }
      }
    }, CHART_PERFORMANCE_CONFIG.RELAYOUT_DEBOUNCE);
    
    interactionTimeoutRef.current = setTimeout(() => {
      setIsUserInteracting(false);
    }, CHART_PERFORMANCE_CONFIG.RELAYOUT_DEBOUNCE + 200);
    
  }, [detectDataGaps, fetchMissingData, isLoadingMoreData, syncChartRanges]);

  const handleVolumeChartRelayout = useCallback((eventData: any) => {
    if (isLoadingMoreData) {
      console.log('Skipping volume chart relayout handling - already loading');
      return;
    }

    setIsUserInteracting(true);
    
    if (interactionTimeoutRef.current) {
      clearTimeout(interactionTimeoutRef.current);
    }
    
    let newXRange = null;
    
    if (eventData['xaxis.range[0]'] && eventData['xaxis.range[1]']) {
      newXRange = [eventData['xaxis.range[0]'], eventData['xaxis.range[1]']];
    } else if (eventData['xaxis.range']) {
      newXRange = eventData['xaxis.range'];
    }
    
    console.log('Volume chart relayout event:', { newXRange });
    
    if (newXRange) {
      syncChartRanges(newXRange, 'volume');
    }
    
    if (eventData['xaxis.autorange'] === true) {
      setSyncedXRange(null);
      setXRange(null);
    }
    
    interactionTimeoutRef.current = setTimeout(() => {
      setIsUserInteracting(false);
    }, CHART_PERFORMANCE_CONFIG.RELAYOUT_DEBOUNCE + 200);
    
  }, [isLoadingMoreData, syncChartRanges]);

  const handleRsiChartRelayout = useCallback((eventData: any) => {
    if (isLoadingMoreData) return;

    setIsUserInteracting(true);
    
    if (interactionTimeoutRef.current) {
      clearTimeout(interactionTimeoutRef.current);
    }
    
    let newXRange = null;
    
    if (eventData['xaxis.range[0]'] && eventData['xaxis.range[1]']) {
      newXRange = [eventData['xaxis.range[0]'], eventData['xaxis.range[1]']];
    } else if (eventData['xaxis.range']) {
      newXRange = eventData['xaxis.range'];
    }
    
    if (newXRange) {
      syncChartRanges(newXRange, 'rsi');
    }
    
    if (eventData['xaxis.autorange'] === true) {
      setSyncedXRange(null);
      setXRange(null);
    }
    
    interactionTimeoutRef.current = setTimeout(() => {
      setIsUserInteracting(false);
    }, CHART_PERFORMANCE_CONFIG.RELAYOUT_DEBOUNCE + 200);
    
  }, [isLoadingMoreData, syncChartRanges]);

  const handleMacdChartRelayout = useCallback((eventData: any) => {
    if (isLoadingMoreData) return;

    setIsUserInteracting(true);
    
    if (interactionTimeoutRef.current) {
      clearTimeout(interactionTimeoutRef.current);
    }
    
    let newXRange = null;
    
    if (eventData['xaxis.range[0]'] && eventData['xaxis.range[1]']) {
      newXRange = [eventData['xaxis.range[0]'], eventData['xaxis.range[1]']];
    } else if (eventData['xaxis.range']) {
      newXRange = eventData['xaxis.range'];
    }
    
    if (newXRange) {
      syncChartRanges(newXRange, 'macd');
    }
    
    if (eventData['xaxis.autorange'] === true) {
      setSyncedXRange(null);
      setXRange(null);
    }
    
    interactionTimeoutRef.current = setTimeout(() => {
      setIsUserInteracting(false);
    }, CHART_PERFORMANCE_CONFIG.RELAYOUT_DEBOUNCE + 200);
    
  }, [isLoadingMoreData, syncChartRanges]);

  useEffect(() => {
    if (data && data.length > 0) {
      const marketHoursData = filterMarketHoursData(data);
      setAllData(marketHoursData);
      
      if (marketHoursData.length > 0) {
        const start = new Date(marketHoursData[0].interval_start);
        const end = new Date(marketHoursData[marketHoursData.length - 1].interval_start);
        setDataRange({ start, end });
      }
      
      setXRange(null);
      setYRange(null);
      setSyncedXRange(null);
    }
  }, [data]);

  useEffect(() => {
    if (companyId) {
      setXRange(null);
      setYRange(null);
      setSyncedXRange(null);
      setAllData([]);
      setDataRange({ start: null, end: null });
      lastFetchRangeRef.current = null;
      setIsUserInteracting(false);
    }
  }, [companyId]);

  useEffect(() => {
    const totalAvailableHeight = isFullscreen ? window.innerHeight - 20 : height - 20;
    const gap = CHART_PERFORMANCE_CONFIG.CHART_GAP;
    
    const hasRSI = activeIndicators.includes('rsi');
    const hasMACD = activeIndicators.includes('macd');
    
    let indicatorHeight = 0;
    if (hasRSI) indicatorHeight += CHART_PERFORMANCE_CONFIG.INDICATOR_CHART_HEIGHT + gap;
    if (hasMACD) indicatorHeight += CHART_PERFORMANCE_CONFIG.INDICATOR_CHART_HEIGHT + gap;
    
    const availableForMainCharts = totalAvailableHeight - indicatorHeight;
    
    if (showVolume) {
      const priceHeight = Math.floor(availableForMainCharts * CHART_PERFORMANCE_CONFIG.PRICE_CHART_HEIGHT_RATIO);
      const volumeHeight = Math.floor(availableForMainCharts * CHART_PERFORMANCE_CONFIG.VOLUME_CHART_HEIGHT_RATIO);
      
      setPriceChartHeight(priceHeight);
      setVolumeChartHeight(volumeHeight);
    } else {
      setPriceChartHeight(availableForMainCharts);
      setVolumeChartHeight(0);
    }
    
    setRsiChartHeight(hasRSI ? CHART_PERFORMANCE_CONFIG.INDICATOR_CHART_HEIGHT : 0);
    setMacdChartHeight(hasMACD ? CHART_PERFORMANCE_CONFIG.INDICATOR_CHART_HEIGHT : 0);
    
  }, [height, isFullscreen, showVolume, activeIndicators]);

  useEffect(() => {
    return () => {
      [loadingTimeoutRef, minimumLoadingTimeRef, relayoutTimeoutRef, interactionTimeoutRef].forEach(ref => {
        if (ref.current) clearTimeout(ref.current);
      });
      if (loadingControllerRef.current) {
        loadingControllerRef.current.abort();
      }
    };
  }, []);

  const detectDeviceType = useCallback((width: number) => {
    if (width < CHART_PERFORMANCE_CONFIG.RESPONSIVE_BREAKPOINTS.MOBILE) {
      return 'mobile';
    } else if (width < CHART_PERFORMANCE_CONFIG.RESPONSIVE_BREAKPOINTS.TABLET) {
      return 'tablet';
    } else {
      return 'desktop';
    }
  }, []);

  useEffect(() => {
    const updateViewportSize = () => {
      const newSize = {
        width: window.innerWidth,
        height: window.innerHeight
      };
      setViewportSize(newSize);
      setDeviceType(detectDeviceType(newSize.width));
    };

    updateViewportSize();
    
    const handleResize = () => {
      if (resizeTimeoutRef.current) {
        clearTimeout(resizeTimeoutRef.current);
      }
      resizeTimeoutRef.current = setTimeout(updateViewportSize, CHART_PERFORMANCE_CONFIG.RESIZE_DEBOUNCE_MS);
    };

    window.addEventListener('resize', handleResize);
    return () => {
      window.removeEventListener('resize', handleResize);
      if (resizeTimeoutRef.current) {
        clearTimeout(resizeTimeoutRef.current);
      }
    };
  }, [detectDeviceType]);

  useEffect(() => {
    if (!containerRef.current || !autoResize) return;

    const updateContainerDimensions = (entries: ResizeObserverEntry[]) => {
      if (!entries.length) return;
      
      const entry = entries[0];
      const { width: containerWidth, height: containerHeight } = entry.contentRect;
      
      if (containerWidth === 0 || containerHeight === 0) return;

      const sidebarWidth = sidebarVisible ? CHART_PERFORMANCE_CONFIG.SIDEBAR_WIDTH : 0;
      const availableWidth = containerWidth - sidebarWidth;
      const availableHeight = isFullscreen ? window.innerHeight : containerHeight;

      const newContainerDims = {
        width: containerWidth,
        height: containerHeight
      };

      const newChartDims = {
        width: Math.max(availableWidth, CHART_PERFORMANCE_CONFIG.MIN_CHART_WIDTH),
        height: Math.max(availableHeight, CHART_PERFORMANCE_CONFIG.MIN_CHART_HEIGHT)
      };

      if (responsiveMode === 'manual') {
        const targetRatio = CHART_PERFORMANCE_CONFIG.ASPECT_RATIOS[aspectRatio];
        const currentRatio = newChartDims.width / newChartDims.height;
        
        if (currentRatio > targetRatio) {
          newChartDims.width = newChartDims.height * targetRatio;
        } else {
          newChartDims.height = newChartDims.width / targetRatio;
        }
      }

      setContainerDimensions(newContainerDims);
      setChartDimensions(newChartDims);

      if (resizeTimeoutRef.current) {
        clearTimeout(resizeTimeoutRef.current);
      }
      resizeTimeoutRef.current = setTimeout(() => {
        try {
          if (priceChartRef.current?.resizeHandler) {
            priceChartRef.current.resizeHandler();
          }
          if (volumeChartRef.current?.resizeHandler) {
            volumeChartRef.current.resizeHandler();
          }
          if (rsiChartRef.current?.resizeHandler) {
            rsiChartRef.current.resizeHandler();
          }
          if (macdChartRef.current?.resizeHandler) {
            macdChartRef.current.resizeHandler();
          }
        } catch (error) {
          console.warn('Plotly resize failed:', error);
        }
      }, CHART_PERFORMANCE_CONFIG.RESIZE_DEBOUNCE_MS);
    };

    if (window.ResizeObserver) {
      resizeObserverRef.current = new ResizeObserver(updateContainerDimensions);
      resizeObserverRef.current.observe(containerRef.current);
    }

    return () => {
      if (resizeObserverRef.current && containerRef.current) {
        resizeObserverRef.current.unobserve(containerRef.current);
        resizeObserverRef.current.disconnect();
      }
      if (resizeTimeoutRef.current) {
        clearTimeout(resizeTimeoutRef.current);
      }
    };
  }, [autoResize, isFullscreen, sidebarVisible, responsiveMode, aspectRatio]);

  const filteredData = useMemo(() => {
    return filterMarketHoursData(allData);
  }, [allData]);

  const optimizedData = useMemo(() => {
    if (!filteredData.length) return filteredData;
    
    if (filteredData.length <= CHART_PERFORMANCE_CONFIG.MAX_VISIBLE_POINTS) {
      return filteredData;
    }
    
    const ratio = Math.ceil(filteredData.length / CHART_PERFORMANCE_CONFIG.MAX_VISIBLE_POINTS);
    const result: StockDataPoint[] = [];
    
    for (let i = 0; i < filteredData.length; i += ratio) {
      const chunk = filteredData.slice(i, i + ratio);
      if (chunk.length === 1) {
        result.push(chunk[0]);
      } else {
        const open = chunk[0].open;
        const close = chunk[chunk.length - 1].close;
        const high = Math.max(...chunk.map(d => d.high));
        const low = Math.min(...chunk.map(d => d.low));
        const volume = chunk.reduce((sum, d) => sum + d.volume, 0);
        
       result.push({
  interval_start: chunk[chunk.length - 1].interval_start,  //  Use LAST timestamp
  open, high, low, close, volume
});

      }
    }
    
    return result;
  }, [filteredData]);

  const calculateIndicator = useCallback((type: string, prices: number[], options = {}) => {
    switch (type) {
      case 'ma': {
        const period = (options as any).period || 20;
        const result = new Array(prices.length);
        
        for (let i = 0; i < prices.length; i++) {
          if (i < period - 1) {
            result[i] = null;
          } else {
            let sum = 0;
            for (let j = i - period + 1; j <= i; j++) {
              sum += prices[j];
            }
            result[i] = sum / period;
          }
        }
        return result;
      }
      
      case 'ema': {
        const period = (options as any).period || 9;
        const k = 2 / (period + 1);
        const result = new Array(prices.length);
        result[0] = prices[0];
        
        for (let i = 1; i < prices.length; i++) {
          result[i] = prices[i] * k + result[i-1] * (1-k);
        }
        
        for (let i = 0; i < period - 1; i++) {
          result[i] = null;
        }
        
        return result;
      }
      
      case 'bollinger': {
        const period = (options as any).period || 20;
        const stdDevMultiplier = (options as any).stdDev || 2;
        const ma = calculateIndicator('ma', prices, { period }) as number[];
        
        const upperBand = new Array(prices.length);
        const lowerBand = new Array(prices.length);
        
        for (let i = 0; i < prices.length; i++) {
          if (ma[i] === null) {
            upperBand[i] = null;
            lowerBand[i] = null;
          } else {
            let sumSquares = 0;
            for (let j = i - period + 1; j <= i; j++) {
              const diff = prices[j] - ma[i];
              sumSquares += diff * diff;
            }
            const stdDev = Math.sqrt(sumSquares / period);
            upperBand[i] = ma[i] + (stdDev * stdDevMultiplier);
            lowerBand[i] = ma[i] - (stdDev * stdDevMultiplier);
          }
        }
        
        return { middle: ma, upper: upperBand, lower: lowerBand };
      }
      
      case 'rsi': {
        const period = (options as any).period || 14;
        const gains = new Array(prices.length - 1);
        const losses = new Array(prices.length - 1);
        
        for (let i = 1; i < prices.length; i++) {
          const change = prices[i] - prices[i-1];
          gains[i-1] = change > 0 ? change : 0;
          losses[i-1] = change < 0 ? -change : 0;
        }
        
        const result = new Array(prices.length).fill(null);
        
        if (gains.length >= period) {
          let avgGain = gains.slice(0, period).reduce((sum, gain) => sum + gain, 0) / period;
          let avgLoss = losses.slice(0, period).reduce((sum, loss) => sum + loss, 0) / period;
          
          for (let i = period; i < gains.length; i++) {
            avgGain = ((avgGain * (period - 1)) + gains[i]) / period;
            avgLoss = ((avgLoss * (period - 1)) + losses[i]) / period;
            
            const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
            result[i + 1] = 100 - (100 / (1 + rs));
          }
        }
        
        return result;
      }
      
      case 'macd': {
        const fastPeriod = (options as any).fastPeriod || 12;
        const slowPeriod = (options as any).slowPeriod || 26;
        const signalPeriod = (options as any).signalPeriod || 9;
        
        const fastEMA = calculateIndicator('ema', prices, { period: fastPeriod }) as number[];
        const slowEMA = calculateIndicator('ema', prices, { period: slowPeriod }) as number[];
        
        const macdLine = fastEMA.map((fast, i) => {
          if (fast === null || slowEMA[i] === null) return null;
          return fast - slowEMA[i];
        });
        
        const validMacd = macdLine.filter(val => val !== null) as number[];
        const signalLine = calculateIndicator('ema', validMacd, { period: signalPeriod }) as number[];
        
        const paddedSignalLine = Array(macdLine.length - validMacd.length + signalPeriod - 1).fill(null).concat(signalLine);
        
        const histogram = macdLine.map((macd, i) => {
          if (macd === null || paddedSignalLine[i] === null) return null;
          return macd - paddedSignalLine[i];
        });
        
        return { macdLine, signalLine: paddedSignalLine, histogram };
      }
      
      default:
        return [];
    }
  }, []);

  const convertToHeikenAshi = useCallback((data: StockDataPoint[]) => {
    if (!data || data.length === 0) return [];
    
    const haData: any[] = [];
    let prevHA: any = null;
    
    for (let i = 0; i < data.length; i++) {
      const current = data[i];
      const currentHigh = current.high;
      const currentLow = current.low;
      const currentOpen = current.open;
      const currentClose = current.close;

      let haOpen: number;
      let haClose: number;
      let haHigh: number;
      let haLow: number;

      haClose = (currentOpen + currentHigh + currentLow + currentClose) / 4;

      if (prevHA === null) {
        haOpen = (currentOpen + currentClose) / 2;
      } else {
        haOpen = (prevHA.ha_open + prevHA.ha_close) / 2;
      }

      haHigh = Math.max(currentHigh, haOpen, haClose);
      haLow = Math.min(currentLow, haOpen, haClose);

      const haCandle = {
        interval_start: current.interval_start,
        ha_open: haOpen,
        ha_high: haHigh,
        ha_low: haLow,
        ha_close: haClose,
        volume: current.volume,
        original_open: currentOpen,
        original_high: currentHigh,
        original_low: currentLow,
        original_close: currentClose,
        color: haClose >= haOpen ? 'green' : 'red',
        bodySize: Math.abs(haClose - haOpen),
        upperWick: haHigh - Math.max(haOpen, haClose),
        lowerWick: Math.min(haOpen, haClose) - haLow
      };

      haData.push(haCandle);
      prevHA = haCandle;
    }
    
    return haData;
  }, []);

  const colors = useMemo(() => {
    const baseColor = '#27272a';
    const lighterShades = {
      100: '#3f3f46',
      200: '#52525b',
      300: '#71717a',
      400: '#a1a1aa',
      500: '#d4d4d8'
    };
    
    if (chartTheme === 'dark') {
      return {
        bg: baseColor,
        paper: baseColor,
        text: lighterShades[500],
        grid: lighterShades[100],
        line: '#60a5fa',
        upColor: '#22c55e',
        downColor: '#ef4444',
        volume: {
          up: 'rgba(34, 197, 94, 0.8)',
          down: 'rgba(239, 68, 68, 0.8)'
        },
        indicators: {
          ma: ['#f59e0b', '#f97316', '#dc2626', '#7c3aed'],
          ema: ['#10b981', '#059669', '#047857', '#065f46'],
          bollinger: '#06b6d4',
          rsi: '#8b5cf6',
          macd: '#ec4899',
          obv: '#f59e0b',
          atr: '#14b8a6',
          stoch: '#f472b6',
          vwap: '#84cc16'
        },
        button: {
          bg: lighterShades[100],
          bgActive: '#60a5fa',
          bgHover: lighterShades[200],
          text: lighterShades[500]
        }
      };
    } else {
      return {
        bg: '#ffffff',
        paper: '#ffffff',
        text: baseColor,
        grid: lighterShades[400],
        line: '#3b82f6',
        upColor: '#059669',
        downColor: '#dc2626',
        volume: {
          up: 'rgba(5, 150, 105, 0.8)',
          down: 'rgba(220, 38, 38, 0.8)'
        },
        indicators: {
          ma: ['#f59e0b', '#f97316', '#dc2626', '#7c3aed'],
          ema: ['#10b981', '#059669', '#047857', '#065f46'],
          bollinger: '#0891b2',
          rsi: '#7c3aed',
          macd: '#be185d',
          obv: '#d97706',
          atr: '#0d9488',
          stoch: '#db2777',
          vwap: '#65a30d'
        },
        button: {
          bg: '#f8fafc',
          bgActive: '#3b82f6',
          bgHover: '#f1f5f9',
          text: baseColor
        }
      };
    }
  }, [chartTheme]);

  const priceChartData = useMemo(() => {
    if (!optimizedData.length) return [];

    const timeLabels = optimizedData.map(item => new Date(item.interval_start));
    const plotElements = [];
    
    const chartData = selectedChartType === 'heiken-ashi' ? convertToHeikenAshi(optimizedData) : optimizedData;

    let priceChart;
    
    switch (selectedChartType) {
      case 'candlestick':
        priceChart = {
          x: timeLabels,
          open: optimizedData.map(item => item.open),
          high: optimizedData.map(item => item.high),
          low: optimizedData.map(item => item.low),
          close: optimizedData.map(item => item.close),
          type: 'candlestick',
          name: 'Price',
          decreasing: { 
            line: { color: colors.downColor, width: 1 },
            fillcolor: colors.downColor
          },
          increasing: { 
            line: { color: colors.upColor, width: 1 },
            fillcolor: colors.upColor
          },
          whiskerwidth: 0.8,
          line: { width: 1 }
        };
        break;
        
      case 'ohlc':
        priceChart = {
          x: timeLabels,
          open: optimizedData.map(item => item.open),
          high: optimizedData.map(item => item.high),
          low: optimizedData.map(item => item.low),
          close: optimizedData.map(item => item.close),
          type: 'ohlc',
          name: 'Price',
          decreasing: { line: { color: colors.downColor, width: 2 } },
          increasing: { line: { color: colors.upColor, width: 2 } }
        };
        break;
        
      case 'heiken-ashi':
        priceChart = {
          x: timeLabels,
          open: chartData.map(item => item.ha_open),
          high: chartData.map(item => item.ha_high),
          low: chartData.map(item => item.ha_low),
          close: chartData.map(item => item.ha_close),
          type: 'candlestick',
          name: 'Heiken Ashi',
          decreasing: { 
            line: { color: colors.downColor, width: 1 },
            fillcolor: colors.downColor
          },
          increasing: { 
            line: { color: colors.upColor, width: 1 },
            fillcolor: colors.upColor
          },
          whiskerwidth: 0.8
        };
        break;
        
      case 'line':
        priceChart = {
          x: timeLabels,
          y: optimizedData.map(item => item.close),
          type: 'scatter',
          mode: 'lines',
          name: 'Price',
          line: { 
            color: colors.line, 
            width: 2.5,
            shape: 'linear'
          },
          connectgaps: true
        };
        break;
        
      case 'area':
        priceChart = {
          x: timeLabels,
          y: optimizedData.map(item => item.close),
          type: 'scatter',
          mode: 'lines',
          name: 'Price',
          fill: 'tozeroy',
          fillcolor: 'rgba(96, 165, 250, 0.2)',
          line: { 
            color: colors.line, 
            width: 2.5,
            shape: 'linear'
          },
          connectgaps: true
        };
        break;
    }
    
    plotElements.push(priceChart);

    const prices = optimizedData.map(item => item.close);

    if (activeIndicators.includes('ma')) {
      selectedMAperiods.forEach((period, index) => {
        const ma = calculateIndicator('ma', prices, { period });
        plotElements.push({
          x: timeLabels,
          y: ma,
          type: 'scatter',
          mode: 'lines',
          name: `MA(${period})`,
          line: { 
            color: colors.indicators.ma[index % colors.indicators.ma.length],
            width: 2,
            shape: 'linear'
          },
          connectgaps: false
        });
      });
    }

    if (activeIndicators.includes('ema')) {
      selectedEMAperiods.forEach((period, index) => {
        const ema = calculateIndicator('ema', prices, { period });
        plotElements.push({
          x: timeLabels,
          y: ema,
          type: 'scatter',
          mode: 'lines',
          name: `EMA(${period})`,
          line: { 
            color: colors.indicators.ema[index % colors.indicators.ema.length],
            width: 2,
            dash: 'dash',
            shape: 'linear'
          },
          connectgaps: false
        });
      });
    }

    if (activeIndicators.includes('bollinger')) {
      const bands = calculateIndicator('bollinger', prices, { period: 20, stdDev: 2 }) as any;
      
      plotElements.push({
        x: timeLabels,
        y: bands.upper,
        type: 'scatter',
        mode: 'lines',
        name: 'BB Upper',
        line: { 
          color: colors.indicators.bollinger, 
          width: 1.5, 
          dash: 'dot',
          shape: 'linear'
        },
        showlegend: false,
        connectgaps: false
      });
      
      plotElements.push({
        x: timeLabels,
        y: bands.lower,
        type: 'scatter',
        mode: 'lines',
        name: 'BB Lower',
        line: { 
          color: colors.indicators.bollinger, 
          width: 1.5, 
          dash: 'dot',
          shape: 'linear'
        },
        fill: 'tonexty',
        fillcolor: 'rgba(6, 182, 212, 0.1)',
        showlegend: false,
        connectgaps: false
      });
      
      plotElements.push({
        x: timeLabels,
        y: bands.middle,
        type: 'scatter',
        mode: 'lines',
        name: 'BB(20,2)',
        line: { 
          color: colors.indicators.bollinger, 
          width: 1.5,
          shape: 'linear'
        },
        connectgaps: false
      });
    }

    return plotElements;
  }, [
    optimizedData, 
    selectedChartType, 
    activeIndicators, 
    selectedMAperiods, 
    selectedEMAperiods, 
    colors,
    calculateIndicator,
    convertToHeikenAshi
  ]);

  const volumeChartData = useMemo(() => {
    if (!optimizedData.length) return [];

    const timeLabels = optimizedData.map(item => new Date(item.interval_start));
    const volumes = optimizedData.map(item => item.volume);
    
    const volumeColors = optimizedData.map((item, i) => {
      if (i === 0) return colors.volume.up;
      
      const currentClose = item.close;
      const previousClose = optimizedData[i - 1].close;
      
      return currentClose >= previousClose ? colors.volume.up : colors.volume.down;
    });

    const maxVolume = Math.max(...volumes);
    const minVolume = Math.min(...volumes.filter(v => v > 0));
    const avgVolume = volumes.reduce((sum, vol) => sum + vol, 0) / volumes.length;
    
    const normalizedVolumes = volumes.map(vol => {
      if (vol === 0) return 0;
      
      const minVisibleRatio = 0.02;
      const minVisibleVolume = maxVolume * minVisibleRatio;
      
      return Math.max(vol, minVisibleVolume);
    });

    const volumeChart = {
      x: timeLabels,
      y: normalizedVolumes,
      type: 'bar',
      name: 'Volume',
      marker: {
        color: volumeColors,
        line: { 
          width: deviceType === 'mobile' ? 0 : 0.5,
          color: 'rgba(255,255,255,0.1)' 
        },
        opacity: 0.9
      },
      text: volumes.map(vol => vol.toLocaleString()),
      hovertemplate: '<b>Volume:</b> %{text}<br><b>Time:</b> %{x}<extra></extra>',
      hoverlabel: {
        bgcolor: colors.bg,
        bordercolor: colors.line,
        font: { color: colors.text }
      }
    };

    return [volumeChart];
  }, [optimizedData, colors, deviceType]);

  const rsiChartData = useMemo(() => {
    if (!optimizedData.length || !activeIndicators.includes('rsi')) return [];

    const timeLabels = optimizedData.map(item => new Date(item.interval_start));
    const prices = optimizedData.map(item => item.close);
    const rsi = calculateIndicator('rsi', prices) as number[];

    return [{
      x: timeLabels,
      y: rsi,
      type: 'scatter',
      mode: 'lines',
      name: 'RSI(14)',
      line: { 
        color: colors.indicators.rsi, 
        width: 2,
        shape: 'linear'
      },
      connectgaps: false
    }];
  }, [optimizedData, activeIndicators, colors, calculateIndicator]);

  const macdChartData = useMemo(() => {
    if (!optimizedData.length || !activeIndicators.includes('macd')) return [];

    const timeLabels = optimizedData.map(item => new Date(item.interval_start));
    const prices = optimizedData.map(item => item.close);
    const macd = calculateIndicator('macd', prices) as any;
    
    return [
      {
        x: timeLabels,
        y: macd.macdLine,
        type: 'scatter',
        mode: 'lines',
        name: 'MACD',
        line: { 
          color: colors.indicators.macd, 
          width: 2,
          shape: 'linear'
        },
        connectgaps: false
      },
      {
        x: timeLabels,
        y: macd.signalLine,
        type: 'scatter',
        mode: 'lines',
        name: 'Signal',
        line: { 
          color: '#fbbf24', 
          width: 2,
          shape: 'linear'
        },
        connectgaps: false
      },
      {
        x: timeLabels,
        y: macd.histogram,
        type: 'bar',
        name: 'Histogram',
        marker: {
          color: macd.histogram.map((val: number | null) => 
            val === null ? 'rgba(0,0,0,0)' : 
            val >= 0 ? colors.upColor : colors.downColor
          ),
          opacity: 0.7
        }
      }
    ];
  }, [optimizedData, activeIndicators, colors, calculateIndicator]);

  const chartTitle = useMemo(() => {
    let title = companyId ? 
      `${companyId} - ${selectedInterval.toUpperCase()} Chart [${optimizedData.length} points]` : 
      'Select a Company';
    
    if (isLoadingMoreData) {
      title += '  Expanding...';
    }
    
    return title;
  }, [companyId, selectedInterval, optimizedData.length, isLoadingMoreData]);

  const priceChartLayout = useMemo(() => {
    const getResponsiveMargin = () => {
      switch (deviceType) {
        case 'mobile':
          return { r: 40, l: 40, b: 10, t: 60, pad: 2 };
        case 'tablet':
          return { r: 50, l: 50, b: 15, t: 70, pad: 3 };
        default:
          return { r: 60, l: 60, b: 40, t: 80, pad: 4 };
      }
    };

    const getResponsiveFontSizes = () => {
      switch (deviceType) {
        case 'mobile':
          return { title: 14, axis: 9, tick: 8, legend: 9 };
        case 'tablet':
          return { title: 15, axis: 10, tick: 9, legend: 10 };
        default:
          return { title: 16, axis: 12, tick: 10, legend: 11 };
      }
    };

    const responsiveMargin = getResponsiveMargin();
    const responsiveFonts = getResponsiveFontSizes();

    const baseLayout: any = {
      autosize: true,
      responsive: true,
      
      uirevision: CHART_PERFORMANCE_CONFIG.STABLE_UI_REVISION + '_price',
      
      dragmode: drawingMode || 'pan',
      selectdirection: 'diagonal',
      scrollZoom: true,
      doubleClick: 'reset+autosize',
      
      showlegend: true,
      legend: {
        x: 0,
        y: 1.02,
        orientation: deviceType === 'mobile' ? 'v' : 'h',
        bgcolor: 'rgba(0,0,0,0)',
        font: { color: colors.text, size: responsiveFonts.legend },
        xanchor: deviceType === 'mobile' ? 'left' : 'auto',
        yanchor: deviceType === 'mobile' ? 'bottom' : 'auto'
      },
      margin: responsiveMargin,
      paper_bgcolor: colors.paper,
      plot_bgcolor: colors.bg,
      font: { color: colors.text, family: 'Inter, system-ui, sans-serif' },
      
      xaxis: {
        rangeslider: { visible: false },
        type: 'date',
        showgrid: showGridlines,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text, size: responsiveFonts.tick },
        title: { text: 'Time', font: { color: colors.text, size: responsiveFonts.axis } },
        
        autorange: syncedXRange ? false : true,
        range: syncedXRange || undefined,
        fixedrange: false,
        
        rangebreaks: STABLE_RANGEBREAKS,
        
        nticks: deviceType === 'mobile' ? 5 : deviceType === 'tablet' ? 8 : 12,
        
        showticklabels: true
      },

      yaxis: {
        title: { text: 'Price ()', font: { color: colors.text, size: responsiveFonts.axis } },
        tickformat: ',.2f',
        showgrid: showGridlines,
        gridcolor: colors.grid,
        zerolinecolor: colors.grid,
        linecolor: colors.grid,
        type: logScale ? 'log' : 'linear',
        tickfont: { color: colors.text, size: responsiveFonts.tick },
        side: 'left',
        
        autorange: yRange ? false : true,
        range: yRange || undefined,
        fixedrange: false,
        
        nticks: deviceType === 'mobile' ? 6 : deviceType === 'tablet' ? 8 : 10
      },
      
      hovermode: crosshair ? 'x unified' : 'closest',
      hoverdistance: deviceType === 'mobile' ? 50 : 100,
      spikedistance: deviceType === 'mobile' ? 500 : 1000,
      hoverlabel: {
        bgcolor: colors.bg,
        bordercolor: colors.line,
        font: { color: colors.text, size: responsiveFonts.legend }
      },
      shapes: annotations,
      
      title: {
        text: chartTitle,
        font: { color: colors.text, size: responsiveFonts.title, family: 'Inter, system-ui, sans-serif' },
        x: 0.5,
        xanchor: 'center'
      }
    };
    
    return baseLayout;
  }, [
    showGridlines, 
    logScale, 
    drawingMode, 
    colors, 
    crosshair, 
    annotations, 
    deviceType,
    syncedXRange, 
    yRange,
    chartTitle
  ]);

  const volumeChartLayout = useMemo(() => {
    const getResponsiveMargin = () => {
      switch (deviceType) {
        case 'mobile':
          return { r: 40, l: 40, b: 40, t: 20, pad: 2 };
        case 'tablet':
          return { r: 50, l: 50, b: 45, t: 25, pad: 3 };
        default:
          return { r: 60, l: 60, b: 50, t: 30, pad: 4 };
      }
    };

    const getResponsiveFontSizes = () => {
      switch (deviceType) {
        case 'mobile':
          return { title: 12, axis: 9, tick: 8, legend: 9 };
        case 'tablet':
          return { title: 13, axis: 10, tick: 9, legend: 10 };
        default:
          return { title: 14, axis: 11, tick: 10, legend: 11 };
      }
    };

    const responsiveMargin = getResponsiveMargin();
    const responsiveFonts = getResponsiveFontSizes();

    return {
      autosize: true,
      responsive: true,
      
      uirevision: CHART_PERFORMANCE_CONFIG.STABLE_UI_REVISION + '_volume',
      
      dragmode: 'pan',
      selectdirection: 'diagonal',
      scrollZoom: true,
      doubleClick: 'reset+autosize',
      
      showlegend: false,
      margin: responsiveMargin,
      paper_bgcolor: colors.paper,
      plot_bgcolor: colors.bg,
      font: { color: colors.text, family: 'Inter, system-ui, sans-serif' },
      
      xaxis: {
        type: 'date',
        showgrid: showGridlines,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text, size: responsiveFonts.tick },
        title: { text: '', font: { color: colors.text, size: responsiveFonts.axis } },
        
        autorange: syncedXRange ? false : true,
        range: syncedXRange || undefined,
        fixedrange: false,
        
        rangebreaks: STABLE_RANGEBREAKS,
        
        nticks: deviceType === 'mobile' ? 5 : deviceType === 'tablet' ? 8 : 12,
        
        showticklabels: false
      },

      yaxis: {
        title: { text: 'Volume', font: { color: colors.text, size: responsiveFonts.axis } },
        tickformat: '.2s',
        showgrid: showGridlines,
        gridcolor: colors.grid,
        zerolinecolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text, size: responsiveFonts.tick },
        side: 'left',
        autorange: true,
        fixedrange: false,
        nticks: deviceType === 'mobile' ? 4 : deviceType === 'tablet' ? 6 : 8
      },
      
      hovermode: 'x unified',
      hoverdistance: deviceType === 'mobile' ? 50 : 100,
      spikedistance: deviceType === 'mobile' ? 500 : 1000,
      hoverlabel: {
        bgcolor: colors.bg,
        bordercolor: colors.line,
        font: { color: colors.text, size: responsiveFonts.legend }
      },
      
      title: {
        text: 'Trading Volume',
        font: { color: colors.text, size: responsiveFonts.title, family: 'Inter, system-ui, sans-serif' },
        x: 0.5,
        xanchor: 'center'
      }
    };
  }, [
    showGridlines, 
    colors, 
    deviceType,
    syncedXRange
  ]);

  const rsiChartLayout = useMemo(() => {
    const getResponsiveFontSizes = () => {
      switch (deviceType) {
        case 'mobile':
          return { title: 11, axis: 8, tick: 7, legend: 8 };
        case 'tablet':
          return { title: 12, axis: 9, tick: 8, legend: 9 };
        default:
          return { title: 13, axis: 10, tick: 9, legend: 10 };
      }
    };

    const responsiveFonts = getResponsiveFontSizes();

    return {
      autosize: true,
      responsive: true,
      uirevision: CHART_PERFORMANCE_CONFIG.STABLE_UI_REVISION + '_rsi',
      dragmode: 'pan',
      selectdirection: 'diagonal',
      scrollZoom: true,
      doubleClick: 'reset+autosize',
      showlegend: false,
      margin: { r: 60, l: 60, b: 50, t: 30, pad: 4 },
      paper_bgcolor: colors.paper,
      plot_bgcolor: colors.bg,
      font: { color: colors.text, family: 'Inter, system-ui, sans-serif' },
      
      xaxis: {
        type: 'date',
        showgrid: showGridlines,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text, size: responsiveFonts.tick },
        title: { text: '', font: { color: colors.text, size: responsiveFonts.axis } },
        autorange: syncedXRange ? false : true,
        range: syncedXRange || undefined,
        fixedrange: false,
        rangebreaks: STABLE_RANGEBREAKS,
        nticks: deviceType === 'mobile' ? 5 : deviceType === 'tablet' ? 8 : 12,
        showticklabels: false
      },

      yaxis: {
        title: { text: 'RSI', font: { color: colors.indicators.rsi, size: responsiveFonts.axis } },
        range: [0, 100],
        showgrid: true,
        gridcolor: colors.grid,
        tickfont: { color: colors.text, size: responsiveFonts.tick },
        tickvals: [20, 50, 80],
        side: 'left',
        nticks: 3
      },
      
      hovermode: 'x unified',
      hoverdistance: deviceType === 'mobile' ? 50 : 100,
      spikedistance: deviceType === 'mobile' ? 500 : 1000,
      hoverlabel: {
        bgcolor: colors.bg,
        bordercolor: colors.line,
        font: { color: colors.text, size: responsiveFonts.legend }
      },
      
      title: {
        text: 'RSI (14)',
        font: { color: colors.text, size: responsiveFonts.title, family: 'Inter, system-ui, sans-serif' },
        x: 0.5,
        xanchor: 'center'
      },

      shapes: [
        {
          type: 'line',
          x0: 0,
          x1: 1,
          xref: 'paper',
          y0: 70,
          y1: 70,
          line: { color: colors.downColor, width: 1, dash: 'dash' }
        },
        {
          type: 'line',
          x0: 0,
          x1: 1,
          xref: 'paper',
          y0: 30,
          y1: 30,
          line: { color: colors.upColor, width: 1, dash: 'dash' }
        }
      ]
    };
  }, [showGridlines, colors, deviceType, syncedXRange]);

  const macdChartLayout = useMemo(() => {
    const getResponsiveFontSizes = () => {
      switch (deviceType) {
        case 'mobile':
          return { title: 11, axis: 8, tick: 7, legend: 8 };
        case 'tablet':
          return { title: 12, axis: 9, tick: 8, legend: 9 };
        default:
          return { title: 13, axis: 10, tick: 9, legend: 10 };
      }
    };

    const responsiveFonts = getResponsiveFontSizes();

    return {
      autosize: true,
      responsive: true,
      uirevision: CHART_PERFORMANCE_CONFIG.STABLE_UI_REVISION + '_macd',
      dragmode: 'pan',
      selectdirection: 'diagonal',
      scrollZoom: true,
      doubleClick: 'reset+autosize',
      showlegend: true,
      legend: {
        x: 0,
        y: 1.02,
        orientation: 'h',
        bgcolor: 'rgba(0,0,0,0)',
        font: { color: colors.text, size: responsiveFonts.legend - 1 }
      },
      margin: { r: 60, l: 60, b: 50, t: 30, pad: 4 },
      paper_bgcolor: colors.paper,
      plot_bgcolor: colors.bg,
      font: { color: colors.text, family: 'Inter, system-ui, sans-serif' },
      
      xaxis: {
        type: 'date',
        showgrid: showGridlines,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text, size: responsiveFonts.tick },
        title: { text: 'Time', font: { color: colors.text, size: responsiveFonts.axis } },
        autorange: syncedXRange ? false : true,
        range: syncedXRange || undefined,
        fixedrange: false,
        rangebreaks: STABLE_RANGEBREAKS,
        nticks: deviceType === 'mobile' ? 5 : deviceType === 'tablet' ? 8 : 12,
        showticklabels: true
      },

      yaxis: {
        title: { text: 'MACD', font: { color: colors.indicators.macd, size: responsiveFonts.axis } },
        showgrid: true,
        gridcolor: colors.grid,
        tickfont: { color: colors.text, size: responsiveFonts.tick },
        side: 'left',
        nticks: deviceType === 'mobile' ? 3 : 5
      },
      
      hovermode: 'x unified',
      hoverdistance: deviceType === 'mobile' ? 50 : 100,
      spikedistance: deviceType === 'mobile' ? 500 : 1000,
      hoverlabel: {
        bgcolor: colors.bg,
        bordercolor: colors.line,
        font: { color: colors.text, size: responsiveFonts.legend }
      },
      
      title: {
        text: 'MACD (12,26,9)',
        font: { color: colors.text, size: responsiveFonts.title, family: 'Inter, system-ui, sans-serif' },
        x: 0.5,
        xanchor: 'center'
      }
    };
  }, [showGridlines, colors, deviceType, syncedXRange]);

  const config = useMemo(() => ({
    responsive: true,
    useResizeHandler: true,
    autosize: true,
    scrollZoom: true,
    displayModeBar: deviceType !== 'mobile',
    modeBarButtonsToAdd: deviceType !== 'mobile' ? [
      'drawline',
      'drawopenpath',
      'drawclosedpath',
      'drawcircle',
      'drawrect',
      'eraseshape'
    ] : [],
    modeBarButtonsToRemove: deviceType === 'mobile' ? 
      ['select2d', 'lasso2d', 'autoScale2d', 'resetScale2d'] : 
      ['select2d', 'lasso2d'],
    displaylogo: false,
    doubleClick: 'reset+autosize',
    showTips: false,
    plotGlPixelRatio: window.devicePixelRatio || 1,
    toImageButtonOptions: {
      format: 'png',
      filename: `${companyId || 'chart'}_${new Date().toISOString().split('T')[0]}`,
      height: priceChartHeight,
      width: chartDimensions.width,
      scale: deviceType === 'mobile' ? 1 : 2
    }
  }), [companyId, chartDimensions, deviceType, priceChartHeight]);

  const toggleFullscreen = useCallback(() => {
    setIsFullscreen(prev => !prev);
  }, []);

  const toggleAutoResize = useCallback(() => {
    setAutoResize(prev => !prev);
  }, []);

  const toggleResponsiveMode = useCallback(() => {
    setResponsiveMode(prev => prev === 'auto' ? 'manual' : 'auto');
  }, []);

  const handleAspectRatioChange = useCallback((ratio: keyof typeof CHART_PERFORMANCE_CONFIG.ASPECT_RATIOS) => {
    setAspectRatio(ratio);
  }, []);

  const toggleIndicator = useCallback((id: string) => {
    setActiveIndicators(prev => 
      prev.includes(id) 
        ? prev.filter(ind => ind !== id) 
        : [...prev, id]
    );
  }, []);

  const toggleMAPeriod = useCallback((period: number) => {
    setSelectedMAperiods(prev => 
      prev.includes(period) 
        ? prev.filter(p => p !== period) 
        : [...prev, period].sort((a, b) => a - b)
    );
  }, []);

  const toggleEMAPeriod = useCallback((period: number) => {
    setSelectedEMAperiods(prev => 
      prev.includes(period) 
        ? prev.filter(p => p !== period) 
        : [...prev, period].sort((a, b) => a - b)
    );
  }, []);

  const handleThemeToggle = useCallback(() => {
    const newTheme = chartTheme === 'dark' ? 'light' : 'dark';
    setChartTheme(newTheme);
    if (onThemeChange) {
      onThemeChange(newTheme);
    }
  }, [chartTheme, onThemeChange]);

  const handleIntervalChange = useCallback((newInterval: string) => {
    setSelectedInterval(newInterval);
    if (onIntervalChange) {
      onIntervalChange(newInterval);
    }
  }, [onIntervalChange]);

  const handleChartTypeChange = useCallback((type: string) => {
    setSelectedChartType(type);
  }, []);

  const handleDrawingModeChange = useCallback((mode: string | null) => {
    setDrawingMode(mode);
    if (priceChartRef.current) {
      const update = { dragmode: mode || 'pan' };
      priceChartRef.current.relayout(update);
    }
  }, []);

  const handlePlotUpdate = useCallback((figure: any) => {
    if (figure.layout?.shapes) {
      setAnnotations(figure.layout.shapes);
    }
  }, []);

  const resetChart = useCallback(() => {
    setXRange(null);
    setYRange(null);
    setSyncedXRange(null);
    
    const resetUpdate = { 
      'xaxis.autorange': true,
      'yaxis.autorange': true,
      'xaxis.range': undefined,
      'yaxis.range': undefined,
      dragmode: 'pan'
    };
    
    const charts = [priceChartRef, volumeChartRef, rsiChartRef, macdChartRef];
    
    charts.forEach(chartRef => {
      if (chartRef.current) {
        chartRef.current.relayout(resetUpdate);
      }
    });
    
    setAnnotations([]);
    setDrawingMode(null);
  }, []);

  const exportChartData = useCallback(() => {
    if (!optimizedData.length) return;

    const csvContent = [
      'Date,Open,High,Low,Close,Volume',
      ...optimizedData.map(item => 
        `${item.interval_start},${item.open},${item.high},${item.low},${item.close},${item.volume}`
      )
    ].join('\n');

    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${companyId || 'chart'}_${selectedInterval}_${new Date().toISOString().split('T')[0]}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, [optimizedData, companyId, selectedInterval]);

  useEffect(() => {
    if (!autoRefresh || !onIntervalChange) return;

    const interval = setInterval(() => {
      onIntervalChange(selectedInterval);
    }, refreshInterval);

    return () => clearInterval(interval);
  }, [autoRefresh, refreshInterval, selectedInterval, onIntervalChange]);

  const addPriceAlert = useCallback((price: number, type: 'above' | 'below') => {
    const newAlert = {
      id: Date.now(),
      price,
      type,
      triggered: false,
      createdAt: new Date()
    };
    setPriceAlerts(prev => [...prev, newAlert]);
  }, []);

  const removePriceAlert = useCallback((id: number) => {
    setPriceAlerts(prev => prev.filter(alert => alert.id !== id));
  }, []);

  useEffect(() => {
    if (!alertsEnabled || !optimizedData.length || !priceAlerts.length) return;

    const currentPrice = optimizedData[optimizedData.length - 1]?.close;
    if (!currentPrice) return;

    priceAlerts.forEach(alert => {
      if (alert.triggered) return;

      const shouldTrigger = 
        (alert.type === 'above' && currentPrice >= alert.price) ||
        (alert.type === 'below' && currentPrice <= alert.price);

      if (shouldTrigger) {
        setPriceAlerts(prev => 
          prev.map(a => a.id === alert.id ? { ...a, triggered: true } : a)
        );

        if ('Notification' in window && Notification.permission === 'granted') {
          new Notification(`Price Alert: ${companyId}`, {
            body: `Price ${alert.type} ${alert.price.toFixed(2)} (Current: ${currentPrice.toFixed(2)})`,
            icon: '/favicon.ico'
          });
        }
      }
    });
  }, [optimizedData, priceAlerts, alertsEnabled, companyId]);

  useEffect(() => {
    if (alertsEnabled && 'Notification' in window && Notification.permission === 'default') {
      Notification.requestPermission();
    }
  }, [alertsEnabled]);

  useEffect(() => {
    const handleKeyPress = (e: KeyboardEvent) => {
      if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
          case 't':
            e.preventDefault();
            handleThemeToggle();
            break;
          case 'g':
            e.preventDefault();
            setShowGridlines(prev => !prev);
            break;
          case 'v':
            e.preventDefault();
            setShowVolume(prev => !prev);
            break;
          case 'c':
            e.preventDefault();
            setCrosshair(prev => !prev);
            break;
          case 'l':
            e.preventDefault();
            setLogScale(prev => !prev);
            break;
          case 's':
            e.preventDefault();
            setSidebarVisible(prev => !prev);
            break;
          case 'r':
            e.preventDefault();
            resetChart();
            break;
          case 'f':
            e.preventDefault();
            toggleFullscreen();
            break;
          case 'a':
            e.preventDefault();
            toggleAutoResize();
            break;
        }
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [handleThemeToggle, resetChart, toggleFullscreen, toggleAutoResize]);

  useEffect(() => {
    setSelectedInterval(interval);
  }, [interval]);

  useEffect(() => {
    setChartTheme(theme);
  }, [theme]);

  const buttonStyle = {
    backgroundColor: colors.button.bg,
    color: colors.button.text,
    border: `1px solid ${colors.grid}`,
    borderRadius: '6px',
    padding: deviceType === 'mobile' ? '4px 8px' : '6px 12px',
    fontSize: deviceType === 'mobile' ? '11px' : '12px',
    fontWeight: '500',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    display: 'flex',
    alignItems: 'center',
    gap: '4px'
  };

  const activeButtonStyle = {
    ...buttonStyle,
    backgroundColor: colors.button.bgActive,
    color: '#ffffff',
    borderColor: colors.button.bgActive
  };

  const containerStyle = useMemo(() => ({
    width: '100%',
    height: isFullscreen ? '100vh' : `${height}px`,
    backgroundColor: colors.bg,
    fontFamily: 'Inter, system-ui, sans-serif',
    position: isFullscreen ? 'fixed' as const : 'relative' as const,
    top: isFullscreen ? 0 : 'auto',
    left: isFullscreen ? 0 : 'auto',
    zIndex: isFullscreen ? 9999 : 'auto',
    overflow: 'hidden',
    minWidth: `${CHART_PERFORMANCE_CONFIG.MIN_CHART_WIDTH}px`,
    minHeight: `${CHART_PERFORMANCE_CONFIG.MIN_CHART_HEIGHT}px`
  }), [colors.bg, height, isFullscreen]);

  const chartContainerStyle = useMemo(() => {
    const sidebarWidth = sidebarVisible && deviceType !== 'mobile' ? CHART_PERFORMANCE_CONFIG.SIDEBAR_WIDTH : 0;
    return {
      marginLeft: deviceType === 'mobile' ? '0px' : `${sidebarWidth}px`,
      transition: 'margin-left 0.3s ease',
      height: '100%',
      width: deviceType === 'mobile' ? '100%' : sidebarVisible ? `calc(100% - ${sidebarWidth}px)` : '100%',
      minWidth: `${CHART_PERFORMANCE_CONFIG.MIN_CHART_WIDTH}px`,
      position: 'relative' as const,
      display: 'flex',
      flexDirection: 'column' as const
    };
  }, [sidebarVisible, deviceType]);

  const testDynamicLoading = useCallback(() => {
    console.log('=== Testing Dynamic Loading ===');
    console.log('Current allData length:', allData.length);
    console.log('Company ID:', companyId);
    console.log('Is loading:', isLoadingMoreData);
    
    if (!companyId) {
      console.error('No company ID set');
      return;
    }
    
    if (allData.length === 0) {
      console.error('No initial data available');
      return;
    }
    
    const now = new Date();
    const testRange: [string, string] = [
      new Date(now.getTime() - 6 * 60 * 60 * 1000).toISOString(),
      new Date(now.getTime() + 1 * 60 * 60 * 1000).toISOString()
    ];
    
    console.log('Test range:', testRange);
    
    const gaps = detectDataGaps(testRange);
    console.log('Detected gaps:', gaps);
    
    if (gaps && gaps.length > 0) {
      console.log('Triggering test fetch...');
      fetchMissingData(gaps);
    } else {
      console.log('No gaps detected in test range');
      
      const forcedGap = [{
        type: 'test',
        start: new Date(now.getTime() - 2 * 60 * 60 * 1000),
        end: new Date(now.getTime() - 1 * 60 * 60 * 1000),
        priority: 'high' as const
      }];
      
      console.log('Forcing test gap:', forcedGap);
      fetchMissingData(forcedGap);
    }
  }, [allData, companyId, detectDataGaps, fetchMissingData, isLoadingMoreData]);

  if (loading && allData.length === 0) {
    return (
      <div 
        className="flex items-center justify-center" 
        style={{ 
          height: `${height}px`, 
          backgroundColor: colors.bg,
          color: colors.text,
          fontFamily: 'Inter, system-ui, sans-serif'
        }}
      >
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4"></div>
          <p className="text-lg font-medium">Loading chart data...</p>
          <p className="text-sm opacity-70 mt-2">Optimizing for smooth performance</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div 
        className="flex items-center justify-center" 
        style={{ 
          height: `${height}px`, 
          backgroundColor: colors.bg,
          color: colors.text,
          fontFamily: 'Inter, system-ui, sans-serif'
        }}
      >
        <div className="text-center">
          <div className="text-red-500 text-6xl mb-4"></div>
          <p className="text-lg font-medium text-red-400">Error loading chart</p>
          <p className="text-sm opacity-70 mt-2">{error}</p>
        </div>
      </div>
    );
  }

  if (!data || data.length === 0) {
    return (
      <div 
        className="flex items-center justify-center" 
        style={{ 
          height: `${height}px`, 
          backgroundColor: colors.bg,
          color: colors.text,
          fontFamily: 'Inter, system-ui, sans-serif'
        }}
      >
        <div className="text-center">
          <div className="text-gray-400 text-6xl mb-4"></div>
          <p className="text-lg font-medium">No data available</p>
          <p className="text-sm opacity-70 mt-2">Select a company and date range to view the chart</p>
        </div>
      </div>
    );
  }

  return (
    <div 
      ref={containerRef}
      style={containerStyle}
    >
      <LoadingIndicator show={showLoadingIndicator || isLoadingMoreData} />

      {sidebarVisible && deviceType !== 'mobile' && (
        <div 
          className="absolute top-0 left-0 z-10 p-4 rounded-lg shadow-lg border max-h-full overflow-y-auto"
          style={{ 
            backgroundColor: colors.paper,
            borderColor: colors.grid,
            width: `${CHART_PERFORMANCE_CONFIG.SIDEBAR_WIDTH}px`,
            maxHeight: `${height - 20}px`
          }}
        >
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-lg font-semibold" style={{ color: colors.text }}>
              Chart Controls
            </h3>
            <div className="flex space-x-1">
              <button
                onClick={toggleFullscreen}
                style={buttonStyle}
                title={isFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen'}
                onMouseEnter={(e) => e.currentTarget.style.backgroundColor = colors.button.bgHover}
                onMouseLeave={(e) => e.currentTarget.style.backgroundColor = colors.button.bg}
              >
                {isFullscreen ? <Minimize2 size={16} /> : <Maximize2 size={16} />}
              </button>
              <button
                onClick={() => setSidebarVisible(false)}
                style={buttonStyle}
                onMouseEnter={(e) => e.currentTarget.style.backgroundColor = colors.button.bgHover}
                onMouseLeave={(e) => e.currentTarget.style.backgroundColor = colors.button.bg}
              >
                <EyeOff size={16} />
              </button>
            </div>
          </div>

          <div className="mb-4">
            <label className="block text-sm font-medium mb-2" style={{ color: colors.text }}>
              Theme
            </label>
            <button
              onClick={handleThemeToggle}
              style={buttonStyle}
              className="w-full justify-center"
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = colors.button.bgHover}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = colors.button.bg}
            >
              {chartTheme === 'dark' ? <Sun size={16} /> : <Moon size={16} />}
              {chartTheme === 'dark' ? 'Light Mode' : 'Dark Mode'}
            </button>
          </div>

          <div className="mb-4">
            <label className="block text-sm font-medium mb-2" style={{ color: colors.text }}>
              Time Interval
            </label>
            <div className="grid grid-cols-4 gap-1">
              {timeIntervals.map(interval => (
                <button
                  key={interval.id}
                  onClick={() => handleIntervalChange(interval.id)}
                  style={selectedInterval === interval.id ? activeButtonStyle : buttonStyle}
                  className="text-center"
                  onMouseEnter={(e) => {
                    if (selectedInterval !== interval.id) {
                      e.currentTarget.style.backgroundColor = colors.button.bgHover;
                    }
                  }}
                  onMouseLeave={(e) => {
                    if (selectedInterval !== interval.id) {
                      e.currentTarget.style.backgroundColor = colors.button.bg;
                    }
                  }}
                >
                  {interval.name}
                </button>
              ))}
            </div>
          </div>

          <div className="mb-4">
            <label className="block text-sm font-medium mb-2" style={{ color: colors.text }}>
              Chart Type
            </label>
            <div className="grid grid-cols-2 gap-1">
              {chartTypes.map(type => {
                const Icon = type.icon;
                return (
                  <button
                    key={type.id}
                    onClick={() => handleChartTypeChange(type.id)}
                    style={selectedChartType === type.id ? activeButtonStyle : buttonStyle}
                    onMouseEnter={(e) => {
                      if (selectedChartType !== type.id) {
                        e.currentTarget.style.backgroundColor = colors.button.bgHover;
                      }
                    }}
                    onMouseLeave={(e) => {
                      if (selectedChartType !== type.id) {
                        e.currentTarget.style.backgroundColor = colors.button.bg;
                      }
                    }}
                  >
                    <Icon size={14} />
                    {type.name}
                  </button>
                );
              })}
            </div>
          </div>

          <div className="mb-4">
            <label className="block text-sm font-medium mb-2" style={{ color: colors.text }}>
              Drawing Tools
            </label>
            <div className="grid grid-cols-2 gap-1">
              {drawingTools.map(tool => {
                const Icon = tool.icon;
                return (
                  <button
                    key={tool.id}
                    onClick={() => handleDrawingModeChange(drawingMode === tool.id ? null : tool.id)}
                    style={drawingMode === tool.id ? activeButtonStyle : buttonStyle}
                    onMouseEnter={(e) => {
                      if (drawingMode !== tool.id) {
                        e.currentTarget.style.backgroundColor = colors.button.bgHover;
                      }
                    }}
                    onMouseLeave={(e) => {
                      if (drawingMode !== tool.id) {
                        e.currentTarget.style.backgroundColor = colors.button.bg;
                      }
                    }}
                  >
                    <Icon size={14} />
                    {tool.name}
                  </button>
                );
              })}
            </div>
            <button
              onClick={resetChart}
              style={buttonStyle}
              className="w-full justify-center mt-2"
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = colors.button.bgHover}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = colors.button.bg}
            >
              <RotateCcw size={14} />
              Reset Chart
            </button>
            <button
              onClick={testDynamicLoading}
              style={buttonStyle}
              className="w-full justify-center mt-2"
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = colors.button.bgHover}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = colors.button.bg}
            >
               Test Dynamic Loading
            </button>
          </div>

          <div className="mb-4">
            <label className="block text-sm font-medium mb-2" style={{ color: colors.text }}>
              Technical Indicators
            </label>
            <div className="space-y-2">
              {availableIndicators.map(indicator => (
                <div key={indicator.id} className="flex items-center space-x-2">
                  <input
                    type="checkbox"
                    id={indicator.id}
                    checked={activeIndicators.includes(indicator.id)}
                    onChange={() => toggleIndicator(indicator.id)}
                    className="rounded"
                    style={{ 
                      accentColor: colors.button.bgActive,
                      backgroundColor: colors.button.bg
                    }}
                  />
                  <label 
                    htmlFor={indicator.id} 
                    className="text-sm cursor-pointer flex-1"
                    style={{ color: colors.text }}
                  >
                    {indicator.name}
                  </label>
                </div>
              ))}
            </div>
          </div>

          {activeIndicators.includes('ma') && (
            <div className="mb-4">
              <label className="block text-sm font-medium mb-2" style={{ color: colors.text }}>
                MA Periods
              </label>
              <div className="grid grid-cols-3 gap-1">
                {availableIndicators.find(ind => ind.id === 'ma')?.periods?.map(period => (
                  <button
                    key={period}
                    onClick={() => toggleMAPeriod(period)}
                    style={selectedMAperiods.includes(period) ? activeButtonStyle : buttonStyle}
                    onMouseEnter={(e) => {
                      if (!selectedMAperiods.includes(period)) {
                        e.currentTarget.style.backgroundColor = colors.button.bgHover;
                      }
                    }}
                    onMouseLeave={(e) => {
                      if (!selectedMAperiods.includes(period)) {
                        e.currentTarget.style.backgroundColor = colors.button.bg;
                      }
                    }}
                  >
                    {period}
                  </button>
                ))}
              </div>
            </div>
          )}

          {activeIndicators.includes('ema') && (
            <div className="mb-4">
              <label className="block text-sm font-medium mb-2" style={{ color: colors.text }}>
                EMA Periods
              </label>
              <div className="grid grid-cols-3 gap-1">
                {availableIndicators.find(ind => ind.id === 'ema')?.periods?.map(period => (
                  <button
                    key={period}
                    onClick={() => toggleEMAPeriod(period)}
                    style={selectedEMAperiods.includes(period) ? activeButtonStyle : buttonStyle}
                    onMouseEnter={(e) => {
                      if (!selectedEMAperiods.includes(period)) {
                        e.currentTarget.style.backgroundColor = colors.button.bgHover;
                      }
                    }}
                    onMouseLeave={(e) => {
                      if (!selectedEMAperiods.includes(period)) {
                        e.currentTarget.style.backgroundColor = colors.button.bg;
                      }
                    }}
                  >
                    {period}
                  </button>
                ))}
              </div>
            </div>
          )}

          <div className="mb-4">
            <label className="block text-sm font-medium mb-2" style={{ color: colors.text }}>
              Display Options
            </label>
            <div className="space-y-2">
              <div className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  id="volume"
                  checked={showVolume}
                  onChange={(e) => setShowVolume(e.target.checked)}
                  style={{ 
                    accentColor: colors.button.bgActive,
                    backgroundColor: colors.button.bg
                  }}
                />
                <label htmlFor="volume" className="text-sm cursor-pointer" style={{ color: colors.text }}>
                  Show Volume Chart
                </label>
              </div>
              
              <div className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  id="gridlines"
                  checked={showGridlines}
                  onChange={(e) => setShowGridlines(e.target.checked)}
                  style={{ 
                    accentColor: colors.button.bgActive,
                    backgroundColor: colors.button.bg
                  }}
                />
                <label htmlFor="gridlines" className="text-sm cursor-pointer" style={{ color: colors.text }}>
                  Show Gridlines
                </label>
              </div>
            </div>
          </div>

          <div className="mb-4">
            <div className="space-y-2">
              <button
                onClick={() => {
                  setAnnotations([]);
                  if (priceChartRef.current) {
                    priceChartRef.current.relayout({ shapes: [] });
                  }
                }}
                style={buttonStyle}
                className="w-full justify-center"
                onMouseEnter={(e) => e.currentTarget.style.backgroundColor = colors.button.bgHover}
                onMouseLeave={(e) => e.currentTarget.style.backgroundColor = colors.button.bg}
              >
                <Eraser size={14} />
                Clear Drawings
              </button>
            </div>
          </div>
        </div>
      )}

      {deviceType === 'mobile' && sidebarVisible && (
        <div 
          className="absolute bottom-0 left-0 right-0 z-10 p-3 border-t"
          style={{ 
            backgroundColor: colors.paper,
            borderColor: colors.grid,
            maxHeight: '40%',
            overflowY: 'auto'
          }}
        >
          <div className="flex justify-between items-center mb-3">
            <h4 className="text-sm font-semibold" style={{ color: colors.text }}>
              Controls
            </h4>
            <button
              onClick={() => setSidebarVisible(false)}
              style={buttonStyle}
            >
              <EyeOff size={14} />
            </button>
          </div>
          
          <div className="grid grid-cols-4 gap-2 mb-3">
            {timeIntervals.slice(0, 4).map(interval => (
              <button
                key={interval.id}
                onClick={() => handleIntervalChange(interval.id)}
                style={selectedInterval === interval.id ? activeButtonStyle : buttonStyle}
                className="text-center"
              >
                {interval.name}
              </button>
            ))}
          </div>
          
          <div className="grid grid-cols-3 gap-2">
            <button
              onClick={handleThemeToggle}
              style={buttonStyle}
              className="justify-center"
            >
              {chartTheme === 'dark' ? <Sun size={14} /> : <Moon size={14} />}
            </button>
            <button
              onClick={() => setShowVolume(!showVolume)}
              style={showVolume ? activeButtonStyle : buttonStyle}
              className="justify-center"
            >
              Volume
            </button>
            <button
              onClick={resetChart}
              style={buttonStyle}
              className="justify-center"
            >
              <RotateCcw size={14} />
            </button>
          </div>
        </div>
      )}

      {!sidebarVisible && (
        <button
          onClick={() => setSidebarVisible(true)}
          className="absolute top-4 left-4 z-10 rounded-lg shadow-lg"
          style={buttonStyle}
          onMouseEnter={(e) => e.currentTarget.style.backgroundColor = colors.button.bgHover}
          onMouseLeave={(e) => e.currentTarget.style.backgroundColor = colors.button.bg}
        >
          <Settings size={16} />
          {deviceType !== 'mobile' && 'Controls'}
        </button>
      )}

      <div 
        ref={chartContainerRef}
        style={chartContainerStyle}
      >
        <div 
          style={{ 
            height: `${priceChartHeight}px`,
            marginBottom: `${CHART_PERFORMANCE_CONFIG.CHART_GAP}px`
          }}
        >
          <Plot
            ref={priceChartRef}
            data={priceChartData}
            layout={priceChartLayout}
            config={config}
            style={{ width: '100%', height: '100%' }}
            onUpdate={handlePlotUpdate}
            onRelayout={handlePriceChartRelayout}
            useResizeHandler={true}
            onInitialized={() => {
              console.log('Price chart initialized');
            }}
          />
        </div>

        {showVolume && volumeChartHeight > 0 && (
          <div 
            style={{ 
              height: `${volumeChartHeight}px`,
              marginBottom: `${CHART_PERFORMANCE_CONFIG.CHART_GAP}px`
            }}
          >
            <Plot
              ref={volumeChartRef}
              data={volumeChartData}
              layout={volumeChartLayout}
              config={config}
              style={{ width: '100%', height: '100%' }}
              onRelayout={handleVolumeChartRelayout}
              useResizeHandler={true}
              onInitialized={() => {
                console.log('Volume chart initialized');
              }}
            />
          </div>
        )}

        {activeIndicators.includes('rsi') && rsiChartHeight > 0 && (
          <div 
            style={{ 
              height: `${rsiChartHeight}px`,
              marginBottom: `${CHART_PERFORMANCE_CONFIG.CHART_GAP}px`
            }}
          >
            <Plot
              ref={rsiChartRef}
              data={rsiChartData}
              layout={rsiChartLayout}
              config={config}
              style={{ width: '100%', height: '100%' }}
              onRelayout={handleRsiChartRelayout}
              useResizeHandler={true}
              onInitialized={() => {
                console.log('RSI chart initialized');
              }}
            />
          </div>
        )}

        {activeIndicators.includes('macd') && macdChartHeight > 0 && (
          <div 
            style={{ 
              height: `${macdChartHeight}px`,
              marginBottom: `${CHART_PERFORMANCE_CONFIG.CHART_GAP}px`
            }}
          >
            <Plot
              ref={macdChartRef}
              data={macdChartData}
              layout={macdChartLayout}
              config={config}
              style={{ width: '100%', height: '100%' }}
              onRelayout={handleMacdChartRelayout}
              useResizeHandler={true}
              onInitialized={() => {
                console.log('MACD chart initialized');
              }}
            />
          </div>
        )}

        <div 
          className="absolute bottom-4 right-4 p-3 rounded-lg shadow-lg border text-xs"
          style={{ 
            backgroundColor: colors.paper,
            borderColor: colors.grid,
            color: colors.text,
            maxWidth: deviceType === 'mobile' ? '200px' : '250px'
          }}
        >
        </div>

        <div className="absolute top-4 left-20">
          <div className="flex items-center space-x-2">
          </div>
        </div>
      </div>
    </div>
  );
}

export default StockChart;


################################################################################
END OF CORE WATCHLIST SYSTEM EXTRACTION
################################################################################

EXTRACTION SUMMARY:
===================
Core Watchlist Files: 3 files
Data and Entity Files: 4 files
Data Processing Files: 2 files + CSV samples
Frontend Watchlist Management: 3 files
Frontend Data Hooks: 3 files
Frontend Display Components: 2 files

TOTAL FILES PROCESSED: 17 FILES + CSV SAMPLES
################################################################################
