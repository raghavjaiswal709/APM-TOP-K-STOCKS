================================================================================
FYERS AUTHENTICATION SYSTEM - ALL FILES
Generated on: 23-07-2025 18:16:41.74
================================================================================

CATEGORIES:
1. Backend Python Files (2 files)
2. Backend NestJS Modules and Services (4 files)
3. Frontend API Routes (4 files)
4. Frontend Components and Pages (3 files)
5. Frontend UI and Data Files (2 files)

TOTAL: 15 FILES
================================================================================


################################################################################
SECTION 1: BACKEND PYTHON FILES
################################################################################

================================================================================
FILE: apps/backend/fyers_data_automated.py
PURPOSE: Automated Fyers data fetching implementation
================================================================================

import eventlet
eventlet.monkey_patch()

import socketio
import json
import sys
import time
import datetime
import pytz
import threading
import logging
import requests
import numpy as np
import os
import webbrowser
from collections import deque
from urllib.parse import quote_plus
from fyers_apiv3 import fyersModel
from fyers_apiv3.FyersWebsocket import data_ws

# Fix Windows Unicode encoding issue
if sys.platform.startswith('win'):
    import codecs
    sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'strict')
    sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'strict')

# Enhanced logging with UTF-8 encoding
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(
            f'fyers_data_{datetime.datetime.now().strftime("%Y%m%d")}.log', 
            encoding='utf-8'
        ),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger("AutomatedFyersServer")

# Socket.IO setup
sio = socketio.Server(cors_allowed_origins='*', async_mode='eventlet')
app = socketio.WSGIApp(sio)

# Configuration - Updated for correct V3 API endpoints
client_id = "150HUKJSWG-100"
secret_key = "18YYNXCAS7"
# redirect_uri = "http://localhost:5000/auth/fyers/callback"
# redirect_uri = "https://127.0.0.1:5000/auth/fyers/callback"
redirect_uri = "https://raghavjaiswal709.github.io/DAKSphere_redirect/"

response_type = "code"
grant_type = "authorization_code"

# API Endpoints - Using correct T1 endpoints
BASE_URL_V3 = "https://api-t1.fyers.in/api/v3"
AUTH_URL = f"{BASE_URL_V3}/generate-authcode"
TOKEN_URL = f"{BASE_URL_V3}/validate-authcode"

# Global variables
clients = {}
symbol_to_clients = {}
running = True
historical_data = {}
ohlc_data = {}
MAX_HISTORY_POINTS = 10000
INDIA_TZ = pytz.timezone('Asia/Kolkata')
fyers = None
fyers_client = None
auth_completed = threading.Event()
access_token = None

class AutomatedAuthHandler:
    def __init__(self):
        self.auth_file_path = os.path.join('data', 'fyers_data_auth.json')
        self.polling_interval = 2  # seconds
        self.max_wait_time = 300  # 5 minutes
        
    def wait_for_auth_completion(self):
        """Wait for authentication to be completed via web interface"""
        logger.info("Starting automated authentication process...")
        
        # Generate auth URL and open browser
        auth_url = self.generate_auth_url()
        logger.info(f"Opening browser with auth URL: {auth_url}")
        
        try:
            webbrowser.open(auth_url)
            logger.info("Browser opened successfully")
        except Exception as e:
            logger.error(f"Failed to open browser: {e}")
            logger.info(f"Please manually open: {auth_url}")
        
        # Poll for auth completion
        start_time = time.time()
        while not auth_completed.is_set():
            if time.time() - start_time > self.max_wait_time:
                logger.error("Authentication timeout. Please try again.")
                return None
                
            if self.check_auth_file():
                logger.info("Authentication completed!")
                return self.load_auth_data()
                
            time.sleep(self.polling_interval)
            logger.debug("Waiting for authentication...")
            
        return None
    
    def generate_auth_url(self):
        """Generate Fyers auth URL using correct V3 endpoint"""
        try:
            # Use api-t1.fyers.in for V3 API
            encoded_redirect_uri = quote_plus(redirect_uri)
            state = "None"  # Standard state value for Fyers API
            
            auth_url = f"{AUTH_URL}?client_id={client_id}&redirect_uri={encoded_redirect_uri}&response_type={response_type}&state={state}"
            
            logger.info(f"Generated auth URL: {auth_url}")
            return auth_url
            
        except Exception as e:
            logger.error(f"Error generating auth URL: {e}")
            raise
    
    def check_auth_file(self):
        """Check if auth file exists and is recent"""
        try:
            if not os.path.exists(self.auth_file_path):
                return False
                
            # Check if file is recent (within last 5 minutes)
            file_age = time.time() - os.path.getmtime(self.auth_file_path)
            if file_age > 300:  # 5 minutes
                logger.debug("Auth file is too old")
                return False
                
            with open(self.auth_file_path, 'r') as f:
                auth_data = json.load(f)
                is_valid = ('access_token' in auth_data and 
                           auth_data.get('service') == 'fyers_data' and
                           auth_data.get('timestamp'))
                
                if is_valid:
                    logger.debug("Valid auth file found")
                return is_valid
                
        except Exception as e:
            logger.error(f"Error checking auth file: {e}")
            return False
    
    def load_auth_data(self):
        """Load authentication data from file"""
        try:
            with open(self.auth_file_path, 'r') as f:
                auth_data = json.load(f)
                logger.info("Loaded authentication data from file")
                return auth_data
        except Exception as e:
            logger.error(f"Error loading auth data: {e}")
            return None

# WebSocket event handlers
@sio.event
def connect(sid, environ):
    logger.info(f"Client connected: {sid}")
    clients[sid] = {
        'subscriptions': set(),
        'connected_at': time.time(),
        'last_ping': time.time()
    }
    
    # Send connection confirmation
    sio.emit('connected', {
        'status': 'connected',
        'server_time': time.time(),
        'fyers_status': 'connected' if fyers else 'disconnected'
    }, room=sid)

@sio.event
def disconnect(sid):
    logger.info(f"Client disconnected: {sid}")
    if sid in clients:
        # Clean up subscriptions
        for symbol in clients[sid]['subscriptions']:
            if symbol in symbol_to_clients:
                symbol_to_clients[symbol].discard(sid)
                # If no more clients for this symbol, unsubscribe from Fyers
                if not symbol_to_clients[symbol]:
                    del symbol_to_clients[symbol]
                    if fyers and hasattr(fyers, 'unsubscribe'):
                        try:
                            fyers.unsubscribe(symbol=[symbol])
                            logger.debug(f"Auto-unsubscribed from {symbol}")
                        except Exception as e:
                            logger.error(f"Failed to auto-unsubscribe from {symbol}: {e}")
        
        del clients[sid]

@sio.event
def ping(sid, data):
    """Handle ping requests from clients"""
    if sid in clients:
        clients[sid]['last_ping'] = time.time()
        sio.emit('pong', {
            'server_time': time.time(),
            'client_time': data.get('timestamp', time.time())
        }, room=sid)

@sio.event
def subscribe(sid, data):
    """Handle subscription requests from clients"""
    if sid not in clients:
        logger.warning(f"Unknown client {sid} trying to subscribe")
        sio.emit('error', {'message': 'Client not registered'}, room=sid)
        return
    
    symbols = data.get('symbols', [])
    if not isinstance(symbols, list):
        symbols = [symbols]
    
    logger.info(f"Client {sid} subscribing to {len(symbols)} symbols: {symbols}")
    
    subscribed_symbols = []
    failed_symbols = []
    
    for symbol in symbols:
        try:
            if symbol not in symbol_to_clients:
                symbol_to_clients[symbol] = set()
            
            symbol_to_clients[symbol].add(sid)
            clients[sid]['subscriptions'].add(symbol)
            
            # Subscribe to Fyers WebSocket if available and not already subscribed
            if fyers and hasattr(fyers, 'subscribe'):
                if len(symbol_to_clients[symbol]) == 1:  # First subscriber for this symbol
                    fyers.subscribe(symbol=[symbol], data_type="SymbolUpdate")
                    logger.debug(f"Subscribed to Fyers symbol: {symbol}")
                
            subscribed_symbols.append(symbol)
            
        except Exception as e:
            logger.error(f"Failed to subscribe to {symbol}: {e}")
            failed_symbols.append(symbol)
    
    # Send confirmation
    sio.emit('subscription_response', {
        'success': True,
        'subscribed': subscribed_symbols,
        'failed': failed_symbols,
        'total_subscriptions': len(clients[sid]['subscriptions'])
    }, room=sid)

@sio.event
def unsubscribe(sid, data):
    """Handle unsubscription requests from clients"""
    if sid not in clients:
        return
    
    symbols = data.get('symbols', [])
    if not isinstance(symbols, list):
        symbols = [symbols]
    
    logger.info(f"Client {sid} unsubscribing from {len(symbols)} symbols")
    
    unsubscribed_symbols = []
    
    for symbol in symbols:
        try:
            if symbol in symbol_to_clients:
                symbol_to_clients[symbol].discard(sid)
                
                # If no more clients for this symbol, unsubscribe from Fyers
                if not symbol_to_clients[symbol]:
                    del symbol_to_clients[symbol]
                    
                    if fyers and hasattr(fyers, 'unsubscribe'):
                        fyers.unsubscribe(symbol=[symbol])
                        logger.debug(f"Unsubscribed from Fyers symbol: {symbol}")
            
            clients[sid]['subscriptions'].discard(symbol)
            unsubscribed_symbols.append(symbol)
            
        except Exception as e:
            logger.error(f"Failed to unsubscribe from {symbol}: {e}")
    
    # Send confirmation
    sio.emit('unsubscription_response', {
        'success': True,
        'unsubscribed': unsubscribed_symbols,
        'remaining_subscriptions': len(clients[sid]['subscriptions'])
    }, room=sid)

@sio.event
def auth_token_ready(sid, data):
    """Handle auth token ready event from web interface"""
    global access_token, fyers_client, fyers
    
    logger.info("Received auth token from web interface")
    access_token = data.get('access_token')
    auth_code = data.get('auth_code')
    
    if access_token:
        try:
            # Initialize Fyers client
            token_only = access_token.replace(f"{client_id}:", "") if access_token.startswith(client_id) else access_token
            
            fyers_client = fyersModel.FyersModel(
                client_id=client_id,
                token=token_only,
                log_path=""
            )
            
            # Test the client
            profile_response = fyers_client.get_profile()
            if profile_response.get('s') == 'ok':
                logger.info("Fyers client initialized and verified successfully")
            else:
                logger.warning(f"Fyers client warning: {profile_response}")
            
            # Initialize WebSocket
            full_access_token = access_token if access_token.startswith(client_id) else f"{client_id}:{access_token}"
            
            fyers = data_ws.FyersDataSocket(
                access_token=full_access_token,
                log_path="",
                litemode=False,
                write_to_file=False,
                reconnect=True,
                on_connect=onopen,
                on_close=onclose,
                on_error=onerror,
                on_message=onmessage
            )
            
            logger.info("Fyers client and WebSocket initialized successfully")
            auth_completed.set()
            
            # Notify all connected clients
            sio.emit('fyers_authenticated', {
                'status': 'authenticated',
                'timestamp': time.time()
            })
            
        except Exception as e:
            logger.error(f"Error initializing Fyers: {e}")
            sio.emit('fyers_auth_error', {
                'error': str(e),
                'timestamp': time.time()
            })

def onmessage(message):
    """Handle incoming Fyers WebSocket messages"""
    try:
        if isinstance(message, dict) and message.get('type') == 'sub':
            logger.debug(f"Subscription confirmation: {message}")
            return
        
        if isinstance(message, dict) and 'symbol' in message:
            symbol = message['symbol']
            
            # Add timestamp if not present
            current_time = int(time.time())
            ist_time = datetime.datetime.fromtimestamp(current_time, INDIA_TZ)
            
            # Create standardized market data
            simplified_data = {
                'symbol': symbol,
                'ltp': float(message.get('ltp', 0)),
                'change': float(message.get('ch', 0)),
                'changePercent': float(message.get('chp', 0)),
                'volume': int(message.get('vol_traded_today', 0)),
                'open': float(message.get('open_price', 0)),
                'high': float(message.get('high_price', 0)),
                'low': float(message.get('low_price', 0)),
                'close': float(message.get('prev_close_price', 0)),
                'bid': float(message.get('bid_price', 0)),
                'ask': float(message.get('ask_price', 0)),
                'timestamp': message.get('last_traded_time', current_time),
                'formatted_time': ist_time.strftime("%H:%M:%S"),
                'server_time': current_time
            }
            
            # Store historical data
            if symbol not in historical_data:
                historical_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)
            
            historical_data[symbol].append({
                'timestamp': current_time,
                'ltp': simplified_data['ltp'],
                'volume': simplified_data['volume'],
                'high': simplified_data['high'],
                'low': simplified_data['low']
            })
            
            # Send data to subscribed clients
            if symbol in symbol_to_clients:
                disconnected_clients = set()
                
                for sid in list(symbol_to_clients[symbol]):
                    try:
                        sio.emit('marketData', simplified_data, room=sid)
                    except Exception as e:
                        logger.error(f"Error sending data to client {sid}: {e}")
                        disconnected_clients.add(sid)
                
                # Clean up disconnected clients
                for sid in disconnected_clients:
                    symbol_to_clients[symbol].discard(sid)
                    if sid in clients:
                        del clients[sid]
                
                # Remove symbol if no clients left
                if not symbol_to_clients[symbol]:
                    del symbol_to_clients[symbol]
                    
    except Exception as e:
        logger.error(f"Error processing message: {e}")
        logger.debug(f"Problematic message: {message}")

def onopen():
    logger.info("Fyers WebSocket connected successfully")
    sio.emit('fyersConnected', {
        'status': 'connected',
        'timestamp': time.time()
    })

def onerror(error):
    logger.error(f"Fyers WebSocket Error: {error}")
    sio.emit('fyersError', {
        'message': str(error),
        'timestamp': time.time()
    })

def onclose(message):
    logger.info(f"Fyers WebSocket Connection closed: {message}")
    sio.emit('fyersDisconnected', {
        'message': str(message),
        'timestamp': time.time()
    })

def cleanup_disconnected_clients():
    """Periodic cleanup of disconnected clients"""
    current_time = time.time()
    disconnected_clients = []
    
    for sid, client_data in clients.items():
        # Consider client disconnected if no ping for 60 seconds
        if current_time - client_data['last_ping'] > 60:
            disconnected_clients.append(sid)
    
    for sid in disconnected_clients:
        logger.info(f"Cleaning up inactive client: {sid}")
        disconnect(sid)

def main_process():
    """Main automated process"""
    global fyers, fyers_client, running, access_token
    
    try:
        # Create data directory
        os.makedirs('data', exist_ok=True)
        
        # Start automated authentication
        auth_handler = AutomatedAuthHandler()
        auth_data = auth_handler.wait_for_auth_completion()
        
        if not auth_data:
            logger.error("Authentication failed or timed out")
            return
            
        access_token = auth_data.get('access_token')
        if not access_token:
            logger.error("No access token received")
            return
            
        # Initialize Fyers client
        token_only = access_token.replace(f"{client_id}:", "") if access_token.startswith(client_id) else access_token
        
        fyers_client = fyersModel.FyersModel(
            client_id=client_id,
            token=token_only,
            log_path=""
        )
        
        # Verify client works
        try:
            profile = fyers_client.get_profile()
            if profile.get('s') == 'ok':
                logger.info("Fyers API client verified successfully")
            else:
                logger.warning(f"Fyers API client verification warning: {profile}")
        except Exception as e:
            logger.error(f"Fyers API client verification failed: {e}")
        
        # Initialize WebSocket
        full_access_token = access_token if access_token.startswith(client_id) else f"{client_id}:{access_token}"
        
        fyers = data_ws.FyersDataSocket(
            access_token=full_access_token,
            log_path="",
            litemode=False,
            write_to_file=False,
            reconnect=True,
            on_connect=onopen,
            on_close=onclose,
            on_error=onerror,
            on_message=onmessage
        )
        
        logger.info("Starting Fyers WebSocket connection...")
        fyers.connect()
        
        # Start periodic cleanup
        def periodic_cleanup():
            while running:
                time.sleep(30)  # Clean up every 30 seconds
                try:
                    cleanup_disconnected_clients()
                except Exception as e:
                    logger.error(f"Error in periodic cleanup: {e}")
        
        cleanup_thread = threading.Thread(target=periodic_cleanup, daemon=True)
        cleanup_thread.start()
        
        logger.info("Starting Socket.IO server on port 5001...")
        eventlet.wsgi.server(eventlet.listen(('0.0.0.0', 5001)), app)
        
    except Exception as e:
        logger.error(f"Error in main process: {e}")
        import traceback
        traceback.print_exc()

def main():
    global running
    
    logger.info("=" * 60)
    logger.info("Starting Automated Fyers Data Server")
    logger.info("Authentication will be handled automatically through web interface")
    logger.info(f"Server will start on port 5001")
    logger.info(f"Redirect URI: {redirect_uri}")
    logger.info("=" * 60)
    
    try:
        # Start main process in eventlet
        eventlet.spawn(main_process)
        
        # Keep main thread alive
        while running:
            time.sleep(1)
            
    except KeyboardInterrupt:
        logger.info("Shutdown requested by user")
        running = False
    except Exception as e:
        logger.error(f"Fatal error in main: {e}")
        import traceback
        traceback.print_exc()
        running = False

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logger.info("Shutting down gracefully...")
        running = False
    except Exception as e:
        logger.error(f"Fatal error: {e}")
        import traceback
        traceback.print_exc()
    finally:
        logger.info("Server shutdown complete")


================================================================================
FILE: apps/backend/fyers_data_automated_fixed.py
PURPOSE: Fixed version of automated Fyers data implementation
================================================================================

import eventlet
eventlet.monkey_patch()

import socketio
import json
import sys
import time
import datetime
import pytz
import threading
import logging
import requests
import numpy as np
import os
import webbrowser
from collections import deque
from fyers_apiv3 import fyersModel
from fyers_apiv3.FyersWebsocket import data_ws

# Fix Windows Unicode encoding issue
if sys.platform.startswith('win'):
    import codecs
    sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'strict')
    sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'strict')

# Enhanced logging with UTF-8 encoding
class UTFFormatter(logging.Formatter):
    def format(self, record):
        # Replace emojis with simple text for Windows compatibility
        msg = super().format(record)
        emoji_replacements = {
            'ðŸš€': '[START]',
            'ðŸ“Œ': '[PIN]',
            'ðŸ”': '[LOCK]',
            'ðŸŒ': '[WEB]',
            'âœ…': '[OK]',
            'âŒ': '[ERROR]',
            'ðŸ”‘': '[KEY]',
            'â³': '[WAIT]',
            'ðŸ›‘': '[STOP]',
            'ðŸ“„': '[FILE]',
            'ðŸŽ‰': '[SUCCESS]'
        }
        
        for emoji, replacement in emoji_replacements.items():
            msg = msg.replace(emoji, replacement)
        
        return msg

# Setup logging with custom formatter
log_formatter = UTFFormatter('%(asctime)s - %(levelname)s - %(message)s')

file_handler = logging.FileHandler(
    f'fyers_data_{datetime.datetime.now().strftime("%Y%m%d")}.log',
    encoding='utf-8'
)
file_handler.setFormatter(log_formatter)

console_handler = logging.StreamHandler()
console_handler.setFormatter(log_formatter)

logger = logging.getLogger("AutomatedFyersServer")
logger.setLevel(logging.INFO)
logger.addHandler(file_handler)
logger.addHandler(console_handler)

# Socket.IO setup
sio = socketio.Server(cors_allowed_origins='*', async_mode='eventlet')
app = socketio.WSGIApp(sio)

# Configuration
client_id = "150HUKJSWG-100"
secret_key = "18YYNXCAS7"
redirect_uri = "https://daksphere.com"
response_type = "code"
grant_type = "authorization_code"

# Global variables
clients = {}
symbol_to_clients = {}
running = True
historical_data = {}
ohlc_data = {}
MAX_HISTORY_POINTS = 10000
INDIA_TZ = pytz.timezone('Asia/Kolkata')
fyers = None
fyers_client = None
auth_completed = threading.Event()
access_token = None

class AutomatedAuthHandler:
    def __init__(self):
        self.auth_file_path = os.path.join('data', 'fyers_data_auth.json')
        self.polling_interval = 2  # seconds
        self.max_wait_time = 300  # 5 minutes
        
    def wait_for_auth_completion(self):
        """Wait for authentication to be completed via web interface"""
        logger.info("[LOCK] Starting automated authentication process...")
        
        # Generate auth URL and open browser
        auth_url = self.generate_auth_url()
        logger.info(f"[WEB] Opening browser with auth URL: {auth_url}")
        
        try:
            webbrowser.open(auth_url)
            logger.info("[OK] Browser opened successfully")
        except Exception as e:
            logger.error(f"[ERROR] Failed to open browser: {e}")
            logger.info(f"Please manually open: {auth_url}")
        
        # Poll for auth completion
        start_time = time.time()
        while not auth_completed.is_set():
            if time.time() - start_time > self.max_wait_time:
                logger.error("[ERROR] Authentication timeout. Please try again.")
                return None
                
            if self.check_auth_file():
                logger.info("[OK] Authentication completed!")
                return self.load_auth_data()
                
            time.sleep(self.polling_interval)
            logger.debug("[WAIT] Waiting for authentication...")
            
        return None
    
    def generate_auth_url(self):
        """Generate Fyers auth URL"""
        return f"https://api-t2.fyers.in/api/v3/generate-authcode?client_id={client_id}&redirect_uri={redirect_uri}&response_type=code&state=fyers_oauth"
    
    def check_auth_file(self):
        """Check if auth file exists and is recent"""
        try:
            if not os.path.exists(self.auth_file_path):
                return False
                
            # Check if file is recent (within last 5 minutes)
            file_age = time.time() - os.path.getmtime(self.auth_file_path)
            if file_age > 300:  # 5 minutes
                return False
                
            with open(self.auth_file_path, 'r') as f:
                auth_data = json.load(f)
                return 'access_token' in auth_data and auth_data.get('service') == 'fyers_data'
                
        except Exception as e:
            logger.error(f"Error checking auth file: {e}")
            return False
    
    def load_auth_data(self):
        """Load authentication data from file"""
        try:
            with open(self.auth_file_path, 'r') as f:
                auth_data = json.load(f)
                logger.info("[FILE] Loaded authentication data from file")
                return auth_data
        except Exception as e:
            logger.error(f"Error loading auth data: {e}")
            return None

# WebSocket event handlers
@sio.event
def connect(sid, environ):
    logger.info(f"Client connected: {sid}")
    clients[sid] = {'subscriptions': set()}

@sio.event
def disconnect(sid):
    logger.info(f"Client disconnected: {sid}")
    if sid in clients:
        for symbol in clients[sid]['subscriptions']:
            if symbol in symbol_to_clients:
                symbol_to_clients[symbol].discard(sid)
        del clients[sid]

@sio.event
def subscribe(sid, data):
    """Handle subscription requests from clients"""
    if sid not in clients:
        logger.warning(f"Unknown client {sid} trying to subscribe")
        return
    
    symbols = data.get('symbols', [])
    logger.info(f"Client {sid} subscribing to {len(symbols)} symbols")
    
    for symbol in symbols:
        if symbol not in symbol_to_clients:
            symbol_to_clients[symbol] = set()
        symbol_to_clients[symbol].add(sid)
        clients[sid]['subscriptions'].add(symbol)
        
        # Subscribe to Fyers WebSocket if available
        if fyers and hasattr(fyers, 'subscribe'):
            try:
                fyers.subscribe(symbol=[symbol], data_type="SymbolUpdate")
                logger.info(f"Subscribed to Fyers symbol: {symbol}")
            except Exception as e:
                logger.error(f"Failed to subscribe to {symbol}: {e}")

@sio.event
def unsubscribe(sid, data):
    """Handle unsubscription requests from clients"""
    if sid not in clients:
        return
    
    symbols = data.get('symbols', [])
    logger.info(f"Client {sid} unsubscribing from {len(symbols)} symbols")
    
    for symbol in symbols:
        if symbol in symbol_to_clients:
            symbol_to_clients[symbol].discard(sid)
            if not symbol_to_clients[symbol]:
                del symbol_to_clients[symbol]
                
                # Unsubscribe from Fyers WebSocket if no clients left
                if fyers and hasattr(fyers, 'unsubscribe'):
                    try:
                        fyers.unsubscribe(symbol=[symbol])
                        logger.info(f"Unsubscribed from Fyers symbol: {symbol}")
                    except Exception as e:
                        logger.error(f"Failed to unsubscribe from {symbol}: {e}")
        
        clients[sid]['subscriptions'].discard(symbol)

@sio.event
def auth_token_ready(sid, data):
    """Handle auth token ready event from web interface"""
    global access_token, fyers_client, fyers
    
    logger.info("[KEY] Received auth token from web interface")
    access_token = data.get('access_token')
    auth_code = data.get('auth_code')
    
    if access_token:
        try:
            # Initialize Fyers client
            fyers_client = fyersModel.FyersModel(
                client_id=client_id,
                token=access_token.replace(f"{client_id}:", ""),
                log_path=""
            )
            
            # Initialize WebSocket
            fyers = data_ws.FyersDataSocket(
                access_token=access_token,
                log_path="",
                litemode=False,
                write_to_file=False,
                reconnect=True,
                on_connect=onopen,
                on_close=onclose,
                on_error=onerror,
                on_message=onmessage
            )
            
            logger.info("[OK] Fyers client and WebSocket initialized")
            auth_completed.set()
            
        except Exception as e:
            logger.error(f"[ERROR] Error initializing Fyers: {e}")

def onmessage(message):
    """Handle incoming Fyers WebSocket messages"""
    logger.debug(f"Response: {message}")
    
    if isinstance(message, dict) and message.get('type') == 'sub':
        logger.info(f"Subscription confirmation: {message}")
        return
    
    if isinstance(message, dict) and 'symbol' in message:
        symbol = message['symbol']
        
        # Add timestamp if not present
        current_time = int(time.time())
        ist_time = datetime.datetime.fromtimestamp(current_time, INDIA_TZ)
        
        simplified_data = {
            'symbol': symbol,
            'ltp': message.get('ltp', 0),
            'change': message.get('ch', 0),
            'changePercent': message.get('chp', 0),
            'volume': message.get('vol_traded_today', 0),
            'open': message.get('open_price', 0),
            'high': message.get('high_price', 0),
            'low': message.get('low_price', 0),
            'close': message.get('prev_close_price', 0),
            'bid': message.get('bid_price', 0),
            'ask': message.get('ask_price', 0),
            'timestamp': message.get('last_traded_time', current_time),
            'formatted_time': ist_time.strftime("%H:%M:%S")
        }
        
        # Store historical data
        if symbol not in historical_data:
            historical_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)
        
        historical_data[symbol].append({
            'timestamp': current_time,
            'ltp': simplified_data['ltp'],
            'volume': simplified_data['volume']
        })
        
        # Send data to subscribed clients
        if symbol in symbol_to_clients:
            for sid in list(symbol_to_clients[symbol]):  # Create copy to avoid modification during iteration
                try:
                    sio.emit('marketData', simplified_data, room=sid)
                except Exception as e:
                    logger.error(f"Error sending data to client {sid}: {e}")
                    # Remove disconnected client
                    symbol_to_clients[symbol].discard(sid)
                    if sid in clients:
                        del clients[sid]

def onopen():
    logger.info("[OK] Fyers WebSocket connected")
    sio.emit('fyersConnected', {'status': 'connected'})

def onerror(error):
    logger.error(f"[ERROR] Fyers WebSocket Error: {error}")
    sio.emit('error', {'message': str(error)})

def onclose(message):
    logger.info(f"[ERROR] Fyers WebSocket Connection closed: {message}")
    sio.emit('fyersDisconnected', {'message': str(message)})

def main_process():
    """Main automated process"""
    global fyers, fyers_client, running, access_token
    
    try:
        # Create data directory
        os.makedirs('data', exist_ok=True)
        
        # Start automated authentication
        auth_handler = AutomatedAuthHandler()
        auth_data = auth_handler.wait_for_auth_completion()
        
        if not auth_data:
            logger.error("[ERROR] Authentication failed or timed out")
            return
            
        access_token = auth_data.get('access_token')
        if not access_token:
            logger.error("[ERROR] No access token received")
            return
            
        # Initialize Fyers client
        token_only = access_token.replace(f"{client_id}:", "") if access_token.startswith(client_id) else access_token
        
        fyers_client = fyersModel.FyersModel(
            client_id=client_id,
            token=token_only,
            log_path=""
        )
        
        # Initialize WebSocket
        fyers = data_ws.FyersDataSocket(
            access_token=access_token if access_token.startswith(client_id) else f"{client_id}:{access_token}",
            log_path="",
            litemode=False,
            write_to_file=False,
            reconnect=True,
            on_connect=onopen,
            on_close=onclose,
            on_error=onerror,
            on_message=onmessage
        )
        
        logger.info("[START] Starting Fyers WebSocket connection...")
        fyers.connect()
        
        logger.info("[WEB] Starting Socket.IO server on port 5001...")
        eventlet.wsgi.server(eventlet.listen(('0.0.0.0', 5001)), app)
        
    except Exception as e:
        logger.error(f"[ERROR] Error in main process: {e}")
        import traceback
        traceback.print_exc()

def main():
    global running
    
    logger.info("[START] Starting Automated Fyers Data Server...")
    logger.info("[PIN] Authentication will be handled automatically through web interface")
    
    try:
        eventlet.spawn(main_process)
        
        while running:
            time.sleep(1)
    except KeyboardInterrupt:
        logger.info("[STOP] Shutting down...")
        running = False

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logger.info("[STOP] Shutting down...")
        running = False
    except Exception as e:
        logger.error(f"[ERROR] Fatal error: {e}")
        import traceback
        traceback.print_exc()


################################################################################
SECTION 2: BACKEND NESTJS MODULES AND SERVICES
################################################################################

================================================================================
FILE: apps/backend/src/app.module.ts
PURPOSE: Main application module configuration
================================================================================

import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { DatabaseModule } from './database/database.module';
// import { MarketDataModule } from './market-data/market-data.module';
import { LiveMarketModule } from './live-market/live-market.module';
import { StockModule } from './stock/stocks.module';
import { WatchlistModule } from './watchlist/watchlist.module';
import { AuthModule } from './auth/auth.module'; // Add this import

@Module({
  imports: [
    DatabaseModule,
    // MarketDataModule,
    LiveMarketModule,
    StockModule,
    WatchlistModule,
    AuthModule, // Add AuthModule here
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}


================================================================================
FILE: apps/backend/src/auth/auth.module.ts
PURPOSE: Authentication module configuration
================================================================================

import { Module } from '@nestjs/common';
import { FyersAuthController } from './fyers-auth.controller';
import { FyersAuthService } from '../market-data/services/fyers-auth.service';

@Module({
  controllers: [FyersAuthController],
  providers: [FyersAuthService],
  exports: [FyersAuthService],
})
export class AuthModule {}


================================================================================
FILE: apps/backend/src/auth/fyers-auth.controller.ts
PURPOSE: Fyers authentication controller
================================================================================

import { Controller, Post, Body, Get, HttpException, HttpStatus } from '@nestjs/common';
import { FyersAuthService } from '../market-data/services/fyers-auth.service';

// Local interfaces to avoid export issues
interface AuthStatus {
  authenticated: boolean;
  token_valid: boolean;
  expires_at: string | null;
  services_notified: string[];
}

interface TokenResponse {
  access_token: string;
  expires_at: string;
}

interface NotifyRequest {
  service: string;
  token: string;
  auth_code: string;
}

interface TokenRequest {
  code: string;
}

interface AuthUrlResponse {
  auth_url: string;
}

interface TokenValidationResponse {
  token: string | null;
  valid: boolean;
  error?: string;
}

@Controller('auth/fyers')
export class FyersAuthController {
  constructor(private readonly fyersAuthService: FyersAuthService) {}

  @Post('token')
  async generateToken(@Body() body: TokenRequest): Promise<TokenResponse> {
    try {
      if (!body.code) {
        throw new HttpException('Authorization code is required', HttpStatus.BAD_REQUEST);
      }

      const result = await this.fyersAuthService.generateTokenFromCode(body.code);
      return result;
    } catch (error) {
      throw new HttpException(
        error.message || 'Token generation failed', 
        HttpStatus.BAD_REQUEST
      );
    }
  }

  @Post('notify')
  async notifyPythonScript(@Body() body: NotifyRequest): Promise<{ success: boolean; message: string }> {
    try {
      if (!body.service || !body.token || !body.auth_code) {
        throw new HttpException(
          'Service name, token, and auth code are required', 
          HttpStatus.BAD_REQUEST
        );
      }

      await this.fyersAuthService.notifyPythonService(
        body.service, 
        body.token, 
        body.auth_code
      );
      
      return { 
        success: true, 
        message: `Successfully notified ${body.service}` 
      };
    } catch (error) {
      throw new HttpException(
        error.message || 'Failed to notify Python service', 
        HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }

  @Get('status')
  async getAuthStatus(): Promise<AuthStatus> {
    try {
      return await this.fyersAuthService.getAuthStatus();
    } catch (error) {
      throw new HttpException(
        'Failed to get auth status', 
        HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }

  @Get('token')
  async getCurrentToken(): Promise<TokenValidationResponse> {
    try {
      const token = await this.fyersAuthService.getCurrentAccessToken();
      
      // Fix: Convert null to undefined for validateToken method
      const valid = await this.fyersAuthService.validateToken(token || undefined);
      
      return { 
        token: token ? token.substring(0, 20) + '...' : null, // Mask token for security
        valid 
      };
    } catch (error) {
      return { 
        token: null, 
        valid: false, 
        error: error.message 
      };
    }
  }

  @Post('start')
  async startAuthProcess(): Promise<AuthUrlResponse> {
    try {
      const authUrl = await this.fyersAuthService.startAuthProcess();
      return { auth_url: authUrl };
    } catch (error) {
      throw new HttpException(
        error.message || 'Failed to start authentication process', 
        HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }

  @Post('refresh')
  async refreshToken(): Promise<{ success: boolean; message: string }> {
    try {
      const success = await this.fyersAuthService.refreshTokenIfNeeded();
      
      if (success) {
        return { 
          success: true, 
          message: 'Token is still valid' 
        };
      } else {
        return { 
          success: false, 
          message: 'Token refresh required - please re-authenticate' 
        };
      }
    } catch (error) {
      throw new HttpException(
        'Token refresh failed', 
        HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }

  @Post('validate')
  async validateToken(@Body() body: { token?: string }): Promise<{ valid: boolean; message: string }> {
    try {
      const valid = await this.fyersAuthService.validateToken(body.token);
      
      return {
        valid,
        message: valid ? 'Token is valid' : 'Token is invalid or expired'
      };
    } catch (error) {
      throw new HttpException(
        'Token validation failed', 
        HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }
}


================================================================================
FILE: apps/backend/src/market-data/services/fyers-auth.service.ts
PURPOSE: Fyers authentication service implementation
================================================================================

import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import * as fs from 'fs';
import * as path from 'path';
import axios from 'axios';
import { io as Client } from 'socket.io-client';

interface TokenData {
  access_token: string;
  expiry: string;
  auth_code: string;
  created_at: string;
  is_valid: boolean;
  last_validated: string;
  session_date: string;
}

interface AuthStatus {
  authenticated: boolean;
  token_valid: boolean;
  expires_at: string | null;
  services_notified: string[];
  session_date?: string;
  auto_refresh_enabled?: boolean;
  next_refresh_check?: string;
}

interface TokenResponse {
  access_token: string;
  expires_at: string;
  reused: boolean;
}

@Injectable()
export class FyersAuthService {
  private readonly logger = new Logger(FyersAuthService.name);
  private clientId: string;
  private secretKey: string;
  private redirectUri: string;
  private tokenPath: string;
  private authStatusPath: string;

  // Updated API endpoints to use T1
  private readonly BASE_URL = 'https://api-t1.fyers.in/api/v3';
  private readonly AUTH_URL = `${this.BASE_URL}/generate-authcode`;
  private readonly TOKEN_URL = `${this.BASE_URL}/validate-authcode`;

  constructor() {
    this.clientId = process.env.FYERS_CLIENT_ID || '150HUKJSWG-100';
    this.secretKey = process.env.FYERS_SECRET_ID || '18YYNXCAS7';
    this.redirectUri = process.env.FYERS_REDIRECT_URI || 'https://raghavjaiswal709.github.io/DAKSphere_redirect/';
    
    const dataDir = path.join(process.cwd(), 'data');
    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
    }
    
    this.tokenPath = path.join(dataDir, 'fyers_token.json');
    this.authStatusPath = path.join(dataDir, 'auth_status.json');
    
    this.logger.log(`Initialized Fyers Auth Service with redirect URI: ${this.redirectUri}`);
    
    // Check existing token on startup
    this.validateExistingToken();
  }

  // ===== TOKEN MANAGEMENT METHODS =====

  private saveTokenData(tokenData: TokenData): void {
    try {
      fs.writeFileSync(this.tokenPath, JSON.stringify(tokenData, null, 2));
      this.logger.debug('Token data saved successfully');
    } catch (error) {
      this.logger.error('Error saving token data:', error.message);
    }
  }

  private calculateTokenExpiry(): Date {
    const now = new Date();
    // Fyers tokens expire at 11:59 PM IST
    const expiryDate = new Date(now);
    expiryDate.setHours(23, 59, 0, 0); // Set to 11:59 PM
    
    // If current time is after market hours (after 4 PM), set expiry to next day
    if (now.getHours() >= 16) {
      expiryDate.setDate(expiryDate.getDate() + 1);
    }
    
    return expiryDate;
  }

  async getValidTokenOrNull(): Promise<string | null> {
    try {
      if (!fs.existsSync(this.tokenPath)) {
        this.logger.debug('No token file exists');
        return null;
      }

      const tokenData: TokenData = JSON.parse(fs.readFileSync(this.tokenPath, 'utf8'));
      
      // Check if token is for current trading session
      const currentDate = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
      if (tokenData.session_date !== currentDate) {
        this.logger.log(`Token is for different session. Current: ${currentDate}, Token: ${tokenData.session_date}`);
        return null;
      }

      // Check if token has expired
      const expiryDate = new Date(tokenData.expiry);
      const now = new Date();
      
      if (expiryDate > now && tokenData.is_valid) {
        const fullToken = `${this.clientId}:${tokenData.access_token}`;
        this.logger.log(`Valid token found, expires in ${Math.round((expiryDate.getTime() - now.getTime()) / (1000 * 60))} minutes`);
        
        // Update last validated time
        tokenData.last_validated = new Date().toISOString();
        this.saveTokenData(tokenData);
        
        return fullToken;
      } else {
        this.logger.warn('Stored token has expired or is invalid');
        await this.markTokenAsInvalid();
        return null;
      }
    } catch (error) {
      this.logger.error('Error checking existing token:', error.message);
      return null;
    }
  }

  async validateExistingToken(): Promise<boolean> {
    try {
      const token = await this.getValidTokenOrNull();
      if (!token) {
        return false;
      }

      this.logger.log('Valid token found and validated');
      return true;
    } catch (error) {
      this.logger.error('Token validation failed:', error.message);
      return false;
    }
  }

  private async markTokenAsInvalid(): Promise<void> {
    try {
      if (fs.existsSync(this.tokenPath)) {
        const tokenData: TokenData = JSON.parse(fs.readFileSync(this.tokenPath, 'utf8'));
        tokenData.is_valid = false;
        tokenData.last_validated = new Date().toISOString();
        this.saveTokenData(tokenData);
      }
      
      await this.updateAuthStatus({
        authenticated: false,
        token_valid: false,
        expires_at: null,
        services_notified: [],
        session_date: new Date().toISOString().split('T')[0],
        auto_refresh_enabled: true,
        next_refresh_check: new Date(Date.now() + 300000).toISOString() // 5 minutes
      });
    } catch (error) {
      this.logger.error('Error marking token as invalid:', error.message);
    }
  }

  private async updateAuthStatus(status: AuthStatus): Promise<void> {
    try {
      fs.writeFileSync(this.authStatusPath, JSON.stringify(status, null, 2));
      this.logger.debug('Auth status updated');
    } catch (error) {
      this.logger.error('Error updating auth status:', error.message);
    }
  }

  // ===== AUTHENTICATION URL GENERATION =====

  async generateAuthUrl(): Promise<string> {
    try {
      // Use proper URL encoding for redirect URI
      const encodedRedirectUri = encodeURIComponent(this.redirectUri);
      const state = 'None'; // Standard state value for Fyers API
      
      const authUrl = `${this.AUTH_URL}?client_id=${this.clientId}&redirect_uri=${encodedRedirectUri}&response_type=code&state=${state}`;
      
      this.logger.log('Generated auth URL with correct V3 T1 endpoint');
      this.logger.debug(`Auth URL: ${authUrl}`);
      
      return authUrl;
    } catch (error) {
      this.logger.error('Error generating auth URL:', error.message);
      throw new Error(`Failed to generate auth URL: ${error.message}`);
    }
  }

  // ===== TOKEN GENERATION =====

  async generateTokenFromCode(authCode: string): Promise<TokenResponse> {
    try {
      // First check if we already have a valid token
      const existingToken = await this.getValidTokenOrNull();
      if (existingToken) {
        this.logger.log('Reusing existing valid token');
        const tokenData: TokenData = JSON.parse(fs.readFileSync(this.tokenPath, 'utf8'));
        return {
          access_token: existingToken,
          expires_at: tokenData.expiry,
          reused: true
        };
      }

      this.logger.log('Generating new access token from auth code');
      this.logger.debug(`Auth code received: ${authCode.substring(0, 20)}...`);
      
      // Correct app ID hash format for Fyers V3
      const appIdHash = `${this.clientId}:${this.secretKey}`;
      
      // Log the hash for debugging (without exposing the secret)
      this.logger.debug(`Using app ID: ${this.clientId}`);
      this.logger.debug(`App ID hash format: ${this.clientId}:***`);
      
      const requestData = {
        grant_type: 'authorization_code',
        appIdHash: appIdHash,
        code: authCode  // This should be the JWT token from auth_code parameter
      };
      
      this.logger.debug('Making token request to Fyers API');
      
      const response = await axios.post(this.TOKEN_URL, requestData, {
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        timeout: 60000
      });

      this.logger.debug('Fyers API response received');
      this.logger.debug(`Response status: ${response.status}`);
      this.logger.debug(`Response data: ${JSON.stringify(response.data)}`);

      if (response.data?.s !== 'ok') {
        this.logger.error('Fyers API returned error:', response.data);
        throw new Error(`Token generation failed: ${JSON.stringify(response.data)}`);
      }

      const accessToken = response.data.access_token;
      if (!accessToken) {
        throw new Error('No access token received from Fyers API');
      }

      const expiryDate = this.calculateTokenExpiry();
      const currentDate = new Date().toISOString().split('T')[0];

      const tokenData: TokenData = {
        access_token: accessToken,
        expiry: expiryDate.toISOString(),
        auth_code: authCode,
        created_at: new Date().toISOString(),
        is_valid: true,
        last_validated: new Date().toISOString(),
        session_date: currentDate
      };

      // Save token
      this.saveTokenData(tokenData);
      
      // Update auth status
      await this.updateAuthStatus({
        authenticated: true,
        token_valid: true,
        expires_at: expiryDate.toISOString(),
        services_notified: [],
        session_date: currentDate,
        auto_refresh_enabled: true,
        next_refresh_check: new Date(Date.now() + 3600000).toISOString()
      });

      this.logger.log('New access token generated and saved successfully');
      
      return {
        access_token: `${this.clientId}:${accessToken}`,
        expires_at: expiryDate.toISOString(),
        reused: false
      };

    } catch (error) {
      this.logger.error('Token generation error details:', {
        message: error.message,
        response: error.response?.data,
        status: error.response?.status,
        clientId: this.clientId,
        authCodePreview: authCode?.substring(0, 20) + '...'
      });
      
      throw new Error(`Failed to generate access token: ${error.response?.data?.message || error.message}`);
    }
  }

  // ===== TOKEN ACCESS METHODS =====

  async getCurrentAccessToken(): Promise<string | null> {
    return this.getValidTokenOrNull();
  }

  // ===== PYTHON SERVICE NOTIFICATION =====

  async notifyPythonService(serviceName: string, token: string, authCode: string): Promise<void> {
    try {
      this.logger.log(`Notifying Python service: ${serviceName}`);
      
      // Write auth data to service-specific file
      const serviceAuthPath = path.join(process.cwd(), 'data', `${serviceName}_auth.json`);
      const authData = {
        access_token: token,
        auth_code: authCode,
        client_id: this.clientId,
        timestamp: new Date().toISOString(),
        service: serviceName,
        expires_at: this.calculateExpiryTime()
      };
      
      fs.writeFileSync(serviceAuthPath, JSON.stringify(authData, null, 2));
      this.logger.debug(`Written auth data to: ${serviceAuthPath}`);
      
      // Try to notify via WebSocket if service is running
      await this.notifyViaWebSocket(serviceName, authData);
      
      // Update auth status
      const currentStatus = await this.getAuthStatus();
      if (!currentStatus.services_notified.includes(serviceName)) {
        currentStatus.services_notified.push(serviceName);
        await this.updateAuthStatus(currentStatus);
      }
      
      this.logger.log(`Successfully notified ${serviceName}`);
      
    } catch (error) {
      this.logger.error(`Failed to notify ${serviceName}:`, error.message);
      throw error;
    }
  }

  private calculateExpiryTime(): string {
    const now = new Date();
    const expiryDate = new Date(now);
    expiryDate.setHours(23, 59, 59, 999);
    
    if (now.getHours() > 15) {
      expiryDate.setDate(expiryDate.getDate() + 1);
    }
    
    return expiryDate.toISOString();
  }

  private async notifyViaWebSocket(serviceName: string, authData: any): Promise<void> {
    return new Promise((resolve) => {
      const ports = {
        'fyers_data': 5001,
        'multi_company_live_data': 5010,
        'new_fyers': 5010
      };
      
      const port = ports[serviceName];
      if (!port) {
        this.logger.warn(`Unknown service: ${serviceName}`);
        resolve();
        return;
      }
      
      const client = Client(`http://localhost:${port}`, {
        timeout: 15000, // Increased timeout
        reconnection: false,
        forceNew: true
      });
      
      const timeout = setTimeout(() => {
        this.logger.debug(`WebSocket notification timeout for ${serviceName}`);
        client.disconnect();
        resolve();
      }, 15000);
      
      client.on('connect', () => {
        this.logger.log(`Connected to ${serviceName} WebSocket on port ${port}`);
        client.emit('auth_token_ready', authData);
        clearTimeout(timeout);
        
        setTimeout(() => {
          client.disconnect();
          resolve();
        }, 1000);
      });
      
      client.on('connect_error', (error) => {
        this.logger.debug(`Could not connect to ${serviceName} WebSocket: ${error.message}`);
        clearTimeout(timeout);
        resolve();
      });
      
      client.on('error', (error) => {
        this.logger.debug(`WebSocket error for ${serviceName}: ${error.message}`);
        clearTimeout(timeout);
        client.disconnect();
        resolve();
      });
    });
  }

  // ===== STATUS AND MONITORING =====

  async getAuthStatus(): Promise<AuthStatus> {
    try {
      if (fs.existsSync(this.authStatusPath)) {
        const status = JSON.parse(fs.readFileSync(this.authStatusPath, 'utf8'));
        
        // Validate token is still valid
        const token = await this.getCurrentAccessToken();
        status.token_valid = !!token;
        status.authenticated = !!token;
        
        return status;
      }
    } catch (error) {
      this.logger.error('Error reading auth status:', error.message);
    }
    
    const currentDate = new Date().toISOString().split('T')[0];
    return {
      authenticated: false,
      token_valid: false,
      expires_at: null,
      services_notified: [],
      session_date: currentDate,
      auto_refresh_enabled: true,
      next_refresh_check: new Date(Date.now() + 300000).toISOString()
    };
  }

  async requiresAuthentication(): Promise<{ required: boolean; reason: string; token_status: string }> {
    try {
      const token = await this.getValidTokenOrNull();
      
      if (token) {
        const tokenData: TokenData = JSON.parse(fs.readFileSync(this.tokenPath, 'utf8'));
        const expiryDate = new Date(tokenData.expiry);
        const now = new Date();
        const hoursRemaining = Math.round((expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60));
        
        return {
          required: false,
          reason: `Valid token exists, expires in ${hoursRemaining} hours`,
          token_status: 'valid'
        };
      } else {
        return {
          required: true,
          reason: 'No valid token found or token expired',
          token_status: 'invalid'
        };
      }
    } catch (error) {
      return {
        required: true,
        reason: `Token check failed: ${error.message}`,
        token_status: 'error'
      };
    }
  }

  // ===== AUTH PROCESS =====

  async startAuthProcess(): Promise<string> {
    try {
      // Check if authentication is required
      const { required, reason } = await this.requiresAuthentication();
      
      if (!required) {
        this.logger.log(`Skipping authentication: ${reason}`);
        throw new Error(`Authentication not required: ${reason}`);
      }

      const authUrl = await this.generateAuthUrl();
      
      // Auto-open browser (optional - can be disabled in production)
      if (process.env.NODE_ENV !== 'production') {
        try {
          const { default: open } = await import('open');
          await open(authUrl);
          this.logger.log('Browser opened with auth URL');
        } catch (error) {
          this.logger.warn('Could not auto-open browser:', error.message);
        }
      }
      
      return authUrl;
    } catch (error) {
      this.logger.error('Failed to start auth process:', error.message);
      throw error;
    }
  }

  // ===== TOKEN VALIDATION =====

  async validateToken(token?: string): Promise<boolean> {
    try {
      const accessToken = token || await this.getCurrentAccessToken();
      if (!accessToken) {
        return false;
      }

      // Basic validation - check if token format is correct
      if (!accessToken.includes(':') || !accessToken.startsWith(this.clientId)) {
        this.logger.warn('Invalid token format');
        return false;
      }

      return true;
    } catch (error) {
      this.logger.error('Token validation error:', error.message);
      return false;
    }
  }

  async refreshTokenIfNeeded(): Promise<boolean> {
    try {
      const currentToken = await this.getCurrentAccessToken();
      if (!currentToken) {
        this.logger.warn('No valid token available for refresh');
        return false;
      }

      // Check if token expires soon (within 1 hour)
      const tokenData = JSON.parse(fs.readFileSync(this.tokenPath, 'utf8'));
      const expiryDate = new Date(tokenData.expiry);
      const now = new Date();
      const oneHour = 60 * 60 * 1000;

      if (expiryDate.getTime() - now.getTime() < oneHour) {
        this.logger.warn('Token expires soon, manual re-authentication required');
        return false;
      }

      return true;
    } catch (error) {
      this.logger.error('Token refresh check failed:', error.message);
      return false;
    }
  }

  // ===== SCHEDULED TASKS =====

  @Cron('0 */10 * * * *') // Every 10 minutes
  async checkTokenValidity(): Promise<void> {
    try {
      this.logger.debug('Checking token validity (auto-check)');
      
      const isValid = await this.validateExistingToken();
      if (!isValid) {
        this.logger.warn('Token invalid during auto-check');
        await this.markTokenAsInvalid();
      }
    } catch (error) {
      this.logger.error('Error in auto token check:', error.message);
    }
  }

  @Cron(CronExpression.EVERY_DAY_AT_MIDNIGHT) // Every day at midnight
  async midnightTokenCleanup(): Promise<void> {
    try {
      this.logger.log('Midnight token cleanup - clearing expired tokens');
      await this.markTokenAsInvalid();
      
      // Clear old token files
      if (fs.existsSync(this.tokenPath)) {
        fs.unlinkSync(this.tokenPath);
        this.logger.log('Old token file deleted');
      }
    } catch (error) {
      this.logger.error('Error in midnight cleanup:', error.message);
    }
  }
}


################################################################################
SECTION 3: FRONTEND API ROUTES
################################################################################

================================================================================
FILE: apps/frontend/app/api/auth/fyers/notify/route.ts
PURPOSE: Fyers notification API route
================================================================================

import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    console.log('Notify request:', body);
    
    const backendUrl = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5000';
    
    const response = await fetch(`${backendUrl}/auth/fyers/notify`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(body),
    });
    
    if (!response.ok) {
      const errorData = await response.text();
      console.error('Notify error:', errorData);
      throw new Error(`Failed to notify service: ${errorData}`);
    }
    
    const data = await response.json();
    console.log('Service notified successfully:', body.service);
    return NextResponse.json(data);
    
  } catch (error) {
    console.error('Notify service error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to notify Python service' },
      { status: 500 }
    );
  }
}


================================================================================
FILE: apps/frontend/app/api/auth/fyers/start/route.ts
PURPOSE: Fyers authentication start API route
================================================================================

import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    const backendUrl = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5000';
    
    const response = await fetch(`${backendUrl}/auth/fyers/start`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    });
    
    if (!response.ok) {
      throw new Error('Failed to start auth process');
    }
    
    const data = await response.json();
    return NextResponse.json(data);
    
  } catch (error) {
    console.error('Auth start error:', error);
    return NextResponse.json(
      { error: 'Failed to start authentication process' },
      { status: 500 }
    );
  }
}


================================================================================
FILE: apps/frontend/app/api/auth/fyers/status/route.ts
PURPOSE: Fyers authentication status API route
================================================================================

import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  try {
    const backendUrl = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5000';
    
    const response = await fetch(`${backendUrl}/auth/fyers/status`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    });
    
    if (!response.ok) {
      console.warn('Backend auth status check failed');
      // Return default status instead of error
      return NextResponse.json({
        authenticated: false,
        token_valid: false,
        expires_at: null,
        services_notified: []
      });
    }
    
    const data = await response.json();
    return NextResponse.json(data);
    
  } catch (error) {
    console.error('Auth status error:', error);
    // Return default status instead of error
    return NextResponse.json({
      authenticated: false,
      token_valid: false,
      expires_at: null,
      services_notified: []
    });
  }
}


================================================================================
FILE: apps/frontend/app/api/auth/fyers/token/route.ts
PURPOSE: Fyers token management API route
================================================================================

import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    const { code } = await request.json();
    
    if (!code) {
      return NextResponse.json(
        { error: 'Authorization code is required' },
        { status: 400 }
      );
    }

    console.log('Received auth code:', code);
    
    const backendUrl = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:5000';
    console.log('Backend URL:', backendUrl);
    
    const response = await fetch(`${backendUrl}/auth/fyers/token`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ code }),
    });
    
    console.log('Backend response status:', response.status);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('Backend error:', errorText);
      throw new Error(`Token generation failed: ${errorText}`);
    }
    
    const data = await response.json();
    console.log('Token generated successfully');
    return NextResponse.json(data);
    
  } catch (error) {
    console.error('Token generation error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to generate token' },
      { status: 500 }
    );
  }
}


################################################################################
SECTION 4: FRONTEND COMPONENTS AND PAGES
################################################################################

================================================================================
FILE: apps/frontend/app/auth/fyers/callback/page.tsx
PURPOSE: Fyers OAuth callback page
================================================================================

'use client';

import { useEffect, useState } from 'react';
import { useSearchParams, useRouter } from 'next/navigation';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { CheckCircle, XCircle, Loader2, Copy, ArrowRight } from 'lucide-react';

export default function FyersCallbackPage() {
  const [status, setStatus] = useState<'processing' | 'success' | 'error' | 'timeout'>('processing');
  const [message, setMessage] = useState('Processing authentication...');
  const [authCode, setAuthCode] = useState<string>('');
  const [accessToken, setAccessToken] = useState<string>('');
  const [countdown, setCountdown] = useState(5);
  const searchParams = useSearchParams();
  const router = useRouter();

  useEffect(() => {
    const code = searchParams.get('code');
    const error = searchParams.get('error');
    const state = searchParams.get('state');

    console.log('Callback received:', { code, error, state });

    if (error) {
      setStatus('error');
      setMessage(`Authentication failed: ${error}`);
      return;
    }

    if (!code) {
      setStatus('error');
      setMessage('No authorization code received');
      return;
    }

    setAuthCode(code);
    processAuthCode(code);
  }, [searchParams]);

  const processAuthCode = async (code: string) => {
    try {
      console.log('Processing auth code:', code);
      setMessage('Generating access token... This may take up to 90 seconds.');
      
      const response = await fetch('/api/auth/fyers/token', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ code }),
      });

      const data = await response.json();
      console.log('Token response:', data);

      if (!response.ok) {
        if (response.status === 408) {
          setStatus('timeout');
          setMessage('Authentication timed out. The process took too long. Please try again.');
          return;
        }
        throw new Error(data.error || 'Failed to generate token');
      }

      setAccessToken(data.access_token);
      setStatus('success');
      setMessage('Authentication successful! Python scripts will now start automatically.');

      // Notify Python scripts via WebSocket
      await notifyPythonScripts(data.access_token, code);

      // Start countdown
      startCountdown();

    } catch (error) {
      console.error('Auth processing error:', error);
      setStatus('error');
      setMessage(`Error: ${error.message}`);
    }
  };

  const notifyPythonScripts = async (token: string, code: string) => {
    try {
      console.log('Notifying Python scripts...');
      
      // Notify all Python services
      const results = await Promise.allSettled([
        fetch('/api/auth/fyers/notify', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            service: 'fyers_data', 
            token, 
            auth_code: code 
          }),
        }),
        fetch('/api/auth/fyers/notify', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            service: 'multi_company_live_data', 
            token, 
            auth_code: code 
          }),
        })
      ]);

      console.log('Notification results:', results);
    } catch (error) {
      console.error('Failed to notify Python scripts:', error);
    }
  };

  const startCountdown = () => {
    const timer = setInterval(() => {
      setCountdown(prev => {
        if (prev <= 1) {
          clearInterval(timer);
          router.push('/live-market?auth=success');
          return 0;
        }
        return prev - 1;
      });
    }, 1000);
  };

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
  };

  const goToLiveMarket = () => {
    router.push('/live-market?auth=success');
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-background p-4">
      <Card className="w-full max-w-md">
        <CardHeader className="text-center">
          <CardTitle className="flex items-center justify-center gap-2">
            {status === 'processing' && <Loader2 className="h-6 w-6 animate-spin text-blue-500" />}
            {status === 'success' && <CheckCircle className="h-6 w-6 text-green-500" />}
            {status === 'error' && <XCircle className="h-6 w-6 text-red-500" />}
            {status === 'timeout' && <XCircle className="h-6 w-6 text-yellow-500" />}
            Fyers Authentication
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <p className="text-center text-muted-foreground">{message}</p>
          
          {authCode && (
            <div className="space-y-2">
              <label className="text-sm font-medium">Authorization Code:</label>
              <div className="flex gap-2">
                <input
                  type="text"
                  value={authCode}
                  readOnly
                  className="flex-1 p-2 text-sm border rounded bg-muted"
                />
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => copyToClipboard(authCode)}
                >
                  <Copy className="h-4 w-4" />
                </Button>
              </div>
            </div>
          )}

          {status === 'success' && (
            <div className="space-y-3">
              <div className="p-3 bg-green-50 border border-green-200 rounded text-sm text-green-800">
                âœ… Authentication completed successfully!
                <br />
                Python scripts have been notified and should start automatically.
              </div>
              
              {countdown > 0 && (
                <div className="text-center">
                  <p className="text-sm text-muted-foreground mb-2">
                    Redirecting to Live Market in {countdown} seconds...
                  </p>
                  <Button 
                    onClick={goToLiveMarket}
                    className="w-full"
                    size="sm"
                  >
                    Go Now <ArrowRight className="w-4 h-4 ml-2" />
                  </Button>
                </div>
              )}
            </div>
          )}

          {(status === 'error' || status === 'timeout') && (
            <div className="space-y-3">
              <div className="p-3 bg-red-50 border border-red-200 rounded text-sm text-red-800">
                {status === 'timeout' ? 'â°' : 'âŒ'} {message}
              </div>
              <div className="flex gap-2">
                <Button 
                  onClick={() => window.location.reload()}
                  variant="outline"
                  className="flex-1"
                  size="sm"
                >
                  Try Again
                </Button>
                <Button 
                  onClick={goToLiveMarket}
                  className="flex-1"
                  size="sm"
                >
                  Continue <ArrowRight className="w-4 h-4 ml-2" />
                </Button>
              </div>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}


================================================================================
FILE: apps/frontend/app/components/FyersAuthStatus.tsx
PURPOSE: Fyers authentication status component
================================================================================

'use client';

import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { CheckCircle, XCircle, Clock, RefreshCw, ExternalLink } from 'lucide-react';

interface AuthStatus {
  authenticated: boolean;
  token_valid: boolean;
  expires_at: string | null;
  services_notified: string[];
}

export const FyersAuthStatus: React.FC = () => {
  const [authStatus, setAuthStatus] = useState<AuthStatus | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchAuthStatus = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/auth/fyers/status');
      const data = await response.json();
      setAuthStatus(data);
      setError(null);
    } catch (err) {
      setError('Failed to fetch auth status');
      console.error(err);
    } finally {
      setLoading(false);
    }
  };

  const startAuthFlow = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/auth/fyers/start', { method: 'POST' });
      const data = await response.json();
      
      if (data.auth_url) {
        window.open(data.auth_url, '_blank');
      }
    } catch (err) {
      setError('Failed to start authentication');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchAuthStatus();
    const interval = setInterval(fetchAuthStatus, 10000); // Refresh every 10 seconds
    return () => clearInterval(interval);
  }, []);

  const getStatusBadge = () => {
    if (!authStatus) return null;
    
    if (authStatus.authenticated && authStatus.token_valid) {
      return <Badge variant="default" className="bg-green-500"><CheckCircle className="w-3 h-3 mr-1" />Active</Badge>;
    } else if (authStatus.authenticated) {
      return <Badge variant="secondary"><Clock className="w-3 h-3 mr-1" />Expired</Badge>;
    } else {
      return <Badge variant="destructive"><XCircle className="w-3 h-3 mr-1" />Inactive</Badge>;
    }
  };

  const getExpiryText = () => {
    if (!authStatus?.expires_at) return 'N/A';
    
    const expiryDate = new Date(authStatus.expires_at);
    const now = new Date();
    const diffHours = Math.ceil((expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60));
    
    if (diffHours <= 0) return 'Expired';
    if (diffHours === 1) return '1 hour remaining';
    return `${diffHours} hours remaining`;
  };

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium">Fyers Authentication</CardTitle>
        <div className="flex items-center gap-2">
          {getStatusBadge()}
          <Button
            variant="ghost"
            size="sm"
            onClick={fetchAuthStatus}
            disabled={loading}
            className="h-8 w-8 p-0"
          >
            <RefreshCw className={`h-4 w-4 ${loading ? 'animate-spin' : ''}`} />
          </Button>
        </div>
      </CardHeader>
      <CardContent>
        {error && (
          <div className="mb-3 p-2 bg-red-50 border border-red-200 rounded text-sm text-red-600">
            {error}
          </div>
        )}
        
        <div className="space-y-2 text-sm">
          <div className="flex justify-between">
            <span className="text-muted-foreground">Status:</span>
            <span className="font-medium">
              {authStatus?.authenticated ? 'Authenticated' : 'Not Authenticated'}
            </span>
          </div>
          
          <div className="flex justify-between">
            <span className="text-muted-foreground">Token Valid:</span>
            <span className="font-medium">
              {authStatus?.token_valid ? 'Yes' : 'No'}
            </span>
          </div>
          
          <div className="flex justify-between">
            <span className="text-muted-foreground">Expires:</span>
            <span className="font-medium">{getExpiryText()}</span>
          </div>
          
          {authStatus?.services_notified && authStatus.services_notified.length > 0 && (
            <div className="pt-2 border-t">
              <div className="text-muted-foreground text-xs mb-1">Services Notified:</div>
              <div className="flex flex-wrap gap-1">
                {authStatus.services_notified.map((service) => (
                  <Badge key={service} variant="outline" className="text-xs">
                    {service}
                  </Badge>
                ))}
              </div>
            </div>
          )}
        </div>
        
        <div className="flex gap-2 mt-4">
          <Button
            onClick={startAuthFlow}
            disabled={loading}
            size="sm"
            className="flex-1"
          >
            {loading ? (
              <RefreshCw className="w-4 h-4 mr-2 animate-spin" />
            ) : (
              <ExternalLink className="w-4 h-4 mr-2" />
            )}
            {authStatus?.authenticated ? 'Re-authenticate' : 'Start Auth'}
          </Button>
        </div>
      </CardContent>
    </Card>
  );
};


================================================================================
FILE: apps/frontend/app/live-market/page.tsx
PURPOSE: Live market page with authentication integration
================================================================================

'use client';
import React, { useState, useEffect, useCallback } from 'react';
import { AppSidebar } from "../components/app-sidebar";
import {
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
  BreadcrumbSeparator,
} from "@/components/ui/breadcrumb";
import { Separator } from "@/components/ui/separator";
import {
  SidebarInset,
  SidebarProvider,
  SidebarTrigger,
} from "@/components/ui/sidebar";
import { ModeToggle } from "../components/toggleButton";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription } from "@/components/ui/alert";
import LiveMarketGrid from './components/LiveMarketGrid';
import { MultiSelectWatchlistSelector } from '../components/controllers/WatchlistSelector/MultiSelectWatchlistSelector';
import { FyersAuthStatus } from '../components/FyersAuthStatus';
import { useLiveMarket } from '../../hooks/useLiveMarket';
import { 
  Info, 
  Activity, 
  Users, 
  TrendingUp, 
  Shield, 
  AlertCircle,
  CheckCircle,
  XCircle 
} from 'lucide-react';

interface Company {
  company_code: string;
  name: string;
  exchange: string;
  marker: string;
  symbol: string;
}

interface AuthStatus {
  authenticated: boolean;
  token_valid: boolean;
  expires_at: string | null;
  services_notified: string[];
}

const LiveMarketPage: React.FC = () => {
  const {
    availableCompanies,
    selectedCompanies: liveMarketSelectedCompanies,
    marketData,
    marketStatus,
    connectionStatus,
    error,
    loading,
    subscribeToCompanies,
    unsubscribeAll,
    isConnected
  } = useLiveMarket();

  const [selectedCompanies, setSelectedCompanies] = useState<Company[]>([]);
  const [selectedWatchlist, setSelectedWatchlist] = useState('A');
  const [authStatus, setAuthStatus] = useState<AuthStatus | null>(null);
  const [authLoading, setAuthLoading] = useState(true);

  // Fetch authentication status
  const fetchAuthStatus = useCallback(async () => {
    try {
      setAuthLoading(true);
      const response = await fetch('/api/auth/fyers/status');
      const data = await response.json();
      setAuthStatus(data);
    } catch (error) {
      console.error('Failed to fetch auth status:', error);
      setAuthStatus(null);
    } finally {
      setAuthLoading(false);
    }
  }, []);

  // Auto-refresh auth status
  useEffect(() => {
    fetchAuthStatus();
    const interval = setInterval(fetchAuthStatus, 30000); // Check every 30 seconds
    return () => clearInterval(interval);
  }, [fetchAuthStatus]);

  // FIXED: Proper company selection handler
  const handleCompaniesSelect = useCallback((companies: Company[]) => {
    console.log('ðŸ” Companies selected in LiveMarketPage:', companies);
    setSelectedCompanies(companies);
    
    // Check auth before subscribing
    if (!authStatus?.authenticated || !authStatus?.token_valid) {
      console.warn('âš ï¸ Cannot subscribe: Fyers authentication required');
      return;
    }
    
    // FIXED: Pass Company objects directly to subscribeToCompanies
    if (companies.length > 0) {
      console.log('ðŸ“¡ Subscribing to companies:', companies);
      subscribeToCompanies(companies);
    } else {
      console.log('ðŸ“¡ No companies selected, unsubscribing from all');
      unsubscribeAll();
    }
  }, [subscribeToCompanies, unsubscribeAll, authStatus]);

  const handleWatchlistChange = useCallback((watchlist: string) => {
    console.log('Watchlist changed to:', watchlist);
    setSelectedWatchlist(watchlist);
    // Clear selections when watchlist changes
    setSelectedCompanies([]);
    unsubscribeAll();
  }, [unsubscribeAll]);

  const handleClearSelection = useCallback(() => {
    console.log('ðŸ“¡ Clearing all selections');
    setSelectedCompanies([]);
    unsubscribeAll();
  }, [unsubscribeAll]);

  // FIXED: Convert selected companies to the format expected by LiveMarketGrid
  const gridSelectedCompanies = React.useMemo(() => {
    return selectedCompanies.map(company => ({
      ...company,
      // Ensure symbol is properly formatted
      symbol: company.symbol || `${company.exchange}:${company.company_code}-${company.marker}`
    }));
  }, [selectedCompanies]);

  // FIXED: Debug logging for state changes
  useEffect(() => {
    console.log('ðŸ” LiveMarketPage State Update:', {
      selectedCompanies: selectedCompanies.length,
      liveMarketSelectedCompanies: liveMarketSelectedCompanies.length,
      marketDataKeys: Object.keys(marketData),
      isConnected,
      loading,
      error,
      authStatus: authStatus?.authenticated
    });
  }, [selectedCompanies, liveMarketSelectedCompanies, marketData, isConnected, loading, error, authStatus]);

  // Get auth status icon and color
  const getAuthStatusDisplay = () => {
    if (authLoading) {
      return { icon: Activity, color: 'text-blue-500', text: 'Checking...' };
    }
    
    if (!authStatus) {
      return { icon: XCircle, color: 'text-red-500', text: 'Unknown' };
    }
    
    if (authStatus.authenticated && authStatus.token_valid) {
      return { icon: CheckCircle, color: 'text-green-500', text: 'Active' };
    } else if (authStatus.authenticated) {
      return { icon: AlertCircle, color: 'text-yellow-500', text: 'Expired' };
    } else {
      return { icon: XCircle, color: 'text-red-500', text: 'Required' };
    }
  };

  const authDisplay = getAuthStatusDisplay();
  const AuthIcon = authDisplay.icon;

  return (
    <SidebarProvider>
      <AppSidebar />
      <SidebarInset>
        <header className="flex h-16 shrink-0 items-center gap-2 w-full">
          <div className="flex items-center gap-2 px-4">
            <SidebarTrigger className="-ml-1" />
            <Separator orientation="vertical" className="mr-2 h-4" />
            <Breadcrumb className="flex items-center justify-end gap-2">
              <BreadcrumbList>
                <BreadcrumbItem className="hidden md:block">
                  <BreadcrumbLink href="#">
                    Building Your Application
                  </BreadcrumbLink>
                </BreadcrumbItem>
                <BreadcrumbSeparator className="hidden md:block" />
                <BreadcrumbItem>
                  <BreadcrumbPage>Live Market Grid</BreadcrumbPage>
                </BreadcrumbItem>
              </BreadcrumbList>
              <ModeToggle />
            </Breadcrumb>
          </div>
        </header>
        
        <div className="flex flex-1 flex-col gap-4 p-4 pt-0">
          {/* Authentication Status Alert */}
          {(!authStatus?.authenticated || !authStatus?.token_valid) && (
            <Alert className="border-yellow-200 bg-yellow-50">
              <Shield className="h-4 w-4" />
              <AlertDescription className="flex items-center justify-between">
                <span>
                  <strong>Fyers Authentication Required:</strong> Please authenticate to access live market data.
                </span>
                <Button variant="outline" size="sm" onClick={fetchAuthStatus}>
                  Refresh Status
                </Button>
              </AlertDescription>
            </Alert>
          )}

          {/* Header Card with Status Overview */}
          <Card className="w-full">
            <CardHeader>
              <div className="flex items-center justify-between">
                <div>
                  <CardTitle className="flex items-center gap-2">
                    <TrendingUp className="h-5 w-5" />
                    Live Market Data Grid
                  </CardTitle>
                  <p className="text-sm text-muted-foreground mt-1">
                    Monitor real-time market data for up to 6 companies from your watchlists
                  </p>
                </div>
                <div className="flex items-center gap-6">
                  {/* Fyers Auth Status */}
                  <div className="flex items-center gap-2 px-3 py-1 rounded-full bg-muted/50">
                    <Shield className="w-4 h-4 text-muted-foreground" />
                    <AuthIcon className={`w-4 h-4 ${authDisplay.color}`} />
                    <span className="text-sm font-medium">
                      Auth: {authDisplay.text}
                    </span>
                  </div>
                  
                  {/* Connection Status */}
                  <div className="flex items-center gap-2">
                    <div className={`w-2 h-2 rounded-full ${
                      isConnected ? 'bg-green-500' : 'bg-red-500'
                    }`} />
                    <span className="text-sm font-medium">
                      {connectionStatus}
                    </span>
                  </div>
                  
                  {/* Market Status */}
                  {marketStatus?.trading_active && (
                    <Badge variant="default" className="bg-green-100 text-green-800">
                      <Activity className="w-3 h-3 mr-1" />
                      Market Open
                    </Badge>
                  )}
                  {!marketStatus?.trading_active && !marketStatus?.is_market_day && (
                    <Badge variant="secondary">
                      Market Closed
                    </Badge>
                  )}
                  {!marketStatus?.is_market_day && (
                    <Badge variant="outline">
                      Weekend
                    </Badge>
                  )}
                </div>
              </div>
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
                {/* Company Selection */}
                <div className="lg:col-span-3 space-y-4">
                  <div className="flex justify-between items-center">
                    <h3 className="text-lg font-medium">Select Companies from Watchlist (1-6)</h3>
                    {selectedCompanies.length > 0 && (
                      <div className="flex items-center gap-4">
                        <div className="flex flex-col items-end gap-1 text-sm text-muted-foreground">
                          <div className="flex items-center gap-1">
                            <Users className="w-4 h-4" />
                            <span>{selectedCompanies.length} companies selected</span>
                          </div>
                          <div className="flex items-center gap-1">
                            <Activity className="w-4 h-4" />
                            <span>{Object.keys(marketData).length} receiving data</span>
                          </div>
                        </div>
                        <Button 
                          variant="outline" 
                          size="sm" 
                          onClick={handleClearSelection}
                          disabled={loading}
                        >
                          {loading ? 'Clearing...' : 'Clear Selection'}
                        </Button>
                      </div>
                    )}
                  </div>
                  
                  <MultiSelectWatchlistSelector
                    onCompaniesSelect={handleCompaniesSelect}
                    selectedWatchlist={selectedWatchlist}
                    onWatchlistChange={handleWatchlistChange}
                    maxSelection={6}
                    selectedCompanies={selectedCompanies}
                    showExchangeFilter={true}
                    showMarkerFilter={true}
                    disabled={!authStatus?.authenticated || !authStatus?.token_valid}
                  />
                  
                  {/* Auth Required Message */}
                  {(!authStatus?.authenticated || !authStatus?.token_valid) && (
                    <div className="bg-yellow-50 border border-yellow-200 text-yellow-700 px-3 py-2 rounded-md text-sm">
                      âš ï¸ Authentication required to select companies and view live data
                    </div>
                  )}

                  {/* Loading State */}
                  {loading && (
                    <div className="flex items-center gap-2 text-sm text-muted-foreground">
                      <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-primary"></div>
                      <span>Subscribing to market data...</span>
                    </div>
                  )}

                  {/* Error Display */}
                  {error && (
                    <div className="bg-red-50 border border-red-200 text-red-700 px-3 py-2 rounded-md text-sm">
                      âŒ {error}
                    </div>
                  )}
                </div>

                {/* Fyers Authentication Panel */}
                <div className="lg:col-span-1">
                  <FyersAuthStatus />
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Live Market Grid */}
          {selectedCompanies.length > 0 && authStatus?.authenticated && authStatus?.token_valid && (
            <LiveMarketGrid
              selectedCompanies={gridSelectedCompanies}
              marketData={marketData}
              connectionStatus={connectionStatus}
              loading={loading}
            />
          )}

          {/* Authentication Required State */}
          {selectedCompanies.length > 0 && (!authStatus?.authenticated || !authStatus?.token_valid) && (
            <Card className="w-full">
              <CardContent className="flex flex-col items-center justify-center py-12">
                <Shield className="h-12 w-12 text-yellow-500 mb-4" />
                <h3 className="text-lg font-medium mb-2">Authentication Required</h3>
                <p className="text-sm text-muted-foreground text-center max-w-md mb-6">
                  You have selected {selectedCompanies.length} companies, but Fyers authentication is required to view live market data.
                </p>
                <div className="flex gap-3">
                  <FyersAuthStatus />
                </div>
              </CardContent>
            </Card>
          )}

          {/* No Selection State */}
          {selectedCompanies.length === 0 && (
            <Card className="w-full">
              <CardContent className="flex flex-col items-center justify-center py-12">
                <TrendingUp className="h-12 w-12 text-muted-foreground mb-4" />
                <h3 className="text-lg font-medium mb-2">No Companies Selected</h3>
                <p className="text-sm text-muted-foreground text-center max-w-md">
                  Select 1-6 companies from your watchlist above to start monitoring their real-time market data in an interactive grid layout.
                  {!authStatus?.authenticated && " Note: Fyers authentication is required for live data."}
                </p>
              </CardContent>
            </Card>
          )}

          {/* Debug Panel (Development only) */}
          {process.env.NODE_ENV === 'development' && (
            <Card className="w-full bg-gray-50">
              <CardHeader>
                <CardTitle className="text-sm">Debug Information</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-xs">
                  <div>
                    <strong>Selected:</strong> {selectedCompanies.length}
                  </div>
                  <div>
                    <strong>Connected:</strong> {isConnected ? 'Yes' : 'No'}
                  </div>
                  <div>
                    <strong>Market Data:</strong> {Object.keys(marketData).length} symbols
                  </div>
                  <div>
                    <strong>Auth Status:</strong> {authStatus?.authenticated ? 'Authenticated' : 'Not Authenticated'}
                  </div>
                </div>
              </CardContent>
            </Card>
          )}
        </div>
      </SidebarInset>
    </SidebarProvider>
  );
};

export default LiveMarketPage;


################################################################################
SECTION 5: FRONTEND UI AND DATA FILES
################################################################################

================================================================================
FILE: apps/frontend/components/ui/alert.tsx
PURPOSE: Alert UI component for authentication notifications
================================================================================

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }


================================================================================
FILE: apps/frontend/public/data-manifest.json
PURPOSE: Data manifest for application configuration
================================================================================

{
  "dates": [
    {
      "date": "2025-06-17",
      "displayDate": "2025-06-17",
      "companiesCount": 6,
      "companies": [
        {
          "symbol": "NSE:GPIL-EQ",
          "company": "GPIL",
          "exchange": "NSE",
          "fileName": "GPIL-NSE.json",
          "fileNameWithoutExt": "GPIL-NSE"
        },
        {
          "symbol": "NSE:IDBI-EQ",
          "company": "IDBI",
          "exchange": "NSE",
          "fileName": "IDBI-NSE.json",
          "fileNameWithoutExt": "IDBI-NSE"
        },
        {
          "symbol": "NSE:KIRIINDUS-EQ",
          "company": "KIRIINDUS",
          "exchange": "NSE",
          "fileName": "KIRIINDUS-NSE.json",
          "fileNameWithoutExt": "KIRIINDUS-NSE"
        },
        {
          "symbol": "NSE:NORTHARC-EQ",
          "company": "NORTHARC",
          "exchange": "NSE",
          "fileName": "NORTHARC-NSE.json",
          "fileNameWithoutExt": "NORTHARC-NSE"
        },
        {
          "symbol": "NSE:RPOWER-EQ",
          "company": "RPOWER",
          "exchange": "NSE",
          "fileName": "RPOWER-NSE.json",
          "fileNameWithoutExt": "RPOWER-NSE"
        },
        {
          "symbol": "NSE:SCI-EQ",
          "company": "SCI",
          "exchange": "NSE",
          "fileName": "SCI-NSE.json",
          "fileNameWithoutExt": "SCI-NSE"
        }
      ]
    },
    {
      "date": "2025-06-10",
      "displayDate": "2025-06-10",
      "companiesCount": 6,
      "companies": [
        {
          "symbol": "NSE:GPIL-EQ",
          "company": "GPIL",
          "exchange": "NSE",
          "fileName": "GPIL-NSE.json",
          "fileNameWithoutExt": "GPIL-NSE"
        },
        {
          "symbol": "NSE:IDBI-EQ",
          "company": "IDBI",
          "exchange": "NSE",
          "fileName": "IDBI-NSE.json",
          "fileNameWithoutExt": "IDBI-NSE"
        },
        {
          "symbol": "NSE:KIRIINDUS-EQ",
          "company": "KIRIINDUS",
          "exchange": "NSE",
          "fileName": "KIRIINDUS-NSE.json",
          "fileNameWithoutExt": "KIRIINDUS-NSE"
        },
        {
          "symbol": "NSE:NORTHARC-EQ",
          "company": "NORTHARC",
          "exchange": "NSE",
          "fileName": "NORTHARC-NSE.json",
          "fileNameWithoutExt": "NORTHARC-NSE"
        },
        {
          "symbol": "NSE:RPOWER-EQ",
          "company": "RPOWER",
          "exchange": "NSE",
          "fileName": "RPOWER-NSE.json",
          "fileNameWithoutExt": "RPOWER-NSE"
        },
        {
          "symbol": "NSE:SCI-EQ",
          "company": "SCI",
          "exchange": "NSE",
          "fileName": "SCI-NSE.json",
          "fileNameWithoutExt": "SCI-NSE"
        }
      ]
    }
  ],
  "lastUpdated": "2025-07-23T12:38:07.226Z"
}

################################################################################
END OF FYERS AUTHENTICATION SYSTEM EXTRACTION
################################################################################

EXTRACTION SUMMARY:
===================
Backend Python Files: 2 files
Backend NestJS Modules and Services: 4 files
Frontend API Routes: 4 files
Frontend Components and Pages: 3 files
Frontend UI and Data Files: 2 files

TOTAL FILES PROCESSED: 15 FILES

SYSTEM COMPONENTS EXTRACTED:
- Automated Python authentication scripts
- NestJS authentication modules and controllers
- Next.js API routes for auth flow
- Frontend auth components and pages
- UI components and configuration files
################################################################################
