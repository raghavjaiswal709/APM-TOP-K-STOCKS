================================================================================
AUTHENTICATION FLOW ANALYSIS - ALL FILES
Generated on: 22-07-2025 21:03:06.58
================================================================================

CATEGORIES:
1. Python Authentication Files (3 files)
2. Backend Auth Configuration (2 files)
3. Frontend Data Hooks (3 files)
4. Market Data Components (2 files)

TOTAL: 10 FILES
================================================================================


################################################################################
SECTION 1: PYTHON AUTHENTICATION FILES
################################################################################

================================================================================
FILE: apps/backend/fyers_data.py
PURPOSE: Core Python authentication implementation
================================================================================

import eventlet
eventlet.monkey_patch()

import socketio
import json
import sys
import time
import datetime
import pytz
import threading
import logging
import requests
import numpy as np
import os
from collections import deque
from fyers_apiv3 import fyersModel
from fyers_apiv3.FyersWebsocket import data_ws

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
)
logger = logging.getLogger("FyersServer")

sio = socketio.Server(cors_allowed_origins='*', async_mode='eventlet')
app = socketio.WSGIApp(sio)

client_id = "150HUKJSWG-100"
secret_key = "18YYNXCAS7"
redirect_uri = "https://daksphere.com/"
response_type = "code"
grant_type = "authorization_code"

clients = {}
symbol_to_clients = {}
running = True

historical_data = {}
ohlc_data = {}
MAX_HISTORY_POINTS = 10000

INDIA_TZ = pytz.timezone('Asia/Kolkata')

fyers = None
fyers_client = None

def get_trading_hours():
    now = datetime.datetime.now(INDIA_TZ)
    start_time = now.replace(hour=9, minute=15, second=0, microsecond=0)
    end_time = now.replace(hour=15, minute=30, second=0, microsecond=0)
    return start_time, end_time

def is_trading_hours():
    now = datetime.datetime.now(INDIA_TZ)
    start_time, end_time = get_trading_hours()
    
    if now.weekday() >= 5:
        return False
    
    return start_time <= now <= end_time

@sio.event
def connect(sid, environ):
    logger.info(f"Client connected: {sid}")
    clients[sid] = {'subscriptions': set()}

@sio.event
def disconnect(sid):
    logger.info(f"Client disconnected: {sid}")
    if sid in clients:
        for symbol in clients[sid]['subscriptions']:
            if symbol in symbol_to_clients:
                symbol_to_clients[symbol].discard(sid)
        del clients[sid]

def fetch_historical_intraday_data(symbol, date=None):
    if not date:
        date = datetime.datetime.now(INDIA_TZ).strftime('%Y-%m-%d')
    
    try:
        date_obj = datetime.datetime.strptime(date, '%Y-%m-%d')
        date_obj = INDIA_TZ.localize(date_obj)
        
        market_open = date_obj.replace(hour=9, minute=15, second=0, microsecond=0)
        market_close = date_obj.replace(hour=15, minute=30, second=0, microsecond=0)
        
        now = datetime.datetime.now(INDIA_TZ)
        if date == now.strftime('%Y-%m-%d') and now < market_open:
            logger.info(f"Market not yet open for {date}")
            return []
        
        if date == now.strftime('%Y-%m-%d') and now < market_close:
            end_time = now
        else:
            end_time = market_close
        
        from_date = market_open.strftime('%Y-%m-%d %H:%M:%S')
        to_date = end_time.strftime('%Y-%m-%d %H:%M:%S')
        
        logger.info(f"Fetching historical data for {symbol} from {from_date} to {to_date}")
        
        if fyers_client:
            data_args = {
                "symbol": symbol,
                "resolution": "1",
                "date_format": "1",
                "range_from": from_date,
                "range_to": to_date,
                "cont_flag": "1"
            }
            
            response = fyers_client.history(data_args)
            
            if response and response.get('s') == 'ok' and 'candles' in response:
                candles = response['candles']
                logger.info(f"Received {len(candles)} candles for {symbol}")
                
                result = []
                
                for candle in candles:
                    timestamp, open_price, high_price, low_price, close_price, volume = candle
                    
                    if timestamp > 10000000000:
                        timestamp = timestamp // 1000
                    
                    data_point = {
                        'symbol': symbol,
                        'ltp': close_price,
                        'open': open_price,
                        'high': high_price,
                        'low': low_price,
                        'close': close_price,
                        'volume': volume,
                        'timestamp': timestamp,
                        'change': 0,
                        'changePercent': 0
                    }
                    
                    result.append(data_point)
                    
                    if symbol not in ohlc_data:
                        ohlc_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)
                    
                    minute_timestamp = (timestamp // 60) * 60
                    
                    ohlc_candle = {
                        'timestamp': minute_timestamp,
                        'open': open_price,
                        'high': high_price,
                        'low': low_price,
                        'close': close_price,
                        'volume': volume
                    }
                    
                    if not ohlc_data[symbol] or ohlc_data[symbol][-1]['timestamp'] != minute_timestamp:
                        ohlc_data[symbol].append(ohlc_candle)
                
                if result:
                    prev_close = result[0]['open']
                    for point in result:
                        point['change'] = point['ltp'] - prev_close
                        point['changePercent'] = (point['change'] / prev_close) * 100 if prev_close else 0
                
                return result
            else:
                logger.error(f"Failed to fetch historical data: {response}")
        
        logger.warning(f"Fyers client not initialized or API call failed for {symbol}")
        return []
        
    except Exception as e:
        logger.error(f"Error fetching historical data: {e}")
        import traceback
        traceback.print_exc()
        return []

def fetch_daily_historical_data(symbol, days=30):
    try:
        if not fyers_client:
            logger.error("Fyers client not initialized")
            return []
        
        end_date = datetime.datetime.now(INDIA_TZ)
        start_date = end_date - datetime.timedelta(days=days)
        
        data_args = {
            "symbol": symbol,
            "resolution": "D",
            "date_format": "1",
            "range_from": start_date.strftime('%Y-%m-%d'),
            "range_to": end_date.strftime('%Y-%m-%d'),
            "cont_flag": "1"
        }
        
        response = fyers_client.history(data_args)
        
        if response and response.get('s') == 'ok' and 'candles' in response:
            return response['candles']
        else:
            logger.error(f"Failed to fetch daily historical data: {response}")
            return []
            
    except Exception as e:
        logger.error(f"Error fetching daily historical data: {e}")
        return []

@sio.event
def subscribe(sid, data):
    symbol = data.get('symbol')
    if not symbol:
        return {'success': False, 'error': 'No symbol provided'}
    
    logger.info(f"Client {sid} subscribing to {symbol}")
    
    clients[sid]['subscriptions'].add(symbol)
    if symbol not in symbol_to_clients:
        symbol_to_clients[symbol] = set()
    symbol_to_clients[symbol].add(sid)
    
    if symbol not in historical_data or not historical_data[symbol]:
        logger.info(f"Fetching historical data for {symbol}")
        hist_data = fetch_historical_intraday_data(symbol)
        
        if symbol not in historical_data:
            historical_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)
        
        for data_point in hist_data:
            historical_data[symbol].append(data_point)
    
    if hasattr(fyers, 'subscribe') and callable(fyers.subscribe):
        logger.info(f"Subscribing to symbol: {symbol}")
        fyers.subscribe(symbols=[symbol], data_type="SymbolUpdate")
    
    if symbol in historical_data and historical_data[symbol]:
        logger.info(f"Sending historical data for {symbol} to client {sid}")
        hist_data_list = list(historical_data[symbol])
        sio.emit('historicalData', {
            'symbol': symbol,
            'data': hist_data_list
        }, room=sid)
    
    if symbol in ohlc_data and ohlc_data[symbol]:
        logger.info(f"Sending OHLC data for {symbol} to client {sid}")
        sio.emit('ohlcData', {
            'symbol': symbol,
            'data': list(ohlc_data[symbol])
        }, room=sid)
    
    return {'success': True, 'symbol': symbol}

@sio.event
def unsubscribe(sid, data):
    symbol = data.get('symbol')
    if not symbol:
        return {'success': False, 'error': 'No symbol provided'}
    
    logger.info(f"Client {sid} unsubscribing from {symbol}")
    
    if sid in clients:
        clients[sid]['subscriptions'].discard(symbol)
    
    if symbol in symbol_to_clients:
        symbol_to_clients[symbol].discard(sid)
        
        if not symbol_to_clients[symbol] and hasattr(fyers, 'unsubscribe'):
            logger.info(f"No more clients for {symbol}, unsubscribing from Fyers")
            fyers.unsubscribe(symbols=[symbol])
    
    return {'success': True, 'symbol': symbol}

@sio.event
def get_trading_status(sid, data):
    start_time, end_time = get_trading_hours()
    return {
        'trading_active': is_trading_hours(),
        'trading_start': start_time.isoformat(),
        'trading_end': end_time.isoformat(),
        'current_time': datetime.datetime.now(INDIA_TZ).isoformat(),
        'is_market_day': datetime.datetime.now(INDIA_TZ).weekday() < 5
    }

@sio.event
def get_historical_data_for_date(sid, data):
    symbol = data.get('symbol')
    date = data.get('date')
    
    if not symbol:
        return {'success': False, 'error': 'No symbol provided'}
    
    if not date:
        date = datetime.datetime.now(INDIA_TZ).strftime('%Y-%m-%d')
    
    try:
        # try:
        #     with open(f'market_data_{date}_{symbol}.json', 'r') as f:
        #         saved_data = json.load(f)
        #         logger.info(f"Loaded saved data for {symbol} on {date}")
        #         return {
        #             'success': True,
        #             'symbol': symbol,
        #             'date': date,
        #             'data': saved_data
        #         }
        # except FileNotFoundError:
        #     pass
        
        hist_data = fetch_historical_intraday_data(symbol, date)
        
        # if hist_data:
        #     try:
        #         with open(f'market_data_{date}_{symbol}.json', 'w') as f:
        #             json.dump(hist_data, f)
        #         logger.info(f"Saved historical data for {symbol} on {date}")
        #     except Exception as e:
        #         logger.error(f"Error saving historical data: {e}")
        
        return {
            'success': True,
            'symbol': symbol,
            'date': date,
            'data': hist_data
        }
    except Exception as e:
        logger.error(f"Error fetching historical data for date: {e}")
        return {'success': False, 'error': str(e)}

@sio.event
def get_daily_data(sid, data):
    symbol = data.get('symbol')
    days = data.get('days', 30)
    
    if not symbol:
        return {'success': False, 'error': 'No symbol provided'}
    
    try:
        daily_data = fetch_daily_historical_data(symbol, days)
        
        if daily_data:
            formatted_data = []
            for candle in daily_data:
                timestamp, open_price, high_price, low_price, close_price, volume = candle
                formatted_data.append({
                    'timestamp': timestamp,
                    'open': open_price,
                    'high': high_price,
                    'low': low_price,
                    'close': close_price,
                    'volume': volume
                })
            
            return {
                'success': True,
                'symbol': symbol,
                'days': days,
                'data': formatted_data
            }
        else:
            return {'success': False, 'error': 'No data available'}
    except Exception as e:
        logger.error(f"Error fetching daily data: {e}")
        return {'success': False, 'error': str(e)}

def store_historical_data(symbol, data_point):
    if symbol not in historical_data:
        historical_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)
    
    if 'timestamp' not in data_point:
        data_point['timestamp'] = int(time.time())
    
    historical_data[symbol].append(data_point)
    
    update_ohlc_data(symbol, data_point)

def update_ohlc_data(symbol, data_point):
    if symbol not in ohlc_data:
        ohlc_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)
    
    timestamp = data_point['timestamp']
    price = data_point['ltp']
    
    minute_timestamp = (timestamp // 60) * 60
    
    if not ohlc_data[symbol] or ohlc_data[symbol][-1]['timestamp'] < minute_timestamp:
        ohlc_data[symbol].append({
            'timestamp': minute_timestamp,
            'open': price,
            'high': price,
            'low': price,
            'close': price,
            'volume': data_point.get('volume', 0)
        })
    else:
        current_candle = ohlc_data[symbol][-1]
        current_candle['high'] = max(current_candle['high'], price)
        current_candle['low'] = min(current_candle['low'], price)
        current_candle['close'] = price
        current_candle['volume'] = data_point.get('volume', current_candle['volume'])

def calculate_indicators(symbol):
    if symbol not in ohlc_data or len(ohlc_data[symbol]) < 20:
        return {}
    
    closes = [candle['close'] for candle in ohlc_data[symbol]]
    
    sma_20 = np.mean(closes[-20:])
    
    ema_9 = closes[-1]
    alpha = 2 / (9 + 1)
    for i in range(2, min(10, len(closes) + 1)):
        ema_9 = alpha * closes[-i] + (1 - alpha) * ema_9
    
    changes = [closes[i] - closes[i-1] for i in range(1, len(closes))]
    gains = [max(0, change) for change in changes]
    losses = [max(0, -change) for change in changes]
    
    if len(gains) >= 14:
        avg_gain = np.mean(gains[-14:])
        avg_loss = np.mean(losses[-14:])
        
        if avg_loss == 0:
            rsi = 100
        else:
            rs = avg_gain / avg_loss
            rsi = 100 - (100 / (1 + rs))
    else:
        rsi = 50
    
    return {
        'sma_20': sma_20,
        'ema_9': ema_9,
        'rsi_14': rsi
    }

def onmessage(message):
    logger.debug(f"Response: {message}")
    
    if isinstance(message, dict) and message.get('type') == 'sub':
        logger.info(f"Subscription confirmation: {message}")
        return
    
    if isinstance(message, dict) and 'symbol' in message:
        symbol = message['symbol']
        
        simplified_data = {
            'symbol': symbol,
            'ltp': message.get('ltp'),
            'change': message.get('ch'),
            'changePercent': message.get('chp'),
            'volume': message.get('vol_traded_today'),
            'open': message.get('open_price'),
            'high': message.get('high_price'),
            'low': message.get('low_price'),
            'close': message.get('prev_close_price'),
            'bid': message.get('bid_price'),
            'ask': message.get('ask_price'),
            'timestamp': message.get('last_traded_time') or int(time.time())
        }
        
        store_historical_data(symbol, simplified_data)
        
        indicators = calculate_indicators(symbol)
        if indicators:
            simplified_data.update(indicators)
        
        if symbol in symbol_to_clients:
            for sid in symbol_to_clients[symbol]:
                try:
                    sio.emit('marketData', simplified_data, room=sid)
                except Exception as e:
                    logger.error(f"Error sending data to client {sid}: {e}")
        else:
            logger.debug(f"No clients subscribed to {symbol}")
    else:
        logger.warning(f"Invalid message format: {message}")

def onerror(error):
    logger.error(f"Error: {error}")
    sio.emit('error', {'message': str(error)})

def onclose(message):
    logger.info(f"Connection closed: {message}")
    sio.emit('fyersDisconnected', {'message': str(message)})

def onopen():
    logger.info("Fyers WebSocket connected")
    sio.emit('fyersConnected', {'status': 'connected'})
    
    default_symbols = []
    fyers.subscribe(symbols=default_symbols, data_type="SymbolUpdate")
    logger.info(f"Subscribed to default symbols: {default_symbols}")

def heartbeat_task():
    global running
    while running:
        try:
            sio.emit('heartbeat', {
                'timestamp': int(time.time()),
                'trading_active': is_trading_hours()
            })
            time.sleep(30)
        except Exception as e:
            logger.error(f"Error in heartbeat: {e}")

def save_daily_data():
    today = datetime.datetime.now(INDIA_TZ).strftime('%Y-%m-%d')
    
    for symbol in historical_data:
        data_to_save = list(historical_data[symbol])
        
        try:
            with open(f'market_data_{today}_{symbol}.json', 'w') as f:
                json.dump(data_to_save, f)
            logger.info(f"Saved market data for {symbol} on {today}")
        except Exception as e:
            logger.error(f"Error saving market data for {symbol}: {e}")
    
    for symbol in ohlc_data:
        ohlc_to_save = list(ohlc_data[symbol])
        
        try:
            with open(f'ohlc_data_{today}_{symbol}.json', 'w') as f:
                json.dump(ohlc_to_save, f)
            logger.info(f"Saved OHLC data for {symbol} on {today}")
        except Exception as e:
            logger.error(f"Error saving OHLC data for {symbol}: {e}")

def load_daily_data():
    today = datetime.datetime.now(INDIA_TZ).strftime('%Y-%m-%d')
    
    for file in os.listdir('.'):
        if file.startswith('market_data_' + today) and file.endswith('.json'):
            symbol = file.replace('market_data_' + today + '_', '').replace('.json', '')
            
            try:
                with open(file, 'r') as f:
                    data_points = json.load(f)
                    
                    if symbol not in historical_data:
                        historical_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)
                    
                    for point in data_points:
                        historical_data[symbol].append(point)
                    
                    logger.info(f"Loaded {len(data_points)} historical data points for {symbol}")
            except Exception as e:
                logger.error(f"Error loading market data for {symbol}: {e}")
    
    for file in os.listdir('.'):
        if file.startswith('ohlc_data_' + today) and file.endswith('.json'):
            symbol = file.replace('ohlc_data_' + today + '_', '').replace('.json', '')
            
            try:
                with open(file, 'r') as f:
                    candles = json.load(f)
                    
                    if symbol not in ohlc_data:
                        ohlc_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)
                    
                    for candle in candles:
                        ohlc_data[symbol].append(candle)
                    
                    logger.info(f"Loaded {len(candles)} OHLC candles for {symbol}")
            except Exception as e:
                logger.error(f"Error loading OHLC data for {symbol}: {e}")

# def data_persistence_task():
#     global running
#     while running:
#         try:
#             save_daily_data()
#             time.sleep(300)
#         except Exception as e:
#             logger.error(f"Error in data persistence task: {e}")

def cleanup_old_data_files():
    try:
        today = datetime.datetime.now(INDIA_TZ)
        for file in os.listdir('.'):
            if (file.startswith('market_data_') or file.startswith('ohlc_data_')) and file.endswith('.json'):
                try:
                    date_str = file.split('_')[2]
                    file_date = datetime.datetime.strptime(date_str, '%Y-%m-%d')
                    if (today - file_date).days > 30:
                        os.remove(file)
                        logger.info(f"Removed old data file: {file}")
                except (ValueError, IndexError):
                    continue
    except Exception as e:
        logger.error(f"Error cleaning up old data files: {e}")

def main_process():
    global fyers, fyers_client, running
    
    try:
        # load_daily_data()
        
        cleanup_old_data_files()
        
        session = fyersModel.SessionModel(
            client_id=client_id,
            secret_key=secret_key,
            redirect_uri=redirect_uri,
            response_type=response_type,
            grant_type=grant_type
        )
        
        auth_url = session.generate_authcode()
        logger.info("\n==== Fyers Authentication ====")
        logger.info("Open this URL in your browser and log in:")
        logger.info(auth_url)
        
        auth_code = input("\nEnter Auth Code: ")
        session.set_token(auth_code)
        token_response = session.generate_token()
        
        if token_response.get('s') != 'ok':
            logger.error(f"Authentication failed: {token_response}")
            return
            
        logger.info("Authentication successful!")
        access_token = f"{client_id}:{token_response['access_token']}"
        
        fyers_client = fyersModel.FyersModel(
            client_id=client_id,
            token=token_response['access_token'],
            log_path=""
        )
        
        fyers = data_ws.FyersDataSocket(
            access_token=access_token,
            log_path="",
            litemode=False,
            write_to_file=False,
            reconnect=True,
            on_connect=onopen,
            on_close=onclose,
            on_error=onerror,
            on_message=onmessage
        )
        
        heartbeat_thread = threading.Thread(target=heartbeat_task, daemon=True)
        heartbeat_thread.start()
        
        # persistence_thread = threading.Thread(target=data_persistence_task, daemon=True)
        # persistence_thread.start()
        
        def schedule_end_of_day_save():
            now = datetime.datetime.now(INDIA_TZ)
            market_close = now.replace(hour=15, minute=30, second=0, microsecond=0)
            
            if now < market_close:
                delay = (market_close - now).total_seconds()
                threading.Timer(delay, save_daily_data).start()
                logger.info(f"Scheduled end-of-day data save for {market_close.strftime('%H:%M:%S')}")
        
        # schedule_end_of_day_save()
        
        fyers.connect()
        logger.info("Connected to Fyers WebSocket")
        
        logger.info("Starting Socket.IO server on port 5001...")
        eventlet.wsgi.server(eventlet.listen(('0.0.0.0', 5001)), app)
        
    except Exception as e:
        logger.error(f"Error: {e}")
        import traceback
        traceback.print_exc()

def main():
    global running
    
    try:
        eventlet.spawn(main_process)
        
        while running:
            time.sleep(1)
    except KeyboardInterrupt:
        logger.info("Shutting down...")
        running = False
        # save_daily_data()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logger.info("Shutting down...")
        running = False
        save_daily_data()


================================================================================
FILE: apps/backend/multi_company_live_data.py
PURPOSE: Multi-company live data authentication
================================================================================

import eventlet
eventlet.monkey_patch()

import socketio
import json
import sys
import time
import datetime
import pytz
import threading
import logging
import requests
import numpy as np
import os
from collections import deque
from fyers_apiv3 import fyersModel
from fyers_apiv3.FyersWebsocket import data_ws
import pandas as pd

# Enhanced logging configuration
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('live_market.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("LiveMarketServer")

# Socket.IO setup with enhanced CORS
sio = socketio.Server(
    cors_allowed_origins='*', 
    async_mode='eventlet',
    logger=True,
    engineio_logger=True
)
app = socketio.WSGIApp(sio)

# Fyers API credentials
client_id = "150HUKJSWG-100"
secret_key = "18YYNXCAS7"
redirect_uri = "https://daksphere.com/"
response_type = "code"
grant_type = "authorization_code"

# Global variables
clients = {}
symbol_to_clients = {}
active_subscriptions = set()
running = True
historical_data = {}
ohlc_data = {}
real_time_data = {}
MAX_HISTORY_POINTS = 10000
MAX_COMPANIES = 6
INDIA_TZ = pytz.timezone('Asia/Kolkata')
fyers = None
fyers_client = None
available_symbols = []
last_tick = {}

MONITORED_FIELDS = [
    'ltp', 'vol_traded_today', 'last_traded_time', 'bid_size', 'ask_size',
    'bid_price', 'ask_price', 'low_price', 'high_price', 'open_price', 'prev_close_price'
]

def load_available_symbols():
    """Load available symbols from watchlist A - optional, fallback to empty."""
    global available_symbols
    try:
        csv_path = os.path.join(os.path.dirname(__file__), 'data', 'watchlists', 'watchlist_A_2025-02-16.csv')
        
        # Try alternative paths if main path doesn't exist
        if not os.path.exists(csv_path):
            csv_path = 'apps/backend/data/watchlists/watchlist_A_2025-02-16.csv'
        
        if not os.path.exists(csv_path):
            # No hardcoded symbols - completely dynamic
            logger.info("No watchlist file found - operating in dynamic mode")
            available_symbols = []
            return True
        else:
            df = pd.read_csv(csv_path)
        
        available_symbols = []
        for _, row in df.iterrows():
            symbol_data = {
                'symbol': f"{row.get('Exchange', 'NSE')}:{row['company_code']}-{row.get('marker', 'EQ')}",
                'company_code': row['company_code'],
                'name': row.get('name', row['company_code']),
                'exchange': row.get('Exchange', 'NSE'),
                'marker': row.get('marker', 'EQ')
            }
            available_symbols.append(symbol_data)
        
        logger.info(f"Loaded {len(available_symbols)} available symbols from watchlist")
        return True
        
    except Exception as e:
        logger.error(f"Error loading symbols: {e}")
        # No fallback symbols - completely empty
        available_symbols = []
        logger.info("Operating in fully dynamic mode - no predefined symbols")
        return True

def get_trading_hours():
    """Get market trading hours in IST."""
    now = datetime.datetime.now(INDIA_TZ)
    start_time = now.replace(hour=9, minute=15, second=0, microsecond=0)
    end_time = now.replace(hour=15, minute=30, second=0, microsecond=0)
    return start_time, end_time

def is_trading_hours():
    """Check if current time is within trading hours."""
    now = datetime.datetime.now(INDIA_TZ)
    start_time, end_time = get_trading_hours()
    if now.weekday() >= 5:  # Saturday or Sunday
        return False
    return start_time <= now <= end_time

def safe_symbol_parse(symbol):
    """Safely parse symbol string to extract exchange and company code."""
    try:
        if ':' not in symbol:
            logger.warning(f"Invalid symbol format (no colon): {symbol}")
            return None, None
        
        parts = symbol.split(':', 1)
        if len(parts) != 2:
            logger.warning(f"Invalid symbol format: {symbol}")
            return None, None
            
        exchange = parts[0]
        code_part = parts[1]
        
        if '-' not in code_part:
            logger.warning(f"Invalid code part (no hyphen): {code_part}")
            return exchange, code_part
        
        company_code = code_part.split('-')[0]
        return exchange, company_code
        
    except Exception as e:
        logger.error(f"Error parsing symbol {symbol}: {e}")
        return None, None

def create_symbol_from_code(company_code, exchange='NSE', marker='EQ'):
    """Create a full Fyers symbol from company code."""
    return f"{exchange}:{company_code}-{marker}"

def add_symbol_to_available(company_code, exchange='NSE', marker='EQ', name=None):
    """Dynamically add a symbol to available symbols if not exists."""
    global available_symbols
    
    symbol = create_symbol_from_code(company_code, exchange, marker)
    
    # Check if symbol already exists
    existing = next((s for s in available_symbols if s['symbol'] == symbol), None)
    if not existing:
        symbol_data = {
            'symbol': symbol,
            'company_code': company_code,
            'name': name or company_code,
            'exchange': exchange,
            'marker': marker
        }
        available_symbols.append(symbol_data)
        logger.info(f"Dynamically added symbol: {symbol}")
        return symbol_data
    return existing

@sio.event
def connect(sid, environ):
    """Handle client connection."""
    logger.info(f"Client connected: {sid}")
    clients[sid] = {
        'subscriptions': set(),
        'connected_at': datetime.datetime.now(INDIA_TZ),
        'last_activity': datetime.datetime.now(INDIA_TZ)
    }
    
    # Send available symbols to client (may be empty initially)
    sio.emit('availableSymbols', {
        'symbols': available_symbols,
        'maxCompanies': MAX_COMPANIES,
        'tradingHours': {
            'isActive': is_trading_hours(),
            'start': get_trading_hours()[0].isoformat(),
            'end': get_trading_hours()[1].isoformat()
        }
    }, room=sid)

@sio.event
def disconnect(sid):
    """Handle client disconnection."""
    logger.info(f"Client disconnected: {sid}")
    if sid in clients:
        # Clean up subscriptions
        for symbol in clients[sid]['subscriptions']:
            if symbol in symbol_to_clients:
                symbol_to_clients[symbol].discard(sid)
                
                # If no more clients for this symbol, unsubscribe from Fyers
                if not symbol_to_clients[symbol]:
                    active_subscriptions.discard(symbol)
                    logger.info(f"Removed {symbol} from active subscriptions")
        
        del clients[sid]
    
    # Update Fyers subscription if needed
    update_fyers_subscription()

@sio.event
def subscribe_companies(sid, data):
    """FIXED: Subscribe to selected companies with enhanced validation."""
    try:
        logger.info(f"üì° Received subscription request from {sid}: {data}")
        
        # FIXED: Extract companyCodes from data
        company_codes = data.get('companyCodes', [])
        logger.info(f"üì° Raw company codes: {company_codes}")
        
        # FIXED: Validate data structure
        if not isinstance(company_codes, list):
            logger.error(f"‚ùå Invalid data type for companyCodes: {type(company_codes)}")
            sio.emit('error', {'message': 'companyCodes must be an array'}, room=sid)
            return
        
        # FIXED: Simplified validation - accept any non-empty string
        valid_company_codes = []
        for code in company_codes:
            if isinstance(code, str) and code.strip():
                valid_company_codes.append(code.strip().upper())
            else:
                logger.warning(f"‚ö†Ô∏è Skipping invalid company code: {code}")
        
        logger.info(f"‚úÖ Valid company codes after filtering: {valid_company_codes}")
        
        # FIXED: Check limits
        if len(valid_company_codes) > MAX_COMPANIES:
            logger.error(f"‚ùå Too many companies requested: {len(valid_company_codes)}")
            sio.emit('error', {'message': f'Maximum {MAX_COMPANIES} companies allowed'}, room=sid)
            return
        
        if len(valid_company_codes) == 0:
            logger.error(f"‚ùå No valid company codes provided")
            sio.emit('error', {'message': 'At least 1 valid company code must be provided'}, room=sid)
            return
        
        # FIXED: Clear existing subscriptions for this client
        if sid in clients:
            for symbol in clients[sid]['subscriptions']:
                if symbol in symbol_to_clients:
                    symbol_to_clients[symbol].discard(sid)
                    if not symbol_to_clients[symbol]:
                        active_subscriptions.discard(symbol)
            clients[sid]['subscriptions'].clear()
        
        # FIXED: Process valid company codes and create symbols
        requested_symbols = []
        for company_code in valid_company_codes:
            logger.info(f"üì° Processing company code: {company_code}")
            
            # Try to find in existing available symbols
            symbol_data = next(
                (s for s in available_symbols if s['company_code'] == company_code),
                None
            )
            
            if symbol_data:
                requested_symbols.append(symbol_data['symbol'])
                logger.info(f"‚úÖ Found existing symbol for {company_code}: {symbol_data['symbol']}")
            else:
                # Dynamically create symbol
                new_symbol_data = add_symbol_to_available(company_code)
                requested_symbols.append(new_symbol_data['symbol'])
                logger.info(f"‚úÖ Dynamically created symbol for {company_code}: {new_symbol_data['symbol']}")
        
        logger.info(f"üì° Final requested symbols: {requested_symbols}")
        
        # FIXED: Update client subscriptions
        if sid not in clients:
            clients[sid] = {
                'subscriptions': set(),
                'connected_at': datetime.datetime.now(INDIA_TZ),
                'last_activity': datetime.datetime.now(INDIA_TZ)
            }
        
        # Add symbols to client subscriptions
        for symbol in requested_symbols:
            clients[sid]['subscriptions'].add(symbol)
            
            # Add to symbol_to_clients mapping
            if symbol not in symbol_to_clients:
                symbol_to_clients[symbol] = set()
            symbol_to_clients[symbol].add(sid)
            
            # Add to active subscriptions
            active_subscriptions.add(symbol)
            logger.info(f"‚úÖ Added {symbol} to active subscriptions")
        
        # FIXED: Update Fyers subscription
        update_fyers_subscription()
        
        # FIXED: Send historical data for each symbol
        for symbol in requested_symbols:
            # Send any existing historical data
            if symbol in historical_data and historical_data[symbol]:
                sio.emit('historicalData', {
                    'symbol': symbol,
                    'data': list(historical_data[symbol])
                }, room=sid)
            else:
                # Fetch historical data on demand
                logger.info(f"üìä Fetching historical data for {symbol}")
                hist_data = fetch_historical_intraday_data(symbol)
                if hist_data:
                    if symbol not in historical_data:
                        historical_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)
                    
                    for data_point in hist_data:
                        historical_data[symbol].append(data_point)
                    
                    sio.emit('historicalData', {
                        'symbol': symbol,
                        'data': hist_data
                    }, room=sid)
        
        # FIXED: Send subscription confirmation
        sio.emit('subscriptionConfirm', {
            'success': True,
            'symbols': requested_symbols,
            'count': len(requested_symbols)
        }, room=sid)
        
        logger.info(f"‚úÖ Successfully subscribed client {sid} to {len(requested_symbols)} symbols")
        
    except Exception as e:
        logger.error(f"‚ùå Error in subscribe_companies: {e}")
        import traceback
        traceback.print_exc()
        sio.emit('error', {'message': f'Subscription failed: {str(e)}'}, room=sid)

@sio.event
def unsubscribe_all(sid, data):
    """Unsubscribe from all companies."""
    try:
        logger.info(f"üì° Unsubscribing all for client {sid}")
        
        if sid in clients:
            for symbol in clients[sid]['subscriptions']:
                if symbol in symbol_to_clients:
                    symbol_to_clients[symbol].discard(sid)
                    if not symbol_to_clients[symbol]:
                        active_subscriptions.discard(symbol)
            
            clients[sid]['subscriptions'].clear()
        
        update_fyers_subscription()
        
        sio.emit('subscriptionConfirm', {
            'success': True,
            'symbols': [],
            'count': 0
        }, room=sid)
        
        logger.info(f"‚úÖ Client {sid} unsubscribed from all symbols")
        
    except Exception as e:
        logger.error(f"‚ùå Error in unsubscribe_all: {e}")
        sio.emit('error', {'message': f'Unsubscription failed: {str(e)}'}, room=sid)

@sio.event
def get_market_status(sid, data):
    """Get current market status."""
    try:
        start_time, end_time = get_trading_hours()
        sio.emit('marketStatus', {
            'trading_active': is_trading_hours(),
            'trading_start': start_time.isoformat(),
            'trading_end': end_time.isoformat(),
            'current_time': datetime.datetime.now(INDIA_TZ).isoformat(),
            'is_market_day': datetime.datetime.now(INDIA_TZ).weekday() < 5,
            'active_subscriptions': len(active_subscriptions),
            'connected_clients': len(clients)
        }, room=sid)
    except Exception as e:
        logger.error(f"‚ùå Error in get_market_status: {e}")
        sio.emit('error', {'message': f'Failed to get market status: {str(e)}'}, room=sid)

def update_fyers_subscription():
    """Update Fyers WebSocket subscription based on active subscriptions."""
    if not fyers:
        logger.warning("Fyers not initialized, cannot update subscription")
        return
    
    try:
        current_symbols = list(active_subscriptions)
        if current_symbols:
            logger.info(f"üîÑ Updating Fyers subscription with {len(current_symbols)} symbols")
            fyers.subscribe(symbols=current_symbols, data_type="SymbolUpdate")
            logger.info(f"‚úÖ Updated Fyers subscription: {current_symbols}")
        else:
            logger.info("üì° No active subscriptions, keeping minimal connection")
    except Exception as e:
        logger.error(f"‚ùå Error updating Fyers subscription: {e}")

def fetch_historical_intraday_data(symbol, date=None):
    """Fetch historical intraday data for a symbol on demand."""
    if not date:
        date = datetime.datetime.now(INDIA_TZ).strftime('%Y-%m-%d')
    
    try:
        date_obj = datetime.datetime.strptime(date, '%Y-%m-%d')
        date_obj = INDIA_TZ.localize(date_obj)
        
        market_open = date_obj.replace(hour=9, minute=15, second=0, microsecond=0)
        market_close = date_obj.replace(hour=15, minute=30, second=0, microsecond=0)
        
        now = datetime.datetime.now(INDIA_TZ)
        if date == now.strftime('%Y-%m-%d') and now < market_open:
            logger.info(f"Market not yet open for {date}")
            return []
        
        end_time = min(now, market_close) if date == now.strftime('%Y-%m-%d') else market_close
        
        from_date = market_open.strftime('%Y-%m-%d %H:%M:%S')
        to_date = end_time.strftime('%Y-%m-%d %H:%M:%S')
        
        logger.info(f"üìä Fetching historical data for {symbol} from {from_date} to {to_date}")
        
        if fyers_client:
            data_args = {
                "symbol": symbol,
                "resolution": "1",
                "date_format": "1",
                "range_from": from_date,
                "range_to": to_date,
                "cont_flag": "1"
            }
            
            response = fyers_client.history(data_args)
            
            if response and response.get('s') == 'ok' and 'candles' in response:
                candles = response['candles']
                logger.info(f"‚úÖ Received {len(candles)} candles for {symbol}")
                
                result = []
                
                for candle in candles:
                    timestamp, open_price, high_price, low_price, close_price, volume = candle
                    
                    if timestamp > 10000000000:
                        timestamp = timestamp // 1000
                    
                    data_point = {
                        'symbol': symbol,
                        'ltp': close_price,
                        'open': open_price,
                        'high': high_price,
                        'low': low_price,
                        'close': close_price,
                        'volume': volume,
                        'timestamp': timestamp,
                        'change': 0,
                        'changePercent': 0
                    }
                    
                    result.append(data_point)
                
                # Calculate change and change percent
                if result:
                    prev_close = result[0]['open']
                    for point in result:
                        point['change'] = point['ltp'] - prev_close
                        point['changePercent'] = (point['change'] / prev_close) * 100 if prev_close else 0
                
                return result
            else:
                logger.error(f"‚ùå Failed to fetch historical data for {symbol}: {response}")
        
        return []
        
    except Exception as e:
        logger.error(f"‚ùå Error fetching historical data for {symbol}: {e}")
        return []

def onmessage(message):
    """Handle incoming Fyers WebSocket messages."""
    try:
        # Skip system messages
        if isinstance(message, dict) and message.get('type') == 'sub':
            logger.info(f"üì° Subscription confirmation: {message}")
            return
        
        if isinstance(message, dict) and message.get('type') in ['cn', 'ful']:
            logger.info(f"üì° Connection message: {message}")
            return
        
        # Process market data
        if isinstance(message, dict) and 'symbol' in message:
            symbol = message['symbol']
            
            # Only process if symbol is actively subscribed
            if symbol not in active_subscriptions:
                return
            
            # FIXED: Prepare enhanced market data
            simplified_data = {
                'symbol': symbol,
                'ltp': message.get('ltp'),
                'change': message.get('ch'),
                'changePercent': message.get('chp'),
                'open': message.get('open_price'),
                'high': message.get('high_price'),
                'low': message.get('low_price'),
                'close': message.get('prev_close_price'),
                'volume': message.get('vol_traded_today'),
                'bid': message.get('bid_price'),
                'ask': message.get('ask_price'),
                'timestamp': message.get('last_traded_time') or int(time.time())
            }
            
            # Store real-time data
            real_time_data[symbol] = simplified_data
            
            # Store historical data
            if symbol not in historical_data:
                historical_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)
            
            historical_data[symbol].append(simplified_data)
            
            # FIXED: Emit to subscribed clients only
            if symbol in symbol_to_clients:
                for sid in symbol_to_clients[symbol]:
                    try:
                        sio.emit('marketData', simplified_data, room=sid)
                    except Exception as e:
                        logger.error(f"‚ùå Error sending data to client {sid}: {e}")
            
            logger.debug(f"üìà Processed market data for {symbol}: LTP={simplified_data['ltp']}")
            
    except Exception as e:
        logger.error(f"‚ùå Error processing message: {e}")

def save_to_file(symbol, data):
    """Save market data to daily files."""
    try:
        exchange, company_code = safe_symbol_parse(symbol)
        
        if exchange and company_code:
            now = datetime.datetime.now(INDIA_TZ)
            folder = f"LD_{now.strftime('%d-%m-%Y')}"
            os.makedirs(folder, exist_ok=True)
            file_name = f"{company_code}-{exchange}.json"
            file_path = os.path.join(folder, file_name)
            
            with open(file_path, 'a') as f:
                json.dump(data, f)
                f.write('\n')
                
    except Exception as e:
        logger.error(f"‚ùå Error saving to file: {e}")

def onopen():
    """Handle Fyers WebSocket connection opening."""
    logger.info("‚úÖ Fyers WebSocket connected")
    sio.emit('fyersConnected', {'status': 'connected'})
    
    # No default subscriptions - wait for client requests
    logger.info("üì° Fyers connection established, ready for dynamic subscriptions")

def onerror(error):
    """Handle Fyers WebSocket errors."""
    logger.error(f"‚ùå Fyers WebSocket Error: {error}")
    sio.emit('fyersError', {'message': str(error)})

def onclose(message):
    """Handle Fyers WebSocket connection closure."""
    logger.info(f"‚ùå Fyers WebSocket Connection closed: {message}")
    sio.emit('fyersDisconnected', {'message': str(message)})

def heartbeat_task():
    """Send periodic heartbeat to clients."""
    global running
    while running:
        try:
            heartbeat_data = {
                'timestamp': int(time.time()),
                'trading_active': is_trading_hours(),
                'active_subscriptions': len(active_subscriptions),
                'connected_clients': len(clients),
                'server_status': 'healthy'
            }
            sio.emit('heartbeat', heartbeat_data)
            time.sleep(30)  # Send heartbeat every 30 seconds
        except Exception as e:
            logger.error(f"‚ùå Error in heartbeat: {e}")
            time.sleep(30)

def main_process():
    """Main process to authenticate and start WebSocket connection."""
    global fyers, fyers_client, running
    
    # Load available symbols (optional, may result in empty list)
    load_available_symbols()
    
    # No preloading of historical data - completely on-demand
    logger.info("üöÄ Backend initialized in dynamic mode - no preloading")
    
    try:
        # Fyers Authentication
        session = fyersModel.SessionModel(
            client_id=client_id,
            secret_key=secret_key,
            redirect_uri=redirect_uri,
            response_type=response_type,
            grant_type=grant_type
        )
        
        auth_url = session.generate_authcode()
        logger.info("\n==== Fyers Authentication ====")
        logger.info("Open this URL in your browser and log in:")
        logger.info(auth_url)
        
        auth_code = input("\nEnter Auth Code: ")
        session.set_token(auth_code)
        token_response = session.generate_token()
        
        if token_response.get('s') != 'ok':
            logger.error(f"‚ùå Authentication failed: {token_response}")
            return
        
        logger.info("‚úÖ Authentication successful!")
        access_token = f"{client_id}:{token_response['access_token']}"
        
        fyers_client = fyersModel.FyersModel(
            client_id=client_id,
            token=token_response['access_token'],
            log_path=""
        )
        
        fyers = data_ws.FyersDataSocket(
            access_token=access_token,
            log_path="",
            litemode=False,
            write_to_file=False,
            reconnect=True,
            on_connect=onopen,
            on_close=onclose,
            on_error=onerror,
            on_message=onmessage
        )
        
        # Start heartbeat task
        heartbeat_thread = threading.Thread(target=heartbeat_task, daemon=True)
        heartbeat_thread.start()
        
        # Connect to Fyers
        fyers.connect()
        logger.info("‚úÖ Connected to Fyers WebSocket")
        
        # Start server
        logger.info("üöÄ Starting Live Market Server on port 5010...")
        eventlet.wsgi.server(eventlet.listen(('0.0.0.0', 5010)), app)
        
    except Exception as e:
        logger.error(f"‚ùå Error in main process: {e}")
        import traceback
        traceback.print_exc()

def main():
    global running
    try:
        eventlet.spawn(main_process)
        while running:
            time.sleep(1)
    except KeyboardInterrupt:
        logger.info("üõë Shutting down...")
        running = False

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logger.info("üõë Shutting down...")
        running = False


================================================================================
FILE: apps/backend/new_fyers.py
PURPOSE: New Fyers authentication implementation
================================================================================

import eventlet
eventlet.monkey_patch()

import socketio
import json
import sys
import time
import datetime
import pytz
import threading
import logging
import requests
import numpy as np
import os
from collections import deque
from fyers_apiv3 import fyersModel
from fyers_apiv3.FyersWebsocket import data_ws
import pandas as pd

# Logging configuration
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
)
logger = logging.getLogger("FyersServer")

# Socket.IO setup
sio = socketio.Server(cors_allowed_origins='*', async_mode='eventlet')
app = socketio.WSGIApp(sio)

# Fyers API credentials
client_id = "150HUKJSWG-100"
secret_key = "18YYNXCAS7"
redirect_uri = "https://daksphere.com/"
response_type = "code"
grant_type = "authorization_code"

# Global variables
clients = {}
symbol_to_clients = {}
running = True
historical_data = {}
ohlc_data = {}
MAX_HISTORY_POINTS = 10000
INDIA_TZ = pytz.timezone('Asia/Kolkata')
fyers = None
fyers_client = None
symbols = []
last_tick = {}
MONITORED_FIELDS = [
    'ltp', 'vol_traded_today', 'last_traded_time', 'bid_size', 'ask_size',
    'bid_price', 'ask_price', 'low_price', 'high_price', 'open_price', 'prev_close_price'
]

def load_symbols():
    """Load symbols from NSE_list.csv."""
    global symbols
    try:
        # df = pd.read_csv('NSE_list.csv')
        df = pd.read_csv(os.path.join(os.path.dirname(__file__), 'data', 'watchlists', 'watchlist_A_2025-06-05.csv'))

        symbols = [f"{row['Exchange']}:{row['company_code']}-EQ" for index, row in df.iterrows()]
        logger.info(f"Loaded {len(symbols)} symbols from NSE_list.csv")
    except Exception as e:
        logger.error(f"Error loading symbols: {e}")
        symbols = []

def get_trading_hours():
    """Get market trading hours in IST."""
    now = datetime.datetime.now(INDIA_TZ)
    start_time = now.replace(hour=9, minute=15, second=0, microsecond=0)
    end_time = now.replace(hour=15, minute=30, second=0, microsecond=0)
    return start_time, end_time

def is_trading_hours():
    """Check if current time is within trading hours."""
    now = datetime.datetime.now(INDIA_TZ)
    start_time, end_time = get_trading_hours()
    if now.weekday() >= 5:  # Saturday or Sunday
        return False
    return start_time <= now <= end_time

def safe_symbol_parse(symbol):
    """Safely parse symbol string to extract exchange and company code."""
    try:
        if ':' not in symbol:
            logger.warning(f"Invalid symbol format (no colon): {symbol}")
            return None, None
        
        parts = symbol.split(':', 1)  # Split only on first colon
        if len(parts) != 2:
            logger.warning(f"Invalid symbol format: {symbol}")
            return None, None
            
        exchange = parts[0]
        code_part = parts[1]
        
        if '-' not in code_part:
            logger.warning(f"Invalid code part (no hyphen): {code_part}")
            return exchange, code_part  # Return what we have
        
        company_code = code_part.split('-')[0]  # Take first part before hyphen
        return exchange, company_code
        
    except Exception as e:
        logger.error(f"Error parsing symbol {symbol}: {e}")
        return None, None

@sio.event
def connect(sid, environ):
    logger.info(f"Client connected: {sid}")
    clients[sid] = {'subscriptions': set()}

@sio.event
def disconnect(sid):
    logger.info(f"Client disconnected: {sid}")
    if sid in clients:
        for symbol in clients[sid]['subscriptions']:
            if symbol in symbol_to_clients:
                symbol_to_clients[symbol].discard(sid)
        del clients[sid]

def fetch_historical_intraday_data(symbol, date=None):
    """Fetch historical intraday data for a symbol."""
    if not date:
        date = datetime.datetime.now(INDIA_TZ).strftime('%Y-%m-%d')
    
    try:
        date_obj = datetime.datetime.strptime(date, '%Y-%m-%d')
        date_obj = INDIA_TZ.localize(date_obj)
        
        market_open = date_obj.replace(hour=9, minute=15, second=0, microsecond=0)
        market_close = date_obj.replace(hour=15, minute=30, second=0, microsecond=0)
        
        now = datetime.datetime.now(INDIA_TZ)
        if date == now.strftime('%Y-%m-%d') and now < market_open:
            logger.info(f"Market not yet open for {date}")
            return []
        
        if date == now.strftime('%Y-%m-%d') and now < market_close:
            end_time = now
        else:
            end_time = market_close
        
        from_date = market_open.strftime('%Y-%m-%d %H:%M:%S')
        to_date = end_time.strftime('%Y-%m-%d %H:%M:%S')
        
        logger.info(f"Fetching historical data for {symbol} from {from_date} to {to_date}")
        
        if fyers_client:
            data_args = {
                "symbol": symbol,
                "resolution": "1",
                "date_format": "1",
                "range_from": from_date,
                "range_to": to_date,
                "cont_flag": "1"
            }
            
            response = fyers_client.history(data_args)
            
            if response and response.get('s') == 'ok' and 'candles' in response:
                candles = response['candles']
                logger.info(f"Received {len(candles)} candles for {symbol}")
                
                result = []
                
                for candle in candles:
                    timestamp, open_price, high_price, low_price, close_price, volume = candle
                    
                    if timestamp > 10000000000:
                        timestamp = timestamp // 1000
                    
                    data_point = {
                        'symbol': symbol,
                        'ltp': close_price,
                        'open': open_price,
                        'high': high_price,
                        'low': low_price,
                        'close': close_price,
                        'volume': volume,
                        'timestamp': timestamp,
                        'change': 0,
                        'changePercent': 0
                    }
                    
                    result.append(data_point)
                    
                    if symbol not in ohlc_data:
                        ohlc_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)
                    
                    minute_timestamp = (timestamp // 60) * 60
                    
                    ohlc_candle = {
                        'timestamp': minute_timestamp,
                        'open': open_price,
                        'high': high_price,
                        'low': low_price,
                        'close': close_price,
                        'volume': volume
                    }
                    
                    if not ohlc_data[symbol] or ohlc_data[symbol][-1]['timestamp'] != minute_timestamp:
                        ohlc_data[symbol].append(ohlc_candle)
                
                if result:
                    prev_close = result[0]['open']
                    for point in result:
                        point['change'] = point['ltp'] - prev_close
                        point['changePercent'] = (point['change'] / prev_close) * 100 if prev_close else 0
                
                return result
            else:
                logger.error(f"Failed to fetch historical data: {response}")
        
        logger.warning(f"Fyers client not initialized or API call failed for {symbol}")
        return []
        
    except Exception as e:
        logger.error(f"Error fetching historical data: {e}")
        import traceback
        traceback.print_exc()
        return []

def onmessage(message):
    """Handle incoming WebSocket messages and append updates to JSON files."""
    logger.debug(f"Response: {message}")
    
    # Handle subscription confirmations
    if isinstance(message, dict) and message.get('type') == 'sub':
        logger.info(f"Subscription confirmation: {message}")
        return
    
    # Handle connection messages
    if isinstance(message, dict) and message.get('type') in ['cn', 'ful']:
        logger.info(f"Connection message: {message}")
        return
    
    if isinstance(message, dict) and 'symbol' in message:
        symbol = message['symbol']
        
        # Prepare simplified data with all monitored fields
        simplified_data = {
            'symbol': symbol,
            'ltp': message.get('ltp'),
            'vol_traded_today': message.get('vol_traded_today'),
            'last_traded_time': message.get('last_traded_time'),
            'bid_size': message.get('bid_size'),
            'ask_size': message.get('ask_size'),
            'bid_price': message.get('bid_price'),
            'ask_price': message.get('ask_price'),
            'low_price': message.get('low_price'),
            'high_price': message.get('high_price'),
            'open_price': message.get('open_price'),
            'prev_close_price': message.get('prev_close_price'),
            'timestamp': message.get('last_traded_time') or int(time.time())
        }
        
        # Safely parse symbol for file naming
        exchange, company_code = safe_symbol_parse(symbol)
        
        if exchange and company_code:
            # Determine file path
            now = datetime.datetime.now(INDIA_TZ)
            folder = f"LD_{now.strftime('%d-%m-%Y')}"
            os.makedirs(folder, exist_ok=True)
            file_name = f"{company_code}-{exchange}.json"
            file_path = os.path.join(folder, file_name)
            
            # Check for updates in monitored fields
            should_append = (symbol not in last_tick or 
                             any(simplified_data[field] != last_tick[symbol].get(field) 
                                 for field in MONITORED_FIELDS if field in simplified_data))
            
            if should_append:
                try:
                    with open(file_path, 'a') as f:
                        json.dump(simplified_data, f)
                        f.write('\n')
                    logger.debug(f"Appended data to {file_path}")
                    last_tick[symbol] = simplified_data.copy()
                except Exception as e:
                    logger.error(f"Error writing to file {file_path}: {e}")
        else:
            logger.warning(f"Could not parse symbol for file naming: {symbol}")
        
        # Emit to subscribed clients
        if symbol in symbol_to_clients:
            for sid in symbol_to_clients[symbol]:
                try:
                    sio.emit('marketData', simplified_data, room=sid)
                except Exception as e:
                    logger.error(f"Error sending data to client {sid}: {e}")
        else:
            logger.debug(f"No clients subscribed to {symbol}")
    else:
        logger.warning(f"Invalid message format: {message}")

def onopen():
    """Handle WebSocket connection opening and subscribe to all symbols."""
    logger.info("Fyers WebSocket connected")
    sio.emit('fyersConnected', {'status': 'connected'})
    
    if symbols:
        try:
            fyers.subscribe(symbols=symbols, data_type="SymbolUpdate")
            logger.info(f"Subscribed to {len(symbols)} symbols")
        except Exception as e:
            logger.error(f"Error subscribing to symbols: {e}")
    else:
        logger.warning("No symbols loaded for subscription")

def onerror(error):
    logger.error(f"WebSocket Error: {error}")
    sio.emit('error', {'message': str(error)})

def onclose(message):
    logger.info(f"WebSocket Connection closed: {message}")
    sio.emit('fyersDisconnected', {'message': str(message)})

def main_process():
    """Main process to authenticate and start WebSocket connection."""
    global fyers, fyers_client, running
    
    # Load symbols at startup
    load_symbols()
    
    if not symbols:
        logger.error("No symbols loaded. Please check NSE_list.csv file.")
        return
    
    try:
        # Authentication
        session = fyersModel.SessionModel(
            client_id=client_id,
            secret_key=secret_key,
            redirect_uri=redirect_uri,
            response_type=response_type,
            grant_type=grant_type
        )
        
        auth_url = session.generate_authcode()
        logger.info("\n==== Fyers Authentication ====")
        logger.info("Open this URL in your browser and log in:")
        logger.info(auth_url)
        
        auth_code = input("\nEnter Auth Code: ")
        session.set_token(auth_code)
        token_response = session.generate_token()
        
        if token_response.get('s') != 'ok':
            logger.error(f"Authentication failed: {token_response}")
            return
            
        logger.info("Authentication successful!")
        access_token = f"{client_id}:{token_response['access_token']}"
        
        fyers_client = fyersModel.FyersModel(
            client_id=client_id,
            token=token_response['access_token'],
            log_path=""
        )
        
        fyers = data_ws.FyersDataSocket(
            access_token=access_token,
            log_path="",
            litemode=False,
            write_to_file=False,
            reconnect=True,
            on_connect=onopen,
            on_close=onclose,
            on_error=onerror,
            on_message=onmessage
        )
        
        fyers.connect()
        logger.info("Connected to Fyers WebSocket")
        
        logger.info("Starting Socket.IO server on port 5010...")
        eventlet.wsgi.server(eventlet.listen(('0.0.0.0', 5010)), app)
        
    except Exception as e:
        logger.error(f"Error in main process: {e}")
        import traceback
        traceback.print_exc()

def main():
    global running
    try:
        eventlet.spawn(main_process)
        while running:
            time.sleep(1)
    except KeyboardInterrupt:
        logger.info("Shutting down...")
        running = False

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logger.info("Shutting down...")
        running = False

################################################################################
SECTION 2: BACKEND AUTH CONFIGURATION
################################################################################

================================================================================
FILE: apps/backend/src/config/fyers.config.ts
PURPOSE: Fyers configuration settings and OAuth parameters
================================================================================

export const fyersConfig = {
    clientId: process.env.FYERS_CLIENT_ID || '',
    secretId: process.env.FYERS_SECRET_ID || '',
    redirectUri: process.env.FYERS_REDIRECT_URI || 'http://127.0.0.1:5000',
    responseType: 'code',
    state: 'fyers',
    grantType: 'authorization_code',
  };
  

================================================================================
FILE: apps/backend/src/market-data/services/fyers-auth.service.ts
PURPOSE: Fyers authentication service implementation
================================================================================

// src/market-data/services/fyers-auth.service.ts
import { Injectable, Logger } from '@nestjs/common';
import * as readline from 'readline';
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import axios from 'axios';

@Injectable()
export class FyersAuthService {
  private readonly logger = new Logger(FyersAuthService.name);
  private accessToken: string | null = null;
  private clientId: string;
  private secretKey: string;
  private redirectUri: string;

  constructor() {
    this.clientId = process.env.FYERS_CLIENT_ID || '';
    this.secretKey = process.env.FYERS_SECRET_ID || '';
    this.redirectUri = process.env.FYERS_REDIRECT_URI || 'https://daksphere.com/';
  }

  async getAccessToken(): Promise<string> {
    // Check if we already have a valid token
    const tokenPath = path.join(process.cwd(), 'data', 'access_token.json');
    
    try {
      if (fs.existsSync(tokenPath)) {
        const tokenData = JSON.parse(fs.readFileSync(tokenPath, 'utf8'));
        if (tokenData.expiry && new Date(tokenData.expiry) > new Date()) {
          this.logger.log('Using existing access token');
          this.accessToken = tokenData.token;
          return `${this.clientId}:${this.accessToken}`;
        }
      }
    } catch (error) {
      this.logger.error('Error reading token file:', error.message);
    }

    // Generate new token
    return await this.generateNewToken();
  }

  private async generateNewToken(): Promise<string> {
    try {
      // Generate auth URL
      const authUrl = `https://api-t1.fyers.in/api/v3/generate-authcode?client_id=${this.clientId}&redirect_uri=${encodeURIComponent(this.redirectUri)}&response_type=code&state=None`;
      
      console.log('\n==== Fyers Authentication ====');
      console.log('Open this URL in your browser and log in:');
      console.log(authUrl);
      
      // Create readline interface for terminal input
      const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
      });

      // Get auth code from user (single line input)
      const authCode = await new Promise<string>((resolve) => {
        rl.question('\nEnter the auth code from the redirect URL: ', (answer) => {
          resolve(answer.trim());
          rl.close();
        });
      });

      // Generate appIdHash
      const appIdHash = `${this.secretKey}:${this.clientId}`;

      // Exchange auth code for access token
      const response = await axios.post('https://api-t1.fyers.in/api/v3/validate-authcode', {
        grant_type: 'authorization_code',
        appIdHash: appIdHash,
        code: authCode
      });

      if (response.data && response.data.s === 'ok') {
        this.accessToken = response.data.access_token;
        
        // Save token for future use
        const expiryDate = new Date();
        expiryDate.setHours(expiryDate.getHours() + 24); // Token valid for 24 hours
        
        const tokenDir = path.join(process.cwd(), 'data');
        if (!fs.existsSync(tokenDir)) {
          fs.mkdirSync(tokenDir, { recursive: true });
        }
        
        fs.writeFileSync(
          path.join(tokenDir, 'access_token.json'),
          JSON.stringify({
            token: this.accessToken,
            expiry: expiryDate.toISOString()
          })
        );
        
        this.logger.log('New access token generated and saved');
        return `${this.clientId}:${this.accessToken}`;
      } else {
        throw new Error(`Failed to generate token: ${JSON.stringify(response.data)}`);
      }
    } catch (error) {
      this.logger.error('Error generating token:', error.message);
      throw new Error('Failed to authenticate with Fyers');
    }
  }
}


################################################################################
SECTION 3: FRONTEND DATA HOOKS
################################################################################

================================================================================
FILE: apps/frontend/hooks/useMarketData.ts
PURPOSE: Market data hook with authentication handling
================================================================================

import { useState, useEffect, useCallback } from 'react';
import { getSocket } from '../lib/socket';

interface MarketData {
  ltp: number;
  change: number;
  changePercent: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
  timestamp: number;
}

interface UseMarketDataReturn {
  data: Record<string, MarketData>;
  isLoading: boolean;
  error: Error | null;
  subscribeToSymbol: (symbol: string) => void;
  unsubscribeFromSymbol: (symbol: string) => void;
}

export const useMarketData = (initialSymbols: string[] = []): UseMarketDataReturn => {
  const [data, setData] = useState<Record<string, MarketData>>({});
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<Error | null>(null);
  const [subscribedSymbols, setSubscribedSymbols] = useState<Set<string>>(
    new Set(initialSymbols)
  );

  const subscribeToSymbol = useCallback((symbol: string) => {
    setSubscribedSymbols((prev) => {
      const newSet = new Set(prev);
      newSet.add(symbol);
      return newSet;
    });
    
    getSocket().emit('subscribe', { symbol });
  }, []);

  const unsubscribeFromSymbol = useCallback((symbol: string) => {
    setSubscribedSymbols((prev) => {
      const newSet = new Set(prev);
      newSet.delete(symbol);
      return newSet;
    });
    
    getSocket().emit('unsubscribe', { symbol });
    
    setData((prev) => {
      const newData = { ...prev };
      delete newData[symbol];
      return newData;
    });
  }, []);

  useEffect(() => {
    const socket = getSocket();
    
    const handleMarketData = (message: { symbol: string; data: MarketData }) => {
      setData((prev) => ({
        ...prev,
        [message.symbol]: message.data,
      }));
      
      setIsLoading(false);
    };
    
    socket.on('marketData', handleMarketData);
    
    initialSymbols.forEach((symbol) => {
      socket.emit('subscribe', { symbol });
    });
    
    return () => {
      socket.off('marketData', handleMarketData);
      
      subscribedSymbols.forEach((symbol) => {
        socket.emit('unsubscribe', { symbol });
      });
    };
  }, [initialSymbols]);

  return {
    data,
    isLoading,
    error,
    subscribeToSymbol,
    unsubscribeFromSymbol,
  };
};


================================================================================
FILE: apps/frontend/hooks/useLiveMarket.ts
PURPOSE: Live market data hook with auth flow
================================================================================

import { useState, useEffect, useCallback, useRef } from 'react';
import { io, Socket } from 'socket.io-client';

interface Company {
  company_code: string;
  name: string;
  exchange: string;
  marker: string;
  symbol: string;
}

interface MarketData {
  symbol: string;
  ltp: number;
  change?: number;
  changePercent?: number;
  open?: number;
  high?: number;
  low?: number;
  close?: number;
  volume?: number;
  timestamp: number;
  bid?: number;
  ask?: number;
}

interface MarketStatus {
  trading_active: boolean;
  trading_start: string;
  trading_end: string;
  current_time: string;
  is_market_day: boolean;
  active_subscriptions: number;
  connected_clients: number;
}

interface TradingHours {
  isActive: boolean;
  start: string;
  end: string;
}

interface AvailableSymbolsData {
  symbols: Company[];
  maxCompanies: number;
  tradingHours: TradingHours;
}

interface SubscriptionConfirm {
  success: boolean;
  symbols: string[];
  count: number;
}

interface HistoricalData {
  symbol: string;
  data: MarketData[];
}

type ConnectionStatus = 'Connecting' | 'Connected' | 'Disconnected' | 'Reconnecting' | 'Error';

// Helper function to validate company object
const isValidCompany = (company: any): company is Company => {
  return (
    company &&
    typeof company === 'object' &&
    typeof company.company_code === 'string' &&
    company.company_code.trim() !== '' &&
    company.company_code !== 'null' &&
    company.company_code !== 'undefined'
  );
};

// Helper function to validate company code
const isValidCompanyCode = (code: any): code is string => {
  return (
    typeof code === 'string' &&
    code.trim() !== '' &&
    code !== 'null' &&
    code !== 'undefined' &&
    code !== null &&
    code !== undefined
  );
};

export const useLiveMarket = () => {
  // State management
  const [availableCompanies, setAvailableCompanies] = useState<Company[]>([]);
  const [selectedCompanies, setSelectedCompanies] = useState<Company[]>([]);
  const [marketData, setMarketData] = useState<Record<string, MarketData>>({});
  const [historicalData, setHistoricalData] = useState<Record<string, MarketData[]>>({});
  const [marketStatus, setMarketStatus] = useState<MarketStatus | null>(null);
  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>('Disconnected');
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [isConnected, setIsConnected] = useState<boolean>(false);
  const [maxCompanies, setMaxCompanies] = useState<number>(6);
  const [tradingHours, setTradingHours] = useState<TradingHours | null>(null);

  // Refs for tracking state
  const socketRef = useRef<Socket | null>(null);
  const subscribedCompanyCodes = useRef<Set<string>>(new Set());
  const reconnectAttempts = useRef<number>(0);
  const maxReconnectAttempts = 5;

  const initializeSocket = useCallback(() => {
    const SOCKET_URL = process.env.NEXT_PUBLIC_LIVE_MARKET_SOCKET_URL || 'http://localhost:5010';
    
    console.log(`üîå Connecting to Live Market WebSocket: ${SOCKET_URL}`);
    setConnectionStatus('Connecting');
    
    const socket = io(SOCKET_URL, {
      reconnectionAttempts: maxReconnectAttempts,
      reconnectionDelay: 2000,
      reconnectionDelayMax: 10000,
      timeout: 10000,
      transports: ['websocket', 'polling'],
      forceNew: true
    });

    // Connection events
    socket.on('connect', () => {
      console.log('‚úÖ Connected to Live Market WebSocket');
      setConnectionStatus('Connected');
      setIsConnected(true);
      setError(null);
      reconnectAttempts.current = 0;
    });

    socket.on('disconnect', (reason) => {
      console.log('‚ùå Disconnected from Live Market WebSocket:', reason);
      setConnectionStatus('Disconnected');
      setIsConnected(false);
      
      if (reason === 'io server disconnect') {
        setConnectionStatus('Reconnecting');
      }
    });

    socket.on('connect_error', (error) => {
      console.error('‚ùå Live Market WebSocket connection error:', error);
      setConnectionStatus('Error');
      setIsConnected(false);
      setError(`Connection failed: ${error.message}`);
      
      reconnectAttempts.current++;
      if (reconnectAttempts.current >= maxReconnectAttempts) {
        setError('Max reconnection attempts reached. Please refresh the page.');
      }
    });

    socket.on('reconnect_attempt', (attemptNumber) => {
      console.log(`üîÑ Reconnection attempt ${attemptNumber}`);
      setConnectionStatus('Reconnecting');
    });

    socket.on('reconnect', (attemptNumber) => {
      console.log(`‚úÖ Reconnected after ${attemptNumber} attempts`);
      setConnectionStatus('Connected');
      setIsConnected(true);
      setError(null);
      reconnectAttempts.current = 0;
    });

    // Handle availableSymbols event from backend
    socket.on('availableSymbols', (data: AvailableSymbolsData) => {
      console.log('üìä Received available symbols:', data);
      
      // Filter out invalid symbols from backend
      const validSymbols = (data.symbols || []).filter(symbol => 
        symbol && 
        symbol.company_code && 
        symbol.company_code !== 'null' && 
        symbol.company_code !== null
      );
      
      setAvailableCompanies(validSymbols);
      setMaxCompanies(data.maxCompanies || 6);
      setTradingHours(data.tradingHours || null);
    });

    // Handle marketData event from backend
    socket.on('marketData', (data: MarketData) => {
      console.log('üìà Received market data:', data);
      setMarketData(prev => ({
        ...prev,
        [data.symbol]: {
          ...prev[data.symbol],
          ...data,
          timestamp: data.timestamp || Date.now()
        }
      }));
    });

    // Handle historicalData event from backend
    socket.on('historicalData', (data: HistoricalData) => {
      console.log('üìâ Received historical data:', data);
      setHistoricalData(prev => ({
        ...prev,
        [data.symbol]: data.data
      }));
    });

    // Handle subscriptionConfirm event from backend
    socket.on('subscriptionConfirm', (data: SubscriptionConfirm) => {
      console.log('‚úÖ Subscription confirmed:', data);
      setLoading(false);
      setError(null);
      
      // Create confirmed companies from valid symbols only
      const confirmedCompanies: Company[] = [];
      
      data.symbols.forEach(symbol => {
        // Skip invalid symbols
        if (!symbol || symbol.includes('None') || symbol.includes('null')) {
          console.warn(`‚ö†Ô∏è Skipping invalid symbol: ${symbol}`);
          return;
        }
        
        // First try to find in available companies
        const existingCompany = availableCompanies.find(company => company.symbol === symbol);
        if (existingCompany) {
          confirmedCompanies.push(existingCompany);
        } else {
          // Create a company object from the symbol if not found
          const parts = symbol.split(':');
          if (parts.length === 2) {
            const codePart = parts[1].split('-')[0];
            const exchange = parts[0];
            const marker = parts[1].split('-')[1] || 'EQ';
            
            // Validate extracted company code
            if (codePart && codePart !== 'None' && codePart !== 'null') {
              const dynamicCompany: Company = {
                company_code: codePart,
                name: codePart,
                exchange: exchange,
                marker: marker,
                symbol: symbol
              };
              confirmedCompanies.push(dynamicCompany);
            }
          }
        }
      });
      
      setSelectedCompanies(confirmedCompanies);
    });

    // Handle marketStatus event from backend
    socket.on('marketStatus', (status: MarketStatus) => {
      console.log('‚è∞ Received market status:', status);
      setMarketStatus(status);
    });

    // Handle heartbeat event from backend
    socket.on('heartbeat', (data: { 
      timestamp: number; 
      trading_active: boolean; 
      active_subscriptions: number;
      connected_clients: number;
      server_status: string;
    }) => {
      console.log('üíì Heartbeat:', data);
      setIsConnected(true);
      setMarketStatus(prev => prev ? { ...prev, trading_active: data.trading_active } : prev);
    });

    // Fyers connection events
    socket.on('fyersConnected', (data) => {
      console.log('üîó Fyers connected:', data);
      setError(null);
    });

    socket.on('fyersDisconnected', (data) => {
      console.log('üîó Fyers disconnected:', data);
      setError('Fyers connection lost. Data may be delayed.');
    });

    socket.on('fyersError', (data) => {
      console.log('üîó Fyers error:', data);
      setError(`Fyers error: ${data.message}`);
    });

    // Error events
    socket.on('error', (data: { message: string }) => {
      console.error('‚ùå Server error:', data);
      setError(data.message);
      setLoading(false);
    });

    return socket;
  }, []);

  // Initialize socket connection
  useEffect(() => {
    const socket = initializeSocket();
    socketRef.current = socket;

    return () => {
      console.log('üßπ Cleaning up Live Market WebSocket connection');
      
      if (subscribedCompanyCodes.current.size > 0) {
        socket.emit('unsubscribe_all', {});
      }
      
      socket.disconnect();
      socketRef.current = null;
    };
  }, [initializeSocket]);

  // FIXED: Subscribe to companies with proper data structure
  const subscribeToCompanies = useCallback((companies: Company[]) => {
    if (!socketRef.current || !isConnected) {
      setError('Not connected to server');
      return Promise.resolve(false);
    }

    console.log('üîç Raw companies input:', companies);

    // Filter and validate companies
    const validCompanies = companies.filter((company, index) => {
      const isValid = isValidCompany(company);
      if (!isValid) {
        console.warn(`‚ö†Ô∏è Invalid company at index ${index}:`, company);
      }
      return isValid;
    });

    console.log('‚úÖ Valid companies after filtering:', validCompanies);

    if (validCompanies.length === 0) {
      setError('No valid companies provided. Please check company data.');
      return Promise.resolve(false);
    }

    if (validCompanies.length > maxCompanies) {
      setError(`Maximum ${maxCompanies} companies allowed`);
      return Promise.resolve(false);
    }

    setLoading(true);
    setError(null);

    // Extract and validate company codes - THIS IS THE KEY FIX
    const companyCodes = validCompanies
      .map(company => company.company_code)
      .filter(code => isValidCompanyCode(code));

    console.log('üì° Extracted company codes for backend:', companyCodes);

    if (companyCodes.length === 0) {
      setError('No valid company codes found');
      setLoading(false);
      return Promise.resolve(false);
    }

    // Update subscribed company codes
    subscribedCompanyCodes.current = new Set(companyCodes);

    // FIXED: Send correct event name and data structure
    console.log('üì° Sending subscribe_companies event to backend:', { companyCodes });
    socketRef.current.emit('subscribe_companies', { 
      companyCodes: companyCodes 
    });

    return Promise.resolve(true);
  }, [isConnected, maxCompanies]);

  // FIXED: Subscribe by company codes with proper validation
  const subscribeByCompanyCodes = useCallback((companyCodes: string[]) => {
    if (!socketRef.current || !isConnected) {
      setError('Not connected to server');
      return Promise.resolve(false);
    }

    console.log('üîç Raw company codes input:', companyCodes);

    // Filter and validate company codes
    const validCompanyCodes = companyCodes.filter((code, index) => {
      const isValid = isValidCompanyCode(code);
      if (!isValid) {
        console.warn(`‚ö†Ô∏è Invalid company code at index ${index}:`, code);
      }
      return isValid;
    });

    console.log('‚úÖ Valid company codes after filtering:', validCompanyCodes);

    if (validCompanyCodes.length === 0) {
      setError('No valid company codes provided');
      return Promise.resolve(false);
    }

    if (validCompanyCodes.length > maxCompanies) {
      setError(`Maximum ${maxCompanies} companies allowed`);
      return Promise.resolve(false);
    }

    setLoading(true);
    setError(null);

    // Update subscribed company codes
    subscribedCompanyCodes.current = new Set(validCompanyCodes);

    // FIXED: Send correct event name and data structure
    console.log('üì° Sending subscribe_companies event to backend:', { companyCodes: validCompanyCodes });
    socketRef.current.emit('subscribe_companies', { 
      companyCodes: validCompanyCodes 
    });

    return Promise.resolve(true);
  }, [isConnected, maxCompanies]);

  // Fixed: Unsubscribe using backend format
  const unsubscribeAll = useCallback(() => {
    if (!socketRef.current || !isConnected) {
      return Promise.resolve(false);
    }

    console.log('üì° Unsubscribing from all companies');
    
    socketRef.current.emit('unsubscribe_all', {});
    
    subscribedCompanyCodes.current.clear();
    setSelectedCompanies([]);
    setMarketData({});
    setHistoricalData({});

    return Promise.resolve(true);
  }, [isConnected]);

  // Fixed: Get market status using backend event name
  const getMarketStatus = useCallback(() => {
    if (!socketRef.current || !isConnected) {
      return Promise.resolve(null);
    }

    socketRef.current.emit('get_market_status', {});
    return Promise.resolve(marketStatus);
  }, [isConnected, marketStatus]);

  // Manual reconnection
  const reconnect = useCallback(() => {
    if (socketRef.current) {
      socketRef.current.disconnect();
      socketRef.current = null;
    }
    
    const socket = initializeSocket();
    socketRef.current = socket;
  }, [initializeSocket]);

  // Get current subscriptions
  const getSubscribedCompanyCodes = useCallback(() => {
    return Array.from(subscribedCompanyCodes.current);
  }, []);

  return {
    // Data
    availableCompanies,
    selectedCompanies,
    marketData,
    historicalData,
    marketStatus,
    tradingHours,
    maxCompanies,
    
    // Status
    connectionStatus,
    error,
    loading,
    isConnected,
    
    // Actions
    subscribeToCompanies,
    subscribeByCompanyCodes,
    unsubscribeAll,
    getMarketStatus,
    reconnect,
    getSubscribedCompanyCodes
  };
};

export default useLiveMarket;


================================================================================
FILE: apps/frontend/hooks/useStockData.ts
PURPOSE: Stock data hook with authentication integration
================================================================================

// Enhanced useStockData.ts with incremental loading support
import { useState, useCallback, useRef, useEffect } from 'react';

interface StockDataPoint {
  interval_start: string;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
}

interface DataCache {
  [key: string]: StockDataPoint[];
}

interface UseStockDataParams {
  companyCode: string | null;
  exchange?: string;
  interval?: string;
  indicators?: string[];
  enableIncrementalLoading?: boolean;
}

export function useStockData({ 
  companyCode,
  exchange = 'NSE',
  interval = '1m',
  indicators = [],
  enableIncrementalLoading = true
}: UseStockDataParams) {
  const [data, setData] = useState<StockDataPoint[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [dataRange, setDataRange] = useState<{ start: Date | null; end: Date | null }>({ start: null, end: null });
  
  const abortControllerRef = useRef<AbortController | null>(null);
  const cacheRef = useRef<DataCache>({});
  const loadingQueueRef = useRef<Set<string>>(new Set());

  // Generate cache key
  const getCacheKey = useCallback((company: string, start: Date, end: Date, interval: string) => {
    return `${company}_${interval}_${start.getTime()}_${end.getTime()}`;
  }, []);

  // Check if data exists in cache
  const getCachedData = useCallback((start: Date, end: Date) => {
    const key = getCacheKey(companyCode || '', start, end, interval);
    return cacheRef.current[key] || null;
  }, [getCacheKey, companyCode, interval]);

  // Store data in cache
  const setCachedData = useCallback((start: Date, end: Date, data: StockDataPoint[]) => {
    const key = getCacheKey(companyCode || '', start, end, interval);
    cacheRef.current[key] = data;
  }, [getCacheKey, companyCode, interval]);

  // Enhanced fetch with caching and queue management
  const fetchData = useCallback(async (
    startDate?: Date, 
    endDate?: Date, 
    options: { 
      fetchAllData?: boolean;
      merge?: boolean;
      priority?: 'high' | 'normal';
    } = {}
  ) => {
    if (!companyCode) {
      setError('No company selected');
      return [];
    }

    const { fetchAllData = false, merge = false, priority = 'normal' } = options;

    if (!startDate && !fetchAllData) {
      setError('Either provide a start date or set fetchAllData to true');
      return [];
    }

    // Generate request key for queue management
    const requestKey = `${companyCode}_${startDate?.getTime()}_${endDate?.getTime()}`;
    
    if (loadingQueueRef.current.has(requestKey)) {
      console.log('Request already in progress, skipping duplicate:', requestKey);
      return [];
    }

    // Check cache first
    if (startDate && endDate && enableIncrementalLoading) {
      const cachedData = getCachedData(startDate, endDate);
      if (cachedData) {
        console.log('Returning cached data for range:', startDate, endDate);
        if (merge) {
          setData(prevData => mergeData(prevData, cachedData));
        } else {
          setData(cachedData);
        }
        return cachedData;
      }
    }

    // Abort previous request if not high priority
    if (abortControllerRef.current && priority !== 'high') {
      abortControllerRef.current.abort();
    }

    loadingQueueRef.current.add(requestKey);
    setLoading(true);
    setError(null);

    try {
      abortControllerRef.current = new AbortController();
      
      const queryParams = new URLSearchParams({
        exchange,
        interval,
        ...indicators.length > 0 && { indicators: indicators.join(',') }
      });

      if (startDate) {
        queryParams.append('startDate', startDate.toISOString());
        queryParams.append('endDate', endDate?.toISOString() || new Date(startDate.getTime() + 6.25 * 60 * 60 * 1000).toISOString());
      } else {
        queryParams.append('fetchAllData', 'true');
      }

      const url = `/api/companies/${companyCode}/ohlcv?${queryParams.toString()}`;
      console.log(`Fetching stock data: ${url}`);

      const response = await fetch(url, { 
        signal: abortControllerRef.current.signal,
        headers: {
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache'
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      
      const jsonData = await response.json() as StockDataPoint[];
      console.log(`Successfully fetched ${jsonData.length} data points`);

      // Cache the data
      if (startDate && endDate && enableIncrementalLoading) {
        setCachedData(startDate, endDate, jsonData);
      }

      // Update data range
      if (jsonData.length > 0) {
        const newStart = new Date(jsonData[0].interval_start);
        const newEnd = new Date(jsonData[jsonData.length - 1].interval_start);
        
        setDataRange(prev => ({
          start: prev.start ? (newStart < prev.start ? newStart : prev.start) : newStart,
          end: prev.end ? (newEnd > prev.end ? newEnd : prev.end) : newEnd
        }));
      }

      // Merge or replace data
      if (merge) {
        setData(prevData => mergeData(prevData, jsonData));
      } else {
        setData(jsonData);
      }

      return jsonData;
    } catch (err: any) {
      if (err.name === 'AbortError') {
        console.log('Request was aborted');
        return [];
      }
      console.error('Error fetching stock data:', err);
      setError(`Failed to fetch stock data: ${err.message}`);
      return [];
    } finally {
      loadingQueueRef.current.delete(requestKey);
      setLoading(false);
    }
  }, [companyCode, exchange, interval, indicators, enableIncrementalLoading, getCachedData, setCachedData]);

  // Merge data helper function
  const mergeData = useCallback((existing: StockDataPoint[], newData: StockDataPoint[]): StockDataPoint[] => {
    const combined = [...existing, ...newData];
    const uniqueMap = new Map<string, StockDataPoint>();
    
    combined.forEach(item => {
      uniqueMap.set(item.interval_start, item);
    });
    
    return Array.from(uniqueMap.values()).sort((a, b) => 
      new Date(a.interval_start).getTime() - new Date(b.interval_start).getTime()
    );
  }, []);

  // Fetch incremental data
  const fetchIncrementalData = useCallback(async (start: Date, end: Date) => {
    return fetchData(start, end, { merge: true, priority: 'high' });
  }, [fetchData]);

  // Fetch all data
  const fetchAllData = useCallback(async () => {
    return fetchData(undefined, undefined, { fetchAllData: true });
  }, [fetchData]);

  // Clear data and cache
  const clearData = useCallback(() => {
    setData([]);
    setError(null);
    setDataRange({ start: null, end: null });
    cacheRef.current = {};
    loadingQueueRef.current.clear();
  }, []);

  // Smart data loading based on visible range
  const loadDataForRange = useCallback(async (visibleStart: Date, visibleEnd: Date) => {
    if (!enableIncrementalLoading) return;

    const buffer = 30 * 60 * 1000; // 30 minutes buffer
    const expandedStart = new Date(visibleStart.getTime() - buffer);
    const expandedEnd = new Date(visibleEnd.getTime() + buffer);

    const gaps = [];

    // Check if we need data before current range
    if (!dataRange.start || expandedStart < dataRange.start) {
      gaps.push({
        start: expandedStart,
        end: dataRange.start || visibleStart
      });
    }

    // Check if we need data after current range
    if (!dataRange.end || expandedEnd > dataRange.end) {
      gaps.push({
        start: dataRange.end || visibleEnd,
        end: expandedEnd
      });
    }

    // Fetch missing data
    for (const gap of gaps) {
      await fetchIncrementalData(gap.start, gap.end);
    }
  }, [enableIncrementalLoading, dataRange, fetchIncrementalData]);

  // Clear cache on company change
  useEffect(() => {
    clearData();
  }, [companyCode, clearData]);

  return { 
    data, 
    loading, 
    error, 
    dataRange,
    fetchData, 
    fetchAllData, 
    fetchIncrementalData,
    loadDataForRange,
    clearData 
  };
}


################################################################################
SECTION 4: MARKET DATA COMPONENTS
################################################################################

================================================================================
FILE: apps/frontend/app/market-data/components/SymbolSearch.tsx
PURPOSE: Symbol search component with auth-dependent data fetching
================================================================================

'use client';

import React, { useState } from 'react';
import { Input } from '../../../components/ui/input';
import { Button } from '../../../components/ui/button';

interface SymbolSearchProps {
  onSymbolSelect: (symbol: string) => void;
}

// Common Indian stock symbols
const commonSymbols = [
  { symbol: 'NSE:NIFTY50-INDEX', name: 'Nifty 50' },
  { symbol: 'NSE:BANKNIFTY-INDEX', name: 'Bank Nifty' },
  { symbol: 'NSE:RELIANCE-EQ', name: 'Reliance Industries' },
  { symbol: 'NSE:TCS-EQ', name: 'Tata Consultancy Services' },
  { symbol: 'NSE:INFY-EQ', name: 'Infosys' },
  { symbol: 'NSE:HDFCBANK-EQ', name: 'HDFC Bank' },
  { symbol: 'NSE:ICICIBANK-EQ', name: 'ICICI Bank' },
  { symbol: 'NSE:HINDUNILVR-EQ', name: 'Hindustan Unilever' },
  { symbol: 'NSE:ITC-EQ', name: 'ITC' },
  { symbol: 'NSE:SBIN-EQ', name: 'State Bank of India' },
];

const SymbolSearch: React.FC<SymbolSearchProps> = ({ onSymbolSelect }) => {
  const [searchTerm, setSearchTerm] = useState('');
  const [showDropdown, setShowDropdown] = useState(false);
  const [customSymbol, setCustomSymbol] = useState('');

  const filteredSymbols = searchTerm
    ? commonSymbols.filter(
        (item) =>
          item.symbol.toLowerCase().includes(searchTerm.toLowerCase()) ||
          item.name.toLowerCase().includes(searchTerm.toLowerCase())
      )
    : commonSymbols;

  const handleSymbolSelect = (symbol: string) => {
    onSymbolSelect(symbol);
    setSearchTerm('');
    setShowDropdown(false);
  };

  const handleCustomSymbolSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (customSymbol) {
      onSymbolSelect(customSymbol);
      setCustomSymbol('');
    }
  };

  return (
    <div className="relative">
      <div className="flex">
        <Input
          type="text"
          placeholder="Search symbol..."
          value={searchTerm}
          onChange={(e) => {
            setSearchTerm(e.target.value);
            setShowDropdown(true);
          }}
          onFocus={() => setShowDropdown(true)}
          className="w-64"
        />
      </div>

      {showDropdown && (
        <div className="absolute z-10 mt-1 w-full bg-popover rounded-md shadow-lg">
          <ul className="py-1 max-h-60 overflow-auto">
            {filteredSymbols.map((item) => (
              <li
                key={item.symbol}
                className="px-4 py-2 hover:bg-muted cursor-pointer"
                onClick={() => handleSymbolSelect(item.symbol)}
              >
                <div className="font-medium">{item.name}</div>
                <div className="text-sm text-muted-foreground">{item.symbol}</div>
              </li>
            ))}
            {filteredSymbols.length === 0 && (
              <li className="px-4 py-2 text-muted-foreground">
                No results found. Try adding a custom symbol.
              </li>
            )}
          </ul>
          
          <div className="border-t p-2">
            <form onSubmit={handleCustomSymbolSubmit} className="flex gap-2">
              <Input
                type="text"
                placeholder="Add custom symbol (e.g., NSE:SYMBOL-EQ)"
                value={customSymbol}
                onChange={(e) => setCustomSymbol(e.target.value)}
                className="flex-1"
              />
              <Button type="submit" size="sm">Add</Button>
            </form>
          </div>
        </div>
      )}
    </div>
  );
};

export default SymbolSearch;


================================================================================
FILE: apps/frontend/app/live-market/components/CompanySelector.tsx
PURPOSE: Company selector component with authentication flow
================================================================================

'use client';
import React, { useState, useMemo } from 'react';
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Card, CardContent } from "@/components/ui/card";
import { Search, X, Check, Building2 } from 'lucide-react';

interface Company {
  company_code: string;
  name: string;
  exchange: string;
  marker: string;
  symbol: string;
}

interface CompanySelectorProps {
  availableCompanies: Company[];
  selectedCompanies: string[];
  onSelectionChange: (companyCodes: string[]) => void;
  maxSelection: number;
  loading?: boolean;
}

const CompanySelector: React.FC<CompanySelectorProps> = ({
  availableCompanies,
  selectedCompanies,
  onSelectionChange,
  maxSelection,
  loading = false
}) => {
  const [searchTerm, setSearchTerm] = useState('');

  const filteredCompanies = useMemo(() => {
    if (!searchTerm) return availableCompanies;
    
    const term = searchTerm.toLowerCase();
    return availableCompanies.filter(company =>
      company.company_code.toLowerCase().includes(term) ||
      company.name.toLowerCase().includes(term)
    );
  }, [availableCompanies, searchTerm]);

  const handleCompanyToggle = (companyCode: string) => {
    const isSelected = selectedCompanies.includes(companyCode);
    
    if (isSelected) {
      // Remove from selection
      const newSelection = selectedCompanies.filter(code => code !== companyCode);
      onSelectionChange(newSelection);
    } else {
      // Add to selection if under limit
      if (selectedCompanies.length < maxSelection) {
        const newSelection = [...selectedCompanies, companyCode];
        onSelectionChange(newSelection);
      }
    }
  };

  const handleClearAll = () => {
    onSelectionChange([]);
  };

  const isSelectionFull = selectedCompanies.length >= maxSelection;

  return (
    <div className="space-y-4">
      {/* Search */}
      <div className="relative">
        <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
        <Input
          placeholder="Search companies..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="pl-8"
        />
      </div>

      {/* Selected Companies Tags */}
      {selectedCompanies.length > 0 && (
        <div className="space-y-2">
          <div className="flex items-center justify-between">
            <span className="text-sm font-medium">
              Selected ({selectedCompanies.length}/{maxSelection})
            </span>
            {selectedCompanies.length > 0 && (
              <Button
                variant="ghost"
                size="sm"
                onClick={handleClearAll}
                className="h-6 px-2 text-xs"
              >
                Clear All
              </Button>
            )}
          </div>
          <div className="flex flex-wrap gap-2">
            {selectedCompanies.map((companyCode) => {
              const company = availableCompanies.find(c => c.company_code === companyCode);
              return (
                <Badge
                  key={companyCode}
                  variant="default"
                  className="flex items-center gap-1 pr-1"
                >
                  <Building2 className="w-3 h-3" />
                  <span>{company?.company_code || companyCode}</span>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => handleCompanyToggle(companyCode)}
                    className="h-4 w-4 p-0 hover:bg-transparent"
                  >
                    <X className="w-3 h-3" />
                  </Button>
                </Badge>
              );
            })}
          </div>
        </div>
      )}

      {/* Available Companies Grid */}
      <Card>
        <CardContent className="p-4">
          <div className="flex items-center justify-between mb-3">
            <span className="text-sm font-medium">Available Companies</span>
            <span className="text-xs text-muted-foreground">
              {filteredCompanies.length} companies
            </span>
          </div>
          
          <ScrollArea className="h-64 w-full">
            {loading ? (
              <div className="flex items-center justify-center h-32">
                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
              </div>
            ) : (
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2">
                {filteredCompanies.map((company) => {
                  const isSelected = selectedCompanies.includes(company.company_code);
                  const canSelect = !isSelected && !isSelectionFull;
                  
                  return (
                    <Button
                      key={company.company_code}
                      variant={isSelected ? "default" : "outline"}
                      size="sm"
                      onClick={() => handleCompanyToggle(company.company_code)}
                      disabled={!canSelect && !isSelected}
                      className={`justify-start h-auto p-3 ${
                        isSelected ? 'bg-primary text-primary-foreground' : ''
                      }`}
                    >
                      <div className="flex items-center gap-2 w-full">
                        <div className="flex-shrink-0">
                          {isSelected ? (
                            <Check className="w-4 h-4" />
                          ) : (
                            <Building2 className="w-4 h-4" />
                          )}
                        </div>
                        <div className="flex-1 text-left overflow-hidden">
                          <div className="font-medium text-xs">
                            {company.company_code}
                          </div>
                          <div className="text-xs opacity-70 truncate">
                            {company.name}
                          </div>
                          <div className="text-xs opacity-50">
                            {company.exchange}
                          </div>
                        </div>
                      </div>
                    </Button>
                  );
                })}
              </div>
            )}
          </ScrollArea>
          
          {isSelectionFull && (
            <div className="mt-3 p-2 bg-yellow-50 border border-yellow-200 rounded text-xs text-yellow-800">
              Maximum {maxSelection} companies selected. Remove a company to select another.
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
};

export default CompanySelector;


################################################################################
END OF AUTHENTICATION FLOW ANALYSIS EXTRACTION
################################################################################

EXTRACTION SUMMARY:
===================
Python Authentication Files: 3 files
Backend Auth Configuration: 2 files
Frontend Data Hooks: 3 files
Market Data Components: 2 files

TOTAL FILES PROCESSED: 10 FILES

ANALYSIS FOCUS AREAS:
- Current OAuth implementation patterns
- Authentication token management
- Frontend-backend auth integration
- Component-level auth handling
- Multi-company authentication flow
- Live data authentication requirements
################################################################################
