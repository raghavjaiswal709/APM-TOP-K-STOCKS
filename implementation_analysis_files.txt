================================================================================
IMPLEMENTATION ANALYSIS - ALL REQUIRED FILES
Generated on: 04-07-2025 14:18:35.26
================================================================================

CATEGORIES:
1. Backend Files (Python and NestJS) - 10 files
2. Frontend Files (Next.js/React) - 7 files
3. Data Files - 1 file
4. Configuration Files - 2 files

TOTAL: 20 FILES
================================================================================


################################################################################
SECTION 1: BACKEND FILES (PYTHON AND NESTJS)
################################################################################

================================================================================
FILE: apps/backend/fyers_data.py
PURPOSE: Current single company data fetching implementation
================================================================================

import eventlet
eventlet.monkey_patch()

import socketio
import json
import sys
import time
import datetime
import pytz
import threading
import logging
import requests
import numpy as np
import os
from collections import deque
from fyers_apiv3 import fyersModel
from fyers_apiv3.FyersWebsocket import data_ws

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
)
logger = logging.getLogger("FyersServer")

sio = socketio.Server(cors_allowed_origins='*', async_mode='eventlet')
app = socketio.WSGIApp(sio)

client_id = "150HUKJSWG-100"
secret_key = "18YYNXCAS7"
redirect_uri = "https://daksphere.com/"
response_type = "code"
grant_type = "authorization_code"

clients = {}
symbol_to_clients = {}
running = True

historical_data = {}
ohlc_data = {}
MAX_HISTORY_POINTS = 10000

INDIA_TZ = pytz.timezone('Asia/Kolkata')

fyers = None
fyers_client = None

def get_trading_hours():
    now = datetime.datetime.now(INDIA_TZ)
    start_time = now.replace(hour=9, minute=15, second=0, microsecond=0)
    end_time = now.replace(hour=15, minute=30, second=0, microsecond=0)
    return start_time, end_time

def is_trading_hours():
    now = datetime.datetime.now(INDIA_TZ)
    start_time, end_time = get_trading_hours()
    
    if now.weekday() >= 5:
        return False
    
    return start_time <= now <= end_time

@sio.event
def connect(sid, environ):
    logger.info(f"Client connected: {sid}")
    clients[sid] = {'subscriptions': set()}

@sio.event
def disconnect(sid):
    logger.info(f"Client disconnected: {sid}")
    if sid in clients:
        for symbol in clients[sid]['subscriptions']:
            if symbol in symbol_to_clients:
                symbol_to_clients[symbol].discard(sid)
        del clients[sid]

def fetch_historical_intraday_data(symbol, date=None):
    if not date:
        date = datetime.datetime.now(INDIA_TZ).strftime('%Y-%m-%d')
    
    try:
        date_obj = datetime.datetime.strptime(date, '%Y-%m-%d')
        date_obj = INDIA_TZ.localize(date_obj)
        
        market_open = date_obj.replace(hour=9, minute=15, second=0, microsecond=0)
        market_close = date_obj.replace(hour=15, minute=30, second=0, microsecond=0)
        
        now = datetime.datetime.now(INDIA_TZ)
        if date == now.strftime('%Y-%m-%d') and now < market_open:
            logger.info(f"Market not yet open for {date}")
            return []
        
        if date == now.strftime('%Y-%m-%d') and now < market_close:
            end_time = now
        else:
            end_time = market_close
        
        from_date = market_open.strftime('%Y-%m-%d %H:%M:%S')
        to_date = end_time.strftime('%Y-%m-%d %H:%M:%S')
        
        logger.info(f"Fetching historical data for {symbol} from {from_date} to {to_date}")
        
        if fyers_client:
            data_args = {
                "symbol": symbol,
                "resolution": "1",
                "date_format": "1",
                "range_from": from_date,
                "range_to": to_date,
                "cont_flag": "1"
            }
            
            response = fyers_client.history(data_args)
            
            if response and response.get('s') == 'ok' and 'candles' in response:
                candles = response['candles']
                logger.info(f"Received {len(candles)} candles for {symbol}")
                
                result = []
                
                for candle in candles:
                    timestamp, open_price, high_price, low_price, close_price, volume = candle
                    
                    if timestamp > 10000000000:
                        timestamp = timestamp // 1000
                    
                    data_point = {
                        'symbol': symbol,
                        'ltp': close_price,
                        'open': open_price,
                        'high': high_price,
                        'low': low_price,
                        'close': close_price,
                        'volume': volume,
                        'timestamp': timestamp,
                        'change': 0,
                        'changePercent': 0
                    }
                    
                    result.append(data_point)
                    
                    if symbol not in ohlc_data:
                        ohlc_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)
                    
                    minute_timestamp = (timestamp // 60) * 60
                    
                    ohlc_candle = {
                        'timestamp': minute_timestamp,
                        'open': open_price,
                        'high': high_price,
                        'low': low_price,
                        'close': close_price,
                        'volume': volume
                    }
                    
                    if not ohlc_data[symbol] or ohlc_data[symbol][-1]['timestamp'] != minute_timestamp:
                        ohlc_data[symbol].append(ohlc_candle)
                
                if result:
                    prev_close = result[0]['open']
                    for point in result:
                        point['change'] = point['ltp'] - prev_close
                        point['changePercent'] = (point['change'] / prev_close) * 100 if prev_close else 0
                
                return result
            else:
                logger.error(f"Failed to fetch historical data: {response}")
        
        logger.warning(f"Fyers client not initialized or API call failed for {symbol}")
        return []
        
    except Exception as e:
        logger.error(f"Error fetching historical data: {e}")
        import traceback
        traceback.print_exc()
        return []

def fetch_daily_historical_data(symbol, days=30):
    try:
        if not fyers_client:
            logger.error("Fyers client not initialized")
            return []
        
        end_date = datetime.datetime.now(INDIA_TZ)
        start_date = end_date - datetime.timedelta(days=days)
        
        data_args = {
            "symbol": symbol,
            "resolution": "D",
            "date_format": "1",
            "range_from": start_date.strftime('%Y-%m-%d'),
            "range_to": end_date.strftime('%Y-%m-%d'),
            "cont_flag": "1"
        }
        
        response = fyers_client.history(data_args)
        
        if response and response.get('s') == 'ok' and 'candles' in response:
            return response['candles']
        else:
            logger.error(f"Failed to fetch daily historical data: {response}")
            return []
            
    except Exception as e:
        logger.error(f"Error fetching daily historical data: {e}")
        return []

@sio.event
def subscribe(sid, data):
    symbol = data.get('symbol')
    if not symbol:
        return {'success': False, 'error': 'No symbol provided'}
    
    logger.info(f"Client {sid} subscribing to {symbol}")
    
    clients[sid]['subscriptions'].add(symbol)
    if symbol not in symbol_to_clients:
        symbol_to_clients[symbol] = set()
    symbol_to_clients[symbol].add(sid)
    
    if symbol not in historical_data or not historical_data[symbol]:
        logger.info(f"Fetching historical data for {symbol}")
        hist_data = fetch_historical_intraday_data(symbol)
        
        if symbol not in historical_data:
            historical_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)
        
        for data_point in hist_data:
            historical_data[symbol].append(data_point)
    
    if hasattr(fyers, 'subscribe') and callable(fyers.subscribe):
        logger.info(f"Subscribing to symbol: {symbol}")
        fyers.subscribe(symbols=[symbol], data_type="SymbolUpdate")
    
    if symbol in historical_data and historical_data[symbol]:
        logger.info(f"Sending historical data for {symbol} to client {sid}")
        hist_data_list = list(historical_data[symbol])
        sio.emit('historicalData', {
            'symbol': symbol,
            'data': hist_data_list
        }, room=sid)
    
    if symbol in ohlc_data and ohlc_data[symbol]:
        logger.info(f"Sending OHLC data for {symbol} to client {sid}")
        sio.emit('ohlcData', {
            'symbol': symbol,
            'data': list(ohlc_data[symbol])
        }, room=sid)
    
    return {'success': True, 'symbol': symbol}

@sio.event
def unsubscribe(sid, data):
    symbol = data.get('symbol')
    if not symbol:
        return {'success': False, 'error': 'No symbol provided'}
    
    logger.info(f"Client {sid} unsubscribing from {symbol}")
    
    if sid in clients:
        clients[sid]['subscriptions'].discard(symbol)
    
    if symbol in symbol_to_clients:
        symbol_to_clients[symbol].discard(sid)
        
        if not symbol_to_clients[symbol] and hasattr(fyers, 'unsubscribe'):
            logger.info(f"No more clients for {symbol}, unsubscribing from Fyers")
            fyers.unsubscribe(symbols=[symbol])
    
    return {'success': True, 'symbol': symbol}

@sio.event
def get_trading_status(sid, data):
    start_time, end_time = get_trading_hours()
    return {
        'trading_active': is_trading_hours(),
        'trading_start': start_time.isoformat(),
        'trading_end': end_time.isoformat(),
        'current_time': datetime.datetime.now(INDIA_TZ).isoformat(),
        'is_market_day': datetime.datetime.now(INDIA_TZ).weekday() < 5
    }

@sio.event
def get_historical_data_for_date(sid, data):
    symbol = data.get('symbol')
    date = data.get('date')
    
    if not symbol:
        return {'success': False, 'error': 'No symbol provided'}
    
    if not date:
        date = datetime.datetime.now(INDIA_TZ).strftime('%Y-%m-%d')
    
    try:
        try:
            with open(f'market_data_{date}_{symbol}.json', 'r') as f:
                saved_data = json.load(f)
                logger.info(f"Loaded saved data for {symbol} on {date}")
                return {
                    'success': True,
                    'symbol': symbol,
                    'date': date,
                    'data': saved_data
                }
        except FileNotFoundError:
            pass
        
        hist_data = fetch_historical_intraday_data(symbol, date)
        
        if hist_data:
            try:
                with open(f'market_data_{date}_{symbol}.json', 'w') as f:
                    json.dump(hist_data, f)
                logger.info(f"Saved historical data for {symbol} on {date}")
            except Exception as e:
                logger.error(f"Error saving historical data: {e}")
        
        return {
            'success': True,
            'symbol': symbol,
            'date': date,
            'data': hist_data
        }
    except Exception as e:
        logger.error(f"Error fetching historical data for date: {e}")
        return {'success': False, 'error': str(e)}

@sio.event
def get_daily_data(sid, data):
    symbol = data.get('symbol')
    days = data.get('days', 30)
    
    if not symbol:
        return {'success': False, 'error': 'No symbol provided'}
    
    try:
        daily_data = fetch_daily_historical_data(symbol, days)
        
        if daily_data:
            formatted_data = []
            for candle in daily_data:
                timestamp, open_price, high_price, low_price, close_price, volume = candle
                formatted_data.append({
                    'timestamp': timestamp,
                    'open': open_price,
                    'high': high_price,
                    'low': low_price,
                    'close': close_price,
                    'volume': volume
                })
            
            return {
                'success': True,
                'symbol': symbol,
                'days': days,
                'data': formatted_data
            }
        else:
            return {'success': False, 'error': 'No data available'}
    except Exception as e:
        logger.error(f"Error fetching daily data: {e}")
        return {'success': False, 'error': str(e)}

def store_historical_data(symbol, data_point):
    if symbol not in historical_data:
        historical_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)
    
    if 'timestamp' not in data_point:
        data_point['timestamp'] = int(time.time())
    
    historical_data[symbol].append(data_point)
    
    update_ohlc_data(symbol, data_point)

def update_ohlc_data(symbol, data_point):
    if symbol not in ohlc_data:
        ohlc_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)
    
    timestamp = data_point['timestamp']
    price = data_point['ltp']
    
    minute_timestamp = (timestamp // 60) * 60
    
    if not ohlc_data[symbol] or ohlc_data[symbol][-1]['timestamp'] < minute_timestamp:
        ohlc_data[symbol].append({
            'timestamp': minute_timestamp,
            'open': price,
            'high': price,
            'low': price,
            'close': price,
            'volume': data_point.get('volume', 0)
        })
    else:
        current_candle = ohlc_data[symbol][-1]
        current_candle['high'] = max(current_candle['high'], price)
        current_candle['low'] = min(current_candle['low'], price)
        current_candle['close'] = price
        current_candle['volume'] = data_point.get('volume', current_candle['volume'])

def calculate_indicators(symbol):
    if symbol not in ohlc_data or len(ohlc_data[symbol]) < 20:
        return {}
    
    closes = [candle['close'] for candle in ohlc_data[symbol]]
    
    sma_20 = np.mean(closes[-20:])
    
    ema_9 = closes[-1]
    alpha = 2 / (9 + 1)
    for i in range(2, min(10, len(closes) + 1)):
        ema_9 = alpha * closes[-i] + (1 - alpha) * ema_9
    
    changes = [closes[i] - closes[i-1] for i in range(1, len(closes))]
    gains = [max(0, change) for change in changes]
    losses = [max(0, -change) for change in changes]
    
    if len(gains) >= 14:
        avg_gain = np.mean(gains[-14:])
        avg_loss = np.mean(losses[-14:])
        
        if avg_loss == 0:
            rsi = 100
        else:
            rs = avg_gain / avg_loss
            rsi = 100 - (100 / (1 + rs))
    else:
        rsi = 50
    
    return {
        'sma_20': sma_20,
        'ema_9': ema_9,
        'rsi_14': rsi
    }

def onmessage(message):
    logger.debug(f"Response: {message}")
    
    if isinstance(message, dict) and message.get('type') == 'sub':
        logger.info(f"Subscription confirmation: {message}")
        return
    
    if isinstance(message, dict) and 'symbol' in message:
        symbol = message['symbol']
        
        simplified_data = {
            'symbol': symbol,
            'ltp': message.get('ltp'),
            'change': message.get('ch'),
            'changePercent': message.get('chp'),
            'volume': message.get('vol_traded_today'),
            'open': message.get('open_price'),
            'high': message.get('high_price'),
            'low': message.get('low_price'),
            'close': message.get('prev_close_price'),
            'bid': message.get('bid_price'),
            'ask': message.get('ask_price'),
            'timestamp': message.get('last_traded_time') or int(time.time())
        }
        
        store_historical_data(symbol, simplified_data)
        
        indicators = calculate_indicators(symbol)
        if indicators:
            simplified_data.update(indicators)
        
        if symbol in symbol_to_clients:
            for sid in symbol_to_clients[symbol]:
                try:
                    sio.emit('marketData', simplified_data, room=sid)
                except Exception as e:
                    logger.error(f"Error sending data to client {sid}: {e}")
        else:
            logger.debug(f"No clients subscribed to {symbol}")
    else:
        logger.warning(f"Invalid message format: {message}")

def onerror(error):
    logger.error(f"Error: {error}")
    sio.emit('error', {'message': str(error)})

def onclose(message):
    logger.info(f"Connection closed: {message}")
    sio.emit('fyersDisconnected', {'message': str(message)})

def onopen():
    logger.info("Fyers WebSocket connected")
    sio.emit('fyersConnected', {'status': 'connected'})
    
    default_symbols = []
    fyers.subscribe(symbols=default_symbols, data_type="SymbolUpdate")
    logger.info(f"Subscribed to default symbols: {default_symbols}")

def heartbeat_task():
    global running
    while running:
        try:
            sio.emit('heartbeat', {
                'timestamp': int(time.time()),
                'trading_active': is_trading_hours()
            })
            time.sleep(30)
        except Exception as e:
            logger.error(f"Error in heartbeat: {e}")

def save_daily_data():
    today = datetime.datetime.now(INDIA_TZ).strftime('%Y-%m-%d')
    
    for symbol in historical_data:
        data_to_save = list(historical_data[symbol])
        
        try:
            with open(f'market_data_{today}_{symbol}.json', 'w') as f:
                json.dump(data_to_save, f)
            logger.info(f"Saved market data for {symbol} on {today}")
        except Exception as e:
            logger.error(f"Error saving market data for {symbol}: {e}")
    
    for symbol in ohlc_data:
        ohlc_to_save = list(ohlc_data[symbol])
        
        try:
            with open(f'ohlc_data_{today}_{symbol}.json', 'w') as f:
                json.dump(ohlc_to_save, f)
            logger.info(f"Saved OHLC data for {symbol} on {today}")
        except Exception as e:
            logger.error(f"Error saving OHLC data for {symbol}: {e}")

def load_daily_data():
    today = datetime.datetime.now(INDIA_TZ).strftime('%Y-%m-%d')
    
    for file in os.listdir('.'):
        if file.startswith('market_data_' + today) and file.endswith('.json'):
            symbol = file.replace('market_data_' + today + '_', '').replace('.json', '')
            
            try:
                with open(file, 'r') as f:
                    data_points = json.load(f)
                    
                    if symbol not in historical_data:
                        historical_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)
                    
                    for point in data_points:
                        historical_data[symbol].append(point)
                    
                    logger.info(f"Loaded {len(data_points)} historical data points for {symbol}")
            except Exception as e:
                logger.error(f"Error loading market data for {symbol}: {e}")
    
    for file in os.listdir('.'):
        if file.startswith('ohlc_data_' + today) and file.endswith('.json'):
            symbol = file.replace('ohlc_data_' + today + '_', '').replace('.json', '')
            
            try:
                with open(file, 'r') as f:
                    candles = json.load(f)
                    
                    if symbol not in ohlc_data:
                        ohlc_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)
                    
                    for candle in candles:
                        ohlc_data[symbol].append(candle)
                    
                    logger.info(f"Loaded {len(candles)} OHLC candles for {symbol}")
            except Exception as e:
                logger.error(f"Error loading OHLC data for {symbol}: {e}")

def data_persistence_task():
    global running
    while running:
        try:
            save_daily_data()
            time.sleep(300)
        except Exception as e:
            logger.error(f"Error in data persistence task: {e}")

def cleanup_old_data_files():
    try:
        today = datetime.datetime.now(INDIA_TZ)
        for file in os.listdir('.'):
            if (file.startswith('market_data_') or file.startswith('ohlc_data_')) and file.endswith('.json'):
                try:
                    date_str = file.split('_')[2]
                    file_date = datetime.datetime.strptime(date_str, '%Y-%m-%d')
                    if (today - file_date).days > 30:
                        os.remove(file)
                        logger.info(f"Removed old data file: {file}")
                except (ValueError, IndexError):
                    continue
    except Exception as e:
        logger.error(f"Error cleaning up old data files: {e}")

def main_process():
    global fyers, fyers_client, running
    
    try:
        load_daily_data()
        
        cleanup_old_data_files()
        
        session = fyersModel.SessionModel(
            client_id=client_id,
            secret_key=secret_key,
            redirect_uri=redirect_uri,
            response_type=response_type,
            grant_type=grant_type
        )
        
        auth_url = session.generate_authcode()
        logger.info("\n==== Fyers Authentication ====")
        logger.info("Open this URL in your browser and log in:")
        logger.info(auth_url)
        
        auth_code = input("\nEnter Auth Code: ")
        session.set_token(auth_code)
        token_response = session.generate_token()
        
        if token_response.get('s') != 'ok':
            logger.error(f"Authentication failed: {token_response}")
            return
            
        logger.info("Authentication successful!")
        access_token = f"{client_id}:{token_response['access_token']}"
        
        fyers_client = fyersModel.FyersModel(
            client_id=client_id,
            token=token_response['access_token'],
            log_path=""
        )
        
        fyers = data_ws.FyersDataSocket(
            access_token=access_token,
            log_path="",
            litemode=False,
            write_to_file=False,
            reconnect=True,
            on_connect=onopen,
            on_close=onclose,
            on_error=onerror,
            on_message=onmessage
        )
        
        heartbeat_thread = threading.Thread(target=heartbeat_task, daemon=True)
        heartbeat_thread.start()
        
        persistence_thread = threading.Thread(target=data_persistence_task, daemon=True)
        persistence_thread.start()
        
        def schedule_end_of_day_save():
            now = datetime.datetime.now(INDIA_TZ)
            market_close = now.replace(hour=15, minute=30, second=0, microsecond=0)
            
            if now < market_close:
                delay = (market_close - now).total_seconds()
                threading.Timer(delay, save_daily_data).start()
                logger.info(f"Scheduled end-of-day data save for {market_close.strftime('%H:%M:%S')}")
        
        schedule_end_of_day_save()
        
        fyers.connect()
        logger.info("Connected to Fyers WebSocket")
        
        logger.info("Starting Socket.IO server on port 5001...")
        eventlet.wsgi.server(eventlet.listen(('0.0.0.0', 5001)), app)
        
    except Exception as e:
        logger.error(f"Error: {e}")
        import traceback
        traceback.print_exc()

def main():
    global running
    
    try:
        eventlet.spawn(main_process)
        
        while running:
            time.sleep(1)
    except KeyboardInterrupt:
        logger.info("Shutting down...")
        running = False
        save_daily_data()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logger.info("Shutting down...")
        running = False
        save_daily_data()


================================================================================
FILE: apps/backend/data/fyers.py
PURPOSE: New multiple company subscription implementation
================================================================================

[FILE NOT FOUND OR EMPTY] 


================================================================================
FILE: apps/backend/src/config/fyers.config.ts
PURPOSE: Fyers configuration settings
================================================================================

export const fyersConfig = {
    clientId: process.env.FYERS_CLIENT_ID || '',
    secretId: process.env.FYERS_SECRET_ID || '',
    redirectUri: process.env.FYERS_REDIRECT_URI || 'http://127.0.0.1:5000',
    responseType: 'code',
    state: 'fyers',
    grantType: 'authorization_code',
  };
  

================================================================================
FILE: apps/backend/src/market-data/market-data.service.ts
PURPOSE: Current market data service logic
================================================================================


import { Injectable, Logger } from '@nestjs/common';

@Injectable()
export class MarketDataService {
  private readonly logger = new Logger(MarketDataService.name);
  private marketData = new Map<string, any>();

  getAccessToken(): string {
    const token = process.env.FYERS_ACCESS_TOKEN;
    if (!token) {
      this.logger.error('FYERS_ACCESS_TOKEN is not defined in environment');
      throw new Error('Missing Fyers access token');
    }
    return token;
  }

  updateMarketData(symbol: string, data: any) {
    this.marketData.set(symbol, data);
    this.logger.debug(`Updated market data for ${symbol}`);
  }

  getMarketData(symbol: string) {
    return this.marketData.get(symbol) || null;
  }

  isMarketCurrentlyOpen(): boolean {
    const today = new Date().getDay();
    if (today === 0 || today === 6) {
      this.logger.warn('Today is a weekend. Markets are closed.');
      return false;
    }
    
    const now = new Date();
    const hours = now.getHours();
    const minutes = now.getMinutes();
    const currentTime = hours * 100 + minutes;
    
    if (currentTime < 915 || currentTime > 1530) {
      this.logger.warn('Outside market hours (9:15 AM - 3:30 PM IST). Real-time data may not be available.');
      return false;
    }
    
    return true;
  }
}


================================================================================
FILE: apps/backend/src/market-data/market-data.controller.ts
PURPOSE: Current API endpoints
================================================================================

import { Controller, Get, Param, Query } from '@nestjs/common';
import { MarketDataService } from './market-data.service';

@Controller('market-data')
export class MarketDataController {
  constructor(private readonly marketDataService: MarketDataService) {}

  @Get(':symbol')
  getMarketData(@Param('symbol') symbol: string) {
    return this.marketDataService.getMarketData(symbol);
  }

  /*
  @Get('status')
  getMarketStatus() {
    return this.marketDataService.getMarketStatus();
  }

  @Get('quotes')
  getQuotes(@Query('symbols') symbols: string) {
    const symbolArray = symbols.split(',');
    return this.marketDataService.getQuotes(symbolArray);
  }

  @Get('history/:symbol')
  getHistoricalData(
    @Param('symbol') symbol: string,
    @Query('resolution') resolution: string,
    @Query('from') from: string,
    @Query('to') to: string,
  ) {
    return this.marketDataService.getHistoricalData(symbol, resolution, from, to);
  }

  @Get('depth/:symbol')
  getMarketDepth(@Param('symbol') symbol: string) {
    return this.marketDataService.getMarketDepth(symbol);
  }

  @Get('option-chain/:symbol')
  getOptionChain(@Param('symbol') symbol: string) {
    return this.marketDataService.getOptionChain(symbol);
  }
  */
}


================================================================================
FILE: apps/backend/src/market-data/dto/market-data.dto.ts
PURPOSE: Data transfer objects
================================================================================

export class MarketDataDto {
    symbol: string;
    ltp: number;
    change: number;
    changePercent: number;
    open: number;
    high: number;
    low: number;
    close: number;
    volume: number;
    timestamp: number;
  }
  
  export class HistoricalDataRequestDto {
    symbol: string;
    resolution: string;
    from: string;
    to: string;
  }
  
  export class SubscriptionDto {
    symbol: string;
  }
  

================================================================================
FILE: apps/backend/src/market-data/entities/market-data.entity.ts
PURPOSE: Entity definitions
================================================================================

export class MarketData {
    symbol: string;
    ltp: number;
    change: number;
    changePercent: number;
    open: number;
    high: number;
    low: number;
    close: number;
    volume: number;
    timestamp: number;
  }
  

================================================================================
FILE: apps/backend/src/market-data/websocket/market-data.gateway.ts
PURPOSE: WebSocket implementation
================================================================================

// // import {
// //   WebSocketGateway,
// //   WebSocketServer,
// //   SubscribeMessage,
// //   ConnectedSocket,
// //   MessageBody,
// // } from '@nestjs/websockets';
// // import { Server, Socket } from 'socket.io';
// // import { Logger } from '@nestjs/common';
// // import { MarketDataService } from '../market-data.service';
// // import { SubscriptionDto } from '../dto/market-data.dto';
// // import { io } from 'socket.io-client';

// // @WebSocketGateway({
// //   cors: {
// //     origin: '*',
// //   },
// // })
// // export class MarketDataGateway {
// //   @WebSocketServer()
// //   server: Server;
  
// //   private readonly logger = new Logger(MarketDataGateway.name);
// //   private clients = new Map<string, Socket>();
// //   private pythonClient: any;
// //   private symbolToClients = new Map<string, Set<string>>();
  
// //   constructor(private readonly marketDataService: MarketDataService) {
// //     // Connect to the Python bridge
// //     this.pythonClient = io('http://localhost:5001');
    
// //     this.pythonClient.on('connect', () => {
// //       this.logger.log('Connected to Python bridge');
// //     });
    
// //     this.pythonClient.on('disconnect', () => {
// //       this.logger.log('Disconnected from Python bridge');
// //     });
    
// //     this.pythonClient.on('marketData', (data) => {
// //       // Forward the exact data to all connected clients
// //       this.clients.forEach(client => {
// //         if (this.symbolToClients.get(data.symbol)?.has(client.id)) {
// //           client.emit('marketData', data);
// //         }
// //       });
      
// //       // Log the data for debugging
// //       console.log("Response:", data);
// //     });
    
// //   }

// //   handleConnection(client: Socket) {
// //     this.logger.log(`Client connected: ${client.id}`);
// //     this.clients.set(client.id, client);
// //   }

// //   handleDisconnect(client: Socket) {
// //     this.logger.log(`Client disconnected: ${client.id}`);
// //     this.clients.delete(client.id);
// //   }

// //   @SubscribeMessage('subscribe')
// //   handleSubscribe(
// //     @ConnectedSocket() client: Socket,
// //     @MessageBody() data: SubscriptionDto
// //   ) {
// //     const symbol = data.symbol;
// //     this.logger.log(`Client ${client.id} subscribing to ${symbol}`);
    
// //     // Forward subscription to Python bridge
// //     this.pythonClient.emit('subscribe', { symbol });
    
// //     // Send current data if available
// //     const currentData = this.marketDataService.getMarketData(symbol);
// //     if (currentData) {
// //       client.emit('marketData', { symbol, data: currentData });
// //     }
    
// //     return { success: true, symbol };
// //   }

// //   @SubscribeMessage('unsubscribe')
// //   handleUnsubscribe(
// //     @ConnectedSocket() client: Socket,
// //     @MessageBody() data: SubscriptionDto
// //   ) {
// //     const symbol = data.symbol;
// //     this.logger.log(`Client ${client.id} unsubscribing from ${symbol}`);
    
// //     // Forward unsubscription to Python bridge
// //     this.pythonClient.emit('unsubscribe', { symbol });
    
// //     return { success: true, symbol };
// //   }
// // }


// import {
//   WebSocketGateway,
//   WebSocketServer,
//   SubscribeMessage,
//   ConnectedSocket,
//   MessageBody,
// } from '@nestjs/websockets';
// import { Server, Socket } from 'socket.io';
// import { Logger } from '@nestjs/common';
// import { MarketDataService } from '../market-data.service';
// import { SubscriptionDto } from '../dto/market-data.dto';
// import { io } from 'socket.io-client';

// @WebSocketGateway({
//   cors: {
//     origin: '*',
//   },
// })
// export class MarketDataGateway {
//   @WebSocketServer()
//   server: Server;
  
//   private readonly logger = new Logger(MarketDataGateway.name);
//   private clients = new Map<string, Socket>();
//   private pythonClient: any;
//   private symbolToClients = new Map<string, Set<string>>();
  
//   constructor(private readonly marketDataService: MarketDataService) {
//     // Connect to the Python bridge
//     this.pythonClient = io('http://localhost:5001');
    
//     this.pythonClient.on('connect', () => {
//       this.logger.log('Connected to Python bridge');
//     });
    
//     this.pythonClient.on('disconnect', () => {
//       this.logger.log('Disconnected from Python bridge');
//     });
    
//     this.pythonClient.on('marketData', (data) => {
//       // Log the raw data received from Python bridge
//       this.logger.log(`Market data received from Python: ${JSON.stringify(data)}`);
      
//       // Store the data in the service
//       if (data && data.symbol) {
//         this.marketDataService.updateMarketData(data.symbol, data);
        
//         // Forward to all connected clients
//         this.clients.forEach(client => {
//           client.emit('marketData', data);
//         });
//       }
//     });
//   }

//   handleConnection(client: Socket) {
//     this.logger.log(`Client connected: ${client.id}`);
//     this.clients.set(client.id, client);
    
//     // Initialize empty set for this client's subscriptions
//     this.symbolToClients.set(client.id, new Set<string>());
//   }

//   handleDisconnect(client: Socket) {
//     this.logger.log(`Client disconnected: ${client.id}`);
//     // Clean up subscriptions
//     this.symbolToClients.delete(client.id);
//     this.clients.delete(client.id);
//   }

//   @SubscribeMessage('subscribe')
//   handleSubscribe(
//     @ConnectedSocket() client: Socket,
//     @MessageBody() data: SubscriptionDto
//   ) {
//     const symbol = data.symbol;
//     this.logger.log(`Client ${client.id} subscribing to ${symbol}`);
    
//     // Add to client's subscriptions
//     const clientSymbols = this.symbolToClients.get(client.id);
//     if (clientSymbols) {
//       clientSymbols.add(symbol);
//     } else {
//       this.symbolToClients.set(client.id, new Set([symbol]));
//     }
    
//     // Forward subscription to Python bridge
//     this.pythonClient.emit('subscribe', { symbols: [symbol] });
    
//     // Send current data if available
//     const currentData = this.marketDataService.getMarketData(symbol);
//     if (currentData) {
//       client.emit('marketData', currentData);
//     }
    
//     return { success: true, symbol };
//   }

//   @SubscribeMessage('unsubscribe')
//   handleUnsubscribe(
//     @ConnectedSocket() client: Socket,
//     @MessageBody() data: SubscriptionDto
//   ) {
//     const symbol = data.symbol;
//     this.logger.log(`Client ${client.id} unsubscribing from ${symbol}`);
    
//     // Remove from client's subscriptions
//     const clientSymbols = this.symbolToClients.get(client.id);
//     if (clientSymbols) {
//       clientSymbols.delete(symbol);
//     }
    
//     // Forward unsubscription to Python bridge
//     this.pythonClient.emit('unsubscribe', { symbols: [symbol] });
    
//     return { success: true, symbol };
//   }
// }


================================================================================
FILE: apps/backend/src/market-data/websocket/python-bridge.gateway.ts
PURPOSE: Python bridge connection
================================================================================

// // import { WebSocketGateway, WebSocketServer, SubscribeMessage, OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect } from '@nestjs/websockets';
// // import { Logger } from '@nestjs/common';
// // import { Server, Socket } from 'socket.io';
// // import { spawn } from 'child_process';
// // import * as path from 'path';
// // import { DefaultEventsMap } from 'socket.io/dist/typed-events';

// // @WebSocketGateway(5001, {
// //   cors: {
// //     origin: '*',
// //   },
// //   namespace: '/',
// // })
// // export class PythonBridgeGateway implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect {
// //   @WebSocketServer() server: Server;
// //   private readonly logger = new Logger(PythonBridgeGateway.name);
// //   private pythonProcess: any;
// //   private clientToSymbols = new Map<string, Set<string>>();
// //   private marketData = new Map<string, any>();
// //   private isPythonReady = false;
// //   // Fix 1: Properly type the Socket with null
// //   private pythonSocket: Socket<DefaultEventsMap, DefaultEventsMap, DefaultEventsMap, any> | null = null;

// //   afterInit() {
// //     this.startPythonScript();
// //   }

// //   handleConnection(client: Socket) {
// //     this.logger.log(`Client connected: ${client.id}`);
// //   }

// //   handleDisconnect(client: Socket) {
// //     this.logger.log(`Client disconnected: ${client.id}`);
    
// //     // Clean up subscriptions
// //     if (this.clientToSymbols.has(client.id)) {
// //       const symbols = this.clientToSymbols.get(client.id);
// //       this.clientToSymbols.delete(client.id);
      
// //       // Check if any symbols should be unsubscribed (no other clients subscribed)
// //       // Fix 2: Initialize the array and check for undefined
// //       if (symbols) {
// //         const symbolsToUnsubscribe: string[] = []; // Fix 3: Properly type the array
// //         for (const symbol of symbols) {
// //           let isSubscribedByOthers = false;
// //           for (const [_, otherSymbols] of this.clientToSymbols) {
// //             if (otherSymbols.has(symbol)) {
// //               isSubscribedByOthers = true;
// //               break;
// //             }
// //           }
          
// //           if (!isSubscribedByOthers) {
// //             symbolsToUnsubscribe.push(symbol);
// //           }
// //         }
        
// //         // Unsubscribe from symbols no longer needed
// //         if (symbolsToUnsubscribe.length > 0 && this.pythonSocket) {
// //           this.pythonSocket.emit('unsubscribe', { symbols: symbolsToUnsubscribe });
// //         }
// //       }
// //     }
// //   }

// //   @SubscribeMessage('subscribe')
// //   handleSubscribe(client: Socket, payload: { symbol: string }) {
// //     const { symbol } = payload;
// //     this.logger.log(`Client ${client.id} subscribing to ${symbol}`);
    
// //     // Track client subscriptions
// //     if (!this.clientToSymbols.has(client.id)) {
// //       this.clientToSymbols.set(client.id, new Set<string>());
// //     }
    
// //     // Fix 4: Add null check before accessing
// //     const clientSymbols = this.clientToSymbols.get(client.id);
// //     if (clientSymbols) {
// //       clientSymbols.add(symbol);
// //     }
    
// //     // Send cached data if available
// //     if (this.marketData.has(symbol)) {
// //       client.emit('marketData', { 
// //         symbol, 
// //         data: this.marketData.get(symbol) 
// //       });
// //     }
    
// //     // Forward subscription to Python
// //     if (this.isPythonReady && this.pythonSocket) {
// //       this.pythonSocket.emit('subscribe', { symbols: [symbol] });
// //     }
    
// //     return { success: true, symbol };
// //   }

// //   @SubscribeMessage('unsubscribe')
// //   handleUnsubscribe(client: Socket, payload: { symbol: string }) {
// //     const { symbol } = payload;
// //     this.logger.log(`Client ${client.id} unsubscribing from ${symbol}`);
    
// //     // Remove from client subscriptions
// //     if (this.clientToSymbols.has(client.id)) {
// //       // Fix 5: Add null check before accessing
// //       const clientSymbols = this.clientToSymbols.get(client.id);
// //       if (clientSymbols) {
// //         clientSymbols.delete(symbol);
// //       }
// //     }
    
// //     // Check if any other clients are subscribed to this symbol
// //     let isSubscribedByOthers = false;
// //     for (const [clientId, symbols] of this.clientToSymbols) {
// //       if (clientId !== client.id && symbols && symbols.has(symbol)) {
// //         isSubscribedByOthers = true;
// //         break;
// //       }
// //     }
    
// //     // Unsubscribe from Python if no other clients need this symbol
// //     if (!isSubscribedByOthers && this.isPythonReady && this.pythonSocket) {
// //       this.pythonSocket.emit('unsubscribe', { symbols: [symbol] });
// //     }
    
// //     return { success: true, symbol };
// //   }

// //   private startPythonScript() {
// //     try {
// //       const scriptPath = path.join(process.cwd(), 'fyers_data.py');
// //       this.logger.log(`Starting Python script: ${scriptPath}`);
      
// //       this.pythonProcess = spawn('python', [scriptPath], {
// //         stdio: ['inherit', 'inherit', 'inherit']
// //       });
      
// //       this.pythonProcess.on('error', (error) => {
// //         this.logger.error(`Failed to start Python script: ${error.message}`);
// //       });
      
// //       this.pythonProcess.on('close', (code) => {
// //         this.logger.log(`Python script exited with code ${code}`);
// //         this.isPythonReady = false;
// //         // Fix 6: Properly set to null with type
// //         this.pythonSocket = null;
// //       });
      
// //       // Set up event handlers for Python socket connection
// //       this.server.on('connection', (socket) => {
// //         if (socket.handshake.headers['user-agent']?.includes('python-socketio')) {
// //           this.logger.log('Python script connected');
// //           this.pythonSocket = socket;
          
// //           // Handle market data from Python
// //           // Inside the server.on('connection') handler:
// // socket.on('marketData', (data) => {
// //     // Forward the exact raw data from Python to clients
// //     for (const [clientId, symbols] of this.clientToSymbols.entries()) {
// //       if (symbols && symbols.has(data.symbol)) {
// //         const client = this.server.sockets.sockets.get(clientId);
// //         if (client) {
// //           // Send the raw data exactly as received from Python
// //           client.emit('marketData', data);
// //         }
// //       }
// //     }
    
// //     // Also log to console for debugging
// //     this.logger.log(`Market data received: ${data.symbol}`);
// //   });
  
          
// //           // Handle Fyers connection status
// //           socket.on('fyersReady', () => {
// //             this.logger.log('Fyers connection ready');
// //             this.isPythonReady = true;
// //           });
          
// //           socket.on('fyersConnected', () => {
// //             this.logger.log('Fyers WebSocket connected');
// //           });
          
// //           socket.on('fyersDisconnected', () => {
// //             this.logger.log('Fyers WebSocket disconnected');
// //           });
          
// //           socket.on('error', (error) => {
// //             this.logger.error(`Fyers error: ${error.message}`);
// //           });
// //         }
// //       });
      
// //     } catch (error) {
// //       this.logger.error(`Error starting Python script: ${error.message}`);
// //     }
// //   }
// // }


// import { WebSocketGateway, WebSocketServer, SubscribeMessage, OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect } from '@nestjs/websockets';
// import { Logger } from '@nestjs/common';
// import { Server, Socket } from 'socket.io';
// import { spawn } from 'child_process';
// import * as path from 'path';
// import { DefaultEventsMap } from 'socket.io/dist/typed-events';

// @WebSocketGateway(5001, {
//   cors: {
//     origin: '*',
//   },
//   namespace: '/',
// })
// export class PythonBridgeGateway implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect {
//   @WebSocketServer() server: Server;
//   private readonly logger = new Logger(PythonBridgeGateway.name);
//   private pythonProcess: any;
//   private clientToSymbols = new Map<string, Set<string>>();
//   private marketData = new Map<string, any>();
//   private isPythonReady = false;
//   private pythonSocket: Socket<DefaultEventsMap, DefaultEventsMap, DefaultEventsMap, any> | null = null;

//   afterInit() {
//     this.startPythonScript();
//   }

//   handleConnection(client: Socket) {
//     this.logger.log(`Client connected: ${client.id}`);
//   }

//   handleDisconnect(client: Socket) {
//     this.logger.log(`Client disconnected: ${client.id}`);
    
//     // Clean up subscriptions
//     if (this.clientToSymbols.has(client.id)) {
//       const symbols = this.clientToSymbols.get(client.id);
//       this.clientToSymbols.delete(client.id);
      
//       // Check if any symbols should be unsubscribed (no other clients subscribed)
//       if (symbols) {
//         const symbolsToUnsubscribe: string[] = [];
//         for (const symbol of symbols) {
//           let isSubscribedByOthers = false;
//           for (const [_, otherSymbols] of this.clientToSymbols) {
//             if (otherSymbols && otherSymbols.has(symbol)) {
//               isSubscribedByOthers = true;
//               break;
//             }
//           }
          
//           if (!isSubscribedByOthers) {
//             symbolsToUnsubscribe.push(symbol);
//           }
//         }
        
//         // Unsubscribe from symbols no longer needed
//         if (symbolsToUnsubscribe.length > 0 && this.pythonSocket) {
//           this.pythonSocket.emit('unsubscribe', { symbols: symbolsToUnsubscribe });
//         }
//       }
//     }
//   }

//   @SubscribeMessage('subscribe')
//   handleSubscribe(client: Socket, payload: { symbol: string }) {
//     const { symbol } = payload;
//     this.logger.log(`Client ${client.id} subscribing to ${symbol}`);
    
//     // Track client subscriptions
//     if (!this.clientToSymbols.has(client.id)) {
//       this.clientToSymbols.set(client.id, new Set<string>());
//     }
    
//     // Add null check before accessing
//     const clientSymbols = this.clientToSymbols.get(client.id);
//     if (clientSymbols) {
//       clientSymbols.add(symbol);
//     }
    
//     // Send cached data if available
//     if (this.marketData.has(symbol)) {
//       client.emit('marketData', this.marketData.get(symbol));
//     }
    
//     // Forward subscription to Python
//     if (this.isPythonReady && this.pythonSocket) {
//       this.pythonSocket.emit('subscribe', { symbols: [symbol] });
//     }
    
//     return { success: true, symbol };
//   }

//   @SubscribeMessage('unsubscribe')
//   handleUnsubscribe(client: Socket, payload: { symbol: string }) {
//     const { symbol } = payload;
//     this.logger.log(`Client ${client.id} unsubscribing from ${symbol}`);
    
//     // Remove from client subscriptions
//     if (this.clientToSymbols.has(client.id)) {
//       // Add null check before accessing
//       const clientSymbols = this.clientToSymbols.get(client.id);
//       if (clientSymbols) {
//         clientSymbols.delete(symbol);
//       }
//     }
    
//     // Check if any other clients are subscribed to this symbol
//     let isSubscribedByOthers = false;
//     for (const [clientId, symbols] of this.clientToSymbols) {
//       if (clientId !== client.id && symbols && symbols.has(symbol)) {
//         isSubscribedByOthers = true;
//         break;
//       }
//     }
    
//     // Unsubscribe from Python if no other clients need this symbol
//     if (!isSubscribedByOthers && this.isPythonReady && this.pythonSocket) {
//       this.pythonSocket.emit('unsubscribe', { symbols: [symbol] });
//     }
    
//     return { success: true, symbol };
//   }

//   private startPythonScript() {
//     try {
//       const scriptPath = path.join(process.cwd(), 'fyers_data.py');
//       this.logger.log(`Starting Python script: ${scriptPath}`);
      
//       this.pythonProcess = spawn('python', [scriptPath], {
//         stdio: ['inherit', 'inherit', 'inherit']
//       });
      
//       this.pythonProcess.on('error', (error) => {
//         this.logger.error(`Failed to start Python script: ${error.message}`);
//       });
      
//       this.pythonProcess.on('close', (code) => {
//         this.logger.log(`Python script exited with code ${code}`);
//         this.isPythonReady = false;
//         this.pythonSocket = null;
//       });
      
//       // Set up event handlers for Python socket connection
//       this.server.on('connection', (socket) => {
//         if (socket.handshake.headers['user-agent']?.includes('python-socketio')) {
//           this.logger.log('Python script connected');
//           this.pythonSocket = socket;
          
//           // Handle market data from Python
//           socket.on('marketData', (data) => {
//             // Log the raw data received from Python
//             this.logger.log(`Raw market data received: ${JSON.stringify(data)}`);
            
//             // Broadcast to all clients - this is the key change
//             this.server.emit('marketData', data);
            
//             // Store the data
//             if (data && data.symbol) {
//               this.marketData.set(data.symbol, data);
//             }
//           });
          
//           // Handle Fyers messages
//           socket.on('fyersMessage', (message) => {
//             this.logger.log(`Fyers message: ${JSON.stringify(message)}`);
//           });
          
//           // Handle Fyers connection status
//           socket.on('fyersReady', () => {
//             this.logger.log('Fyers connection ready');
//             this.isPythonReady = true;
//           });
          
//           socket.on('fyersConnected', () => {
//             this.logger.log('Fyers WebSocket connected');
//           });
          
//           socket.on('fyersDisconnected', () => {
//             this.logger.log('Fyers WebSocket disconnected');
//           });
          
//           socket.on('error', (error) => {
//             this.logger.error(`Fyers error: ${error.message}`);
//           });
//         }
//       });
      
//     } catch (error) {
//       this.logger.error(`Error starting Python script: ${error.message}`);
//     }
//   }
// }



================================================================================
FILE: apps/backend/src/watchlist/watchlist.service.ts
PURPOSE: Watchlist management logic
================================================================================

import { Injectable, NotFoundException, Logger } from '@nestjs/common';
import * as fs from 'fs';
import * as path from 'path';
import { parse } from 'csv-parse';
import * as moment from 'moment';

export interface CompanyMaster {
  company_id: number;
  company_code: string;
  name: string;
  exchange: string;
  marker: string;
}

export interface CompanyData {
  company_code: string;
  name: string;
  exchange: string;
  total_valid_days?: number;
  avg_daily_high_low_range?: number;
  median_daily_volume?: number;
  avg_trading_capital?: number;
  pe_ratio?: number;
  N1_Pattern_count?: number;
}

export interface MergedCompany {
  company_id?: number;
  company_code: string;
  name: string;
  exchange: string;
  marker: string;
  total_valid_days?: number;
  avg_daily_high_low_range?: number;
  median_daily_volume?: number;
  avg_trading_capital?: number;
  pe_ratio?: number;
  N1_Pattern_count?: number;
}

@Injectable()
export class WatchlistService {
  private readonly logger = new Logger(WatchlistService.name);
  private readonly basePath = path.resolve(process.cwd(), 'data', 'watchlists');
  private readonly masterDataPath = path.resolve(process.cwd(), 'data', 'company_master.csv');
  
  private companyMasterCache: CompanyMaster[] = [];
  private cacheLastUpdated: number = 0;
  private readonly cacheValidityMs = 30 * 60 * 1000;

  async getWatchlistData(watchlist: string, date?: string): Promise<MergedCompany[]> {
    const targetDate = date || moment().format('YYYY-MM-DD');
    
    try {
      const companyMaster = await this.loadCompanyMaster();
      const watchlistData = await this.loadWatchlistCSV(watchlist, targetDate);
      const mergedData = this.mergeCompanyData(companyMaster, watchlistData);
      
      this.logger.log(`Merged ${mergedData.length} companies for watchlist ${watchlist}`);
      return mergedData;
      
    } catch (error) {
      this.logger.error(`Error loading watchlist ${watchlist}:`, error);
      throw new NotFoundException(`Failed to load watchlist ${watchlist}: ${error.message}`);
    }
  }

  private async loadCompanyMaster(): Promise<CompanyMaster[]> {
    const now = Date.now();
    if (this.companyMasterCache.length > 0 && (now - this.cacheLastUpdated) < this.cacheValidityMs) {
      return this.companyMasterCache;
    }

    return new Promise((resolve, reject) => {
      if (!fs.existsSync(this.masterDataPath)) {
        this.logger.error(`Company master file not found: ${this.masterDataPath}`);
        return reject(new Error('Company master data file not found'));
      }

      const results: CompanyMaster[] = [];

      fs.createReadStream(this.masterDataPath)
        .pipe(parse({
          delimiter: ',',
          columns: true,
          skip_empty_lines: true,
          trim: true,
        }))
        .on('data', (data) => {
          try {
            // Handle both possible column name formats
            const company: CompanyMaster = {
              company_id: parseInt(data.company_id) || 0,
              company_code: String(data.company_code || '').trim().toUpperCase(),
              name: String(data['NAME OF COMPANY'] || data.name || '').trim(),
              exchange: String(data.Exchange || data.exchange || 'NSE').trim().toUpperCase(),
              marker: String(data.Marker || data.marker || 'EQ').trim().toUpperCase()
            };

            if (company.company_code && company.name) {
              results.push(company);
              this.logger.debug(`Loaded company: ${company.company_code} - ${company.name}`);
            }
          } catch (error) {
            this.logger.warn(`Skipping invalid company master row: ${JSON.stringify(data)}`);
          }
        })
        .on('end', () => {
          this.companyMasterCache = results;
          this.cacheLastUpdated = Date.now();
          this.logger.log(`Loaded ${results.length} companies from master data`);
          resolve(results);
        })
        .on('error', (error) => {
          this.logger.error(`Error reading company master CSV: ${error}`);
          reject(error);
        });
    });
  }

  private async loadWatchlistCSV(watchlist: string, date: string): Promise<CompanyData[]> {
    const fileName = `watchlist_${watchlist}_${date}.csv`;
    const filePath = path.join(this.basePath, fileName);

    return new Promise((resolve, reject) => {
      if (!fs.existsSync(filePath)) {
        this.logger.warn(`Watchlist file not found: ${filePath}, trying fallback dates...`);
        
        const fallbackDates = this.generateFallbackDates(date);
        this.tryFallbackDates(watchlist, fallbackDates)
          .then(resolve)
          .catch(reject);
        return;
      }

      const results: CompanyData[] = [];

      fs.createReadStream(filePath)
        .pipe(parse({
          delimiter: ',',
          columns: true,
          skip_empty_lines: true,
          trim: true,
        }))
        .on('data', (data) => {
          try {
            const company: CompanyData = {
              company_code: String(data.company_code || '').trim().toUpperCase(),
              name: String(data.name || '').trim(),
              exchange: String(data.exchange || 'NSE').trim().toUpperCase(),
              total_valid_days: data.total_valid_days ? Number(data.total_valid_days) : undefined,
              avg_daily_high_low_range: data.avg_daily_high_low_range ? Number(data.avg_daily_high_low_range) : undefined,
              median_daily_volume: data.median_daily_volume ? Number(data.median_daily_volume) : undefined,
              avg_trading_capital: data.avg_trading_capital ? Number(data.avg_trading_capital) : undefined,
              pe_ratio: data.pe_ratio ? Number(data.pe_ratio) : undefined,
              N1_Pattern_count: data.N1_Pattern_count ? Number(data.N1_Pattern_count) : undefined
            };

            if (company.company_code) {
              results.push(company);
              this.logger.debug(`Loaded watchlist company: ${company.company_code} - ${company.name}`);
            }
          } catch (error) {
            this.logger.warn(`Skipping invalid watchlist row: ${JSON.stringify(data)}`);
          }
        })
        .on('end', () => {
          this.logger.log(`Loaded ${results.length} companies from watchlist CSV: ${fileName}`);
          resolve(results);
        })
        .on('error', (error) => {
          this.logger.error(`Error reading watchlist CSV: ${error}`);
          reject(error);
        });
    });
  }

  private async tryFallbackDates(watchlist: string, fallbackDates: string[]): Promise<CompanyData[]> {
    for (const fallbackDate of fallbackDates) {
      const fileName = `watchlist_${watchlist}_${fallbackDate}.csv`;
      const filePath = path.join(this.basePath, fileName);
      
      if (fs.existsSync(filePath)) {
        this.logger.log(`Using fallback date ${fallbackDate} for watchlist ${watchlist}`);
        return this.loadWatchlistCSV(watchlist, fallbackDate);
      }
    }
    
    throw new Error(`No watchlist data found for ${watchlist} on any fallback dates`);
  }

  private generateFallbackDates(targetDate: string): string[] {
    const date = moment(targetDate);
    const fallbacks: string[] = [];
    
    for (let i = 1; i <= 10; i++) {
      fallbacks.push(date.clone().subtract(i, 'days').format('YYYY-MM-DD'));
    }
    
    return fallbacks;
  }

  private mergeCompanyData(masterData: CompanyMaster[], watchlistData: CompanyData[]): MergedCompany[] {
    const mergedResults: MergedCompany[] = [];
    const masterMap = new Map<string, CompanyMaster[]>();

    // Create a map of master data by company_code
    masterData.forEach(master => {
      const key = master.company_code;
      if (!masterMap.has(key)) {
        masterMap.set(key, []);
      }
      masterMap.get(key)!.push(master);
    });

    this.logger.log(`Master data map has ${masterMap.size} unique company codes`);

    // Merge watchlist data with master data
    watchlistData.forEach(watchlistItem => {
      const masterEntries = masterMap.get(watchlistItem.company_code) || [];
      
      if (masterEntries.length === 0) {
        // No master data found, create entry with default marker
        const merged: MergedCompany = {
          company_code: watchlistItem.company_code,
          name: watchlistItem.name,
          exchange: watchlistItem.exchange,
          marker: 'EQ', // Default marker
          total_valid_days: watchlistItem.total_valid_days,
          avg_daily_high_low_range: watchlistItem.avg_daily_high_low_range,
          median_daily_volume: watchlistItem.median_daily_volume,
          avg_trading_capital: watchlistItem.avg_trading_capital,
          pe_ratio: watchlistItem.pe_ratio,
          N1_Pattern_count: watchlistItem.N1_Pattern_count
        };
        mergedResults.push(merged);
        this.logger.warn(`No master data found for company_code: ${watchlistItem.company_code}`);
      } else {
        // Find exact exchange match or use first available
        let masterEntry = masterEntries.find(m => m.exchange === watchlistItem.exchange);
        if (!masterEntry) {
          masterEntry = masterEntries[0];
        }

        const merged: MergedCompany = {
          company_id: masterEntry.company_id,
          company_code: watchlistItem.company_code,
          name: masterEntry.name || watchlistItem.name,
          exchange: watchlistItem.exchange,
          marker: masterEntry.marker,
          total_valid_days: watchlistItem.total_valid_days,
          avg_daily_high_low_range: watchlistItem.avg_daily_high_low_range,
          median_daily_volume: watchlistItem.median_daily_volume,
          avg_trading_capital: watchlistItem.avg_trading_capital,
          pe_ratio: watchlistItem.pe_ratio,
          N1_Pattern_count: watchlistItem.N1_Pattern_count
        };
        
        mergedResults.push(merged);
        this.logger.debug(`Merged: ${merged.company_code} with marker ${merged.marker}`);
      }
    });

    return mergedResults.sort((a, b) => a.name.localeCompare(b.name));
  }

  async getAllCompaniesWithExchange(watchlist: string, date?: string): Promise<MergedCompany[]> {
    const companies = await this.getWatchlistData(watchlist, date);
    
    return companies.filter(company => 
      company.company_code && 
      company.name && 
      company.exchange &&
      ['NSE', 'BSE'].includes(company.exchange.toUpperCase())
    );
  }

  async checkWatchlistExists(watchlist: string, date?: string): Promise<boolean> {
    const targetDate = date || moment().format('YYYY-MM-DD');
    const fileName = `watchlist_${watchlist}_${targetDate}.csv`;
    const filePath = path.join(this.basePath, fileName);
    
    if (fs.existsSync(filePath)) {
      return true;
    }
    
    const fallbackDates = this.generateFallbackDates(targetDate);
    return fallbackDates.some(fallbackDate => {
      const fallbackFileName = `watchlist_${watchlist}_${fallbackDate}.csv`;
      const fallbackPath = path.join(this.basePath, fallbackFileName);
      return fs.existsSync(fallbackPath);
    });
  }

  async getAvailableWatchlists(): Promise<string[]> {
    try {
      const files = fs.readdirSync(this.basePath);
      const watchlistPattern = /^watchlist_([A-Z])_\d{4}-\d{2}-\d{2}\.csv$/;
      const watchlists = new Set<string>();
      
      files.forEach(file => {
        const match = file.match(watchlistPattern);
        if (match) {
          watchlists.add(match[1]);
        }
      });
      
      return Array.from(watchlists).sort();
    } catch (error) {
      this.logger.error('Error reading watchlist directory:', error);
      return [];
    }
  }

  async refreshCompanyMasterCache(): Promise<void> {
    this.companyMasterCache = [];
    this.cacheLastUpdated = 0;
    await this.loadCompanyMaster();
  }

  async getCompanyByCode(companyCode: string, exchange?: string): Promise<MergedCompany | null> {
    const masterData = await this.loadCompanyMaster();
    
    let matches = masterData.filter(company => 
      company.company_code.toUpperCase() === companyCode.toUpperCase()
    );
    
    if (exchange) {
      const exchangeMatch = matches.find(company => 
        company.exchange.toUpperCase() === exchange.toUpperCase()
      );
      if (exchangeMatch) {
        return {
          company_id: exchangeMatch.company_id,
          company_code: exchangeMatch.company_code,
          name: exchangeMatch.name,
          exchange: exchangeMatch.exchange,
          marker: exchangeMatch.marker
        };
      }
    }
    
    if (matches.length > 0) {
      const match = matches[0];
      return {
        company_id: match.company_id,
        company_code: match.company_code,
        name: match.name,
        exchange: match.exchange,
        marker: match.marker
      };
    }
    
    return null;
  }
}


################################################################################
SECTION 2: FRONTEND FILES (NEXT.JS/REACT)
################################################################################

================================================================================
FILE: apps/frontend/app/market-data/page.tsx
PURPOSE: Current market data page
================================================================================

'use client';
import React, { useEffect, useState, useCallback } from 'react';
import { getSocket } from '@/lib/socket';
import dynamic from 'next/dynamic';
import { AppSidebar } from "../components/app-sidebar";
import {
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
  BreadcrumbSeparator,
} from "@/components/ui/breadcrumb";
import { Separator } from "@/components/ui/separator";
import {
  SidebarInset,
  SidebarProvider,
  SidebarTrigger,
} from "@/components/ui/sidebar";
import { ModeToggle } from "../components/toggleButton";
import { Card, CardContent } from "@/components/ui/card";
import { WatchlistSelector } from "../components/controllers/WatchlistSelector";
import { useWatchlist } from "@/hooks/useWatchlist";

const PlotlyChart = dynamic(() => import('./components/charts/PlotlyChart'), { 
  ssr: false,
  loading: () => (
    <div className="w-full h-full flex items-center justify-center bg-zinc-900">
      <div className="animate-pulse text-blue-500">Loading chart...</div>
    </div>
  )
});

interface MarketData {
  symbol: string;
  ltp: number;
  change?: number;
  changePercent?: number;
  open?: number;
  high?: number;
  low?: number;
  close?: number;
  volume?: number;
  bid?: number;
  ask?: number;
  timestamp: number;
  sma_20?: number;
  ema_9?: number;
  rsi_14?: number;
}

interface OHLCData {
  timestamp: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
}

interface TradingHours {
  start: string;
  end: string;
  current: string;
  isActive: boolean;
}

const MarketDataPage: React.FC = () => {
  const [isClient, setIsClient] = useState(false);
  const [selectedSymbol, setSelectedSymbol] = useState<string>('');
  const [selectedCompany, setSelectedCompany] = useState<string | null>(null);
  const [selectedExchange, setSelectedExchange] = useState<string | null>(null);
  const [selectedWatchlist, setSelectedWatchlist] = useState('A');
  
  const [marketData, setMarketData] = useState<Record<string, MarketData>>({});
  const [historicalData, setHistoricalData] = useState<Record<string, MarketData[]>>({});
  const [ohlcData, setOhlcData] = useState<Record<string, OHLCData[]>>({});
  
  const [socketStatus, setSocketStatus] = useState<string>('Disconnected');
  const [lastDataReceived, setLastDataReceived] = useState<Date | null>(null);
  const [dataCount, setDataCount] = useState<number>(0);
  const [tradingHours, setTradingHours] = useState<TradingHours>({
    start: '',
    end: '',
    current: '',
    isActive: false
  });

  const { 
    companies, 
    loading: watchlistLoading, 
    error: watchlistError,
    selectedWatchlist: currentWatchlist,
    setSelectedWatchlist: setWatchlist,
    exists: watchlistExists
  } = useWatchlist();

  const validateAndFormatSymbol = useCallback((companyCode: string, exchange: string, marker: string = 'EQ'): string => {
    const cleanSymbol = companyCode.replace(/[^A-Z0-9]/g, '').toUpperCase();
    
    if (!cleanSymbol || cleanSymbol.length === 0) {
      return '';
    }
    
    switch (exchange.toUpperCase()) {
      case 'NSE':
        return `NSE:${cleanSymbol}-${marker}`;
      case 'BSE':
        return `BSE:${cleanSymbol}-${marker}`;
      default:
        return `${exchange}:${cleanSymbol}-${marker}`;
    }
  }, []);

  const handleCompanyChange = useCallback((companyCode: string | null, exchange?: string, marker?: string) => {
    console.log(`[MarketData] Company selected: ${companyCode} (${exchange}, ${marker})`);
    
    setSelectedCompany(companyCode);
    setSelectedExchange(exchange || null);
    
    if (companyCode && exchange) {
      const formattedSymbol = validateAndFormatSymbol(companyCode, exchange, marker);
      console.log(`[MarketData] Formatted symbol: ${formattedSymbol}`);
      setSelectedSymbol(formattedSymbol);
    } else {
      setSelectedSymbol('');
    }
  }, [validateAndFormatSymbol]);

  const handleWatchlistChange = useCallback((watchlist: string) => {
    console.log(`[MarketData] Watchlist changed to: ${watchlist}`);
    setSelectedWatchlist(watchlist);
    setWatchlist(watchlist);
    setSelectedCompany(null);
    setSelectedSymbol('');
  }, [setWatchlist]);

  useEffect(() => {
    if (companies.length > 0 && !selectedCompany) {
      const firstCompany = companies[0];
      console.log(`[MarketData] Auto-selecting first company: ${firstCompany.company_code}`);
      handleCompanyChange(firstCompany.company_code, firstCompany.exchange, firstCompany.marker);
    }
  }, [companies, selectedCompany, handleCompanyChange]);

  useEffect(() => {
    setIsClient(true);
    console.log('Component mounted, isClient set to true');
  }, []);

  useEffect(() => {
    if (!isClient) return;

    console.log('Connecting to Python WebSocket server...');
    
    const socket = getSocket();

    socket.on('connect', () => {
      console.log(' Connected to Python WebSocket server');
      console.log('Socket ID:', socket.id);
      setSocketStatus('Connected');
      
      socket.emit('get_trading_status', {}, (response: any) => {
        console.log('Trading status:', response);
        setTradingHours({
          start: response.trading_start,
          end: response.trading_end,
          current: response.current_time,
          isActive: response.trading_active
        });
      });
      
      if (selectedSymbol && selectedSymbol.includes(':') && selectedSymbol.includes('-')) {
        console.log('Subscribing to validated symbol:', selectedSymbol);
        socket.emit('subscribe', { symbol: selectedSymbol });
      }
    });

    socket.on('connect_error', (error) => {
      console.error(' Connection error:', error.message);
      setSocketStatus(`Connection error: ${error.message}`);
    });

    socket.on('disconnect', (reason) => {
      console.log(' Disconnected from Python WebSocket server. Reason:', reason);
      setSocketStatus(`Disconnected: ${reason}`);
    });

    socket.on('marketData', (data: MarketData) => {
      console.log(' Received market data:', data);
      setLastDataReceived(new Date());
      setDataCount(prev => prev + 1);
      
      if (data && data.symbol) {
        setMarketData(prev => ({
          ...prev,
          [data.symbol]: data
        }));
        
        setHistoricalData(prev => {
          const symbol = data.symbol;
          const existingHistory = prev[symbol] || [];
          
          const exists = existingHistory.some(item => item.timestamp === data.timestamp);
          if (exists) return prev;
          
          const newHistory = [...existingHistory, data];
          newHistory.sort((a, b) => a.timestamp - b.timestamp);
          
          return {
            ...prev,
            [symbol]: newHistory
          };
        });
      }
    });
    
    socket.on('historicalData', (data: { symbol: string, data: MarketData[] }) => {
      console.log(' Received historical data:', data);
      
      if (data && data.symbol && Array.isArray(data.data)) {
        const sortedData = [...data.data].sort((a, b) => a.timestamp - b.timestamp);
        
        setHistoricalData(prev => ({
          ...prev,
          [data.symbol]: sortedData
        }));
        
        console.log(`Processed ${sortedData.length} historical data points for ${data.symbol}`);
        
        if (marketData[data.symbol] && sortedData.length > 0) {
          const lastHistorical = sortedData[sortedData.length - 1];
          const current = marketData[data.symbol];
          
          if (lastHistorical.timestamp > current.timestamp) {
            setMarketData(prev => ({
              ...prev,
              [data.symbol]: lastHistorical
            }));
          }
        } else if (sortedData.length > 0) {
          setMarketData(prev => ({
            ...prev,
            [data.symbol]: sortedData[sortedData.length - 1]
          }));
        }
      }
    });

    socket.on('ohlcData', (data: { symbol: string, data: OHLCData[] }) => {
      console.log(' Received OHLC data:', data);
      
      if (data && data.symbol && Array.isArray(data.data)) {
        const sortedData = [...data.data].sort((a, b) => a.timestamp - b.timestamp);
        
        setOhlcData(prev => ({
          ...prev,
          [data.symbol]: sortedData
        }));
        
        console.log(`Processed ${sortedData.length} OHLC data points for ${data.symbol}`);
      }
    });
    
    socket.on('heartbeat', (data: any) => {
      setTradingHours(prev => ({
        ...prev,
        current: new Date().toISOString(),
        isActive: data.trading_active
      }));
    });

    const dataCheckInterval = setInterval(() => {
      const now = new Date();
      const lastReceived = lastDataReceived;
      
      if (!lastReceived || now.getTime() - lastReceived.getTime() > 10000) {
        console.warn(' No market data received in the last 10 seconds');
        
        if (socket.connected && selectedSymbol) {
          console.log(' Attempting to resubscribe to:', selectedSymbol);
          socket.emit('subscribe', { symbol: selectedSymbol });
        }
      }
    }, 5000);

    return () => {
      console.log('Component unmounting, cleaning up socket connection');
      clearInterval(dataCheckInterval);
      
      Object.keys(marketData).forEach(symbol => {
        console.log(' Unsubscribing from:', symbol);
        socket.emit('unsubscribe', { symbol });
      });
    };
  }, [isClient, lastDataReceived, selectedSymbol]);

  useEffect(() => {
    if (!isClient) return;
    
    console.log(' Symbol changed to:', selectedSymbol);
    const socket = getSocket();
    
    if (!socket.connected) {
      console.log('Socket not connected, waiting for connection...');
      return;
    }

    Object.keys(marketData).forEach(symbol => {
      if (symbol !== selectedSymbol) {
        console.log(' Unsubscribing from:', symbol);
        socket.emit('unsubscribe', { symbol });
      }
    });
    
    if (selectedSymbol) {
      socket.emit('subscribe', { symbol: selectedSymbol });
      console.log(' Subscribed to:', selectedSymbol);
    }
  }, [selectedSymbol, isClient]);

  const formatPrice = (price?: number) => {
    return price?.toFixed(2) || '0.00';
  };

  const formatChange = (change?: number, percent?: number) => {
    if ((!change && change !== 0) || (!percent && percent !== 0)) return '-';
    const sign = change >= 0 ? '+' : '';
    return `${sign}${change.toFixed(2)} (${sign}${percent.toFixed(2)}%)`;
  };

  const getChangeClass = (change?: number) => {
    if (!change && change !== 0) return '';
    return change >= 0 ? 'text-green-500' : 'text-red-500';
  };

  const currentData = marketData[selectedSymbol];
  const symbolHistory = historicalData[selectedSymbol] || [];
  const symbolOhlc = ohlcData[selectedSymbol] || [];

  if (!isClient) {
    return (
      <SidebarProvider>
        <AppSidebar />
        <SidebarInset>
          <header className="flex h-16 shrink-0 items-center gap-2 w-full">
            <div className="flex items-center gap-2 px-4">
              <SidebarTrigger className="-ml-1" />
              <Separator orientation="vertical" className="mr-2 h-4" />
              <Breadcrumb className="flex items-center justify-end gap-2">
                <BreadcrumbList>
                  <BreadcrumbItem className="hidden md:block">
                    <BreadcrumbLink href="#">
                      Building Your Application
                    </BreadcrumbLink>
                  </BreadcrumbItem>
                  <BreadcrumbSeparator className="hidden md:block" />
                  <BreadcrumbItem>
                    <BreadcrumbPage>Live Market Data</BreadcrumbPage>
                  </BreadcrumbItem>
                </BreadcrumbList>
                <ModeToggle />
              </Breadcrumb>
            </div>
          </header>
          <div className="flex flex-1 flex-col gap-4 p-4 pt-0">
            <div className="container mx-auto p-4 bg-zinc-900 text-white flex items-center justify-center h-[80vh]">
              <div className="text-xl animate-pulse">Loading market data...</div>
            </div>
          </div>
        </SidebarInset>
      </SidebarProvider>
    );
  }

  return (
    <SidebarProvider>
      <AppSidebar />
      <SidebarInset>
        <header className="flex h-16 shrink-0 items-center gap-2 w-full">
          <div className="flex items-center gap-2 px-4">
            <SidebarTrigger className="-ml-1" />
            <Separator orientation="vertical" className="mr-2 h-4" />
            <Breadcrumb className="flex items-center justify-end gap-2">
              <BreadcrumbList>
                <BreadcrumbItem className="hidden md:block">
                  <BreadcrumbLink href="#">
                    Building Your Application
                  </BreadcrumbLink>
                </BreadcrumbItem>
                <BreadcrumbSeparator className="hidden md:block" />
                <BreadcrumbItem>
                  <BreadcrumbPage>Live Market Data</BreadcrumbPage>
                </BreadcrumbItem>
              </BreadcrumbList>
              <ModeToggle />
            </Breadcrumb>
          </div>
        </header>
        
        <div className="flex flex-1 flex-col gap-4 p-4 pt-0">
          {/* Watchlist Selector Card - Same pattern as dashboard */}
          <Card className="w-full">
            <CardContent className="p-4">
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <h3 className="text-lg font-medium">Market Data Watchlist</h3>
                  <div className="flex items-center space-x-2">
                    <span className={`inline-block w-2 h-2 rounded-full ${
                      socketStatus.includes('Connected') ? 'bg-green-500' : 'bg-red-500'
                    }`}></span>
                    <span className="text-sm text-muted-foreground">{socketStatus}</span>
                  </div>
                </div>
                
                <WatchlistSelector
                  onCompanySelect={handleCompanyChange}
                  selectedWatchlist={selectedWatchlist}
                  onWatchlistChange={handleWatchlistChange}
                  showExchangeFilter={true}
                  showMarkerFilter={true}
                />
                
                {/* Status Information */}
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                  <div>
                    <span className="text-muted-foreground">Selected:</span>
                    <div className="font-medium">
                      {selectedCompany ? `${selectedCompany} (${selectedExchange})` : 'None'}
                    </div>
                  </div>
                  <div>
                    <span className="text-muted-foreground">Fyers Symbol:</span>
                    <div className="font-medium">{selectedSymbol || 'None'}</div>
                  </div>
                  <div>
                    <span className="text-muted-foreground">Market Status:</span>
                    <div className={`font-medium ${tradingHours.isActive ? 'text-green-500' : 'text-red-500'}`}>
                      {tradingHours.isActive ? 'Open' : 'Closed'}
                    </div>
                  </div>
                  <div>
                    <span className="text-muted-foreground">Data Points:</span>
                    <div className="font-medium">{symbolHistory.length} historical / {dataCount} updates</div>
                  </div>
                </div>

                {watchlistError && (
                  <div className="bg-red-50 border border-red-200 text-red-700 px-3 py-2 rounded-md text-sm">
                     {watchlistError}
                  </div>
                )}
              </div>
            </CardContent>
          </Card>

          {/* Market Data Display */}
          <div className="min-h-screen bg-zinc-900 text-zinc-100 rounded-lg">
            <div className="container mx-auto p-4">
              <div className="grid grid-cols-1 lg:grid-cols-4 gap-6 mb-6">
                <div className="lg:col-span-3">
                  <div className="bg-zinc-800 p-4 rounded-lg shadow-lg h-[600px]">
                    {symbolHistory.length > 0 ? (
                      <PlotlyChart 
                        symbol={selectedSymbol} 
                        data={currentData} 
                        historicalData={symbolHistory}
                        ohlcData={symbolOhlc}
                        tradingHours={tradingHours}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center">
                        <p className="text-zinc-400">
                          {selectedSymbol ? `Loading historical data for ${selectedSymbol}...` : 'Select a company to view market data'}
                        </p>
                      </div>
                    )}
                  </div>
                </div>
                
                {/* Market Data Panel */}
                <div className="bg-zinc-800 p-4 rounded-lg shadow-lg">
                  {currentData ? (
                    <>
                      <h2 className="text-xl font-semibold mb-2 text-white">{selectedSymbol}</h2>
                      <div className="text-3xl font-bold mb-2 text-white">{formatPrice(currentData.ltp)}</div>
                      <div className={`text-lg ${getChangeClass(currentData.change)}`}>
                        {formatChange(currentData.change, currentData.changePercent)}
                      </div>
                      
                      <div className="grid grid-cols-2 gap-4 mt-6">
                        <div className="bg-zinc-700 p-3 rounded">
                          <div className="text-xs text-zinc-400">Open</div>
                          <div className="text-lg">{formatPrice(currentData.open)}</div>
                        </div>
                        <div className="bg-zinc-700 p-3 rounded">
                          <div className="text-xs text-zinc-400">Prev Close</div>
                          <div className="text-lg">{formatPrice(currentData.close)}</div>
                        </div>
                        <div className="bg-zinc-700 p-3 rounded">
                          <div className="text-xs text-zinc-400">High</div>
                          <div className="text-lg">{formatPrice(currentData.high)}</div>
                        </div>
                        <div className="bg-zinc-700 p-3 rounded">
                          <div className="text-xs text-zinc-400">Low</div>
                          <div className="text-lg">{formatPrice(currentData.low)}</div>
                        </div>
                      </div>
                      
                      <div className="mt-6 border-t border-zinc-700 pt-4">
                        <div className="grid grid-cols-2 gap-y-2">
                          <div>
                            <div className="text-xs text-zinc-400">Bid</div>
                            <div>{formatPrice(currentData.bid)}</div>
                          </div>
                          <div>
                            <div className="text-xs text-zinc-400">Ask</div>
                            <div>{formatPrice(currentData.ask)}</div>
                          </div>
                          <div>
                            <div className="text-xs text-zinc-400">Volume</div>
                            <div>{currentData.volume?.toLocaleString() || '0'}</div>
                          </div>
                          <div>
                            <div className="text-xs text-zinc-400">Last Updated</div>
                            <div>{new Date(currentData.timestamp * 1000).toLocaleTimeString()}</div>
                          </div>
                        </div>
                      </div>
                      
                      {/* Technical Indicators */}
                      {(currentData.sma_20 || currentData.ema_9 || currentData.rsi_14) && (
                        <div className="mt-6 border-t border-zinc-700 pt-4">
                          <h3 className="text-sm font-medium mb-2 text-zinc-300">Technical Indicators</h3>
                          <div className="grid grid-cols-3 gap-2">
                            {currentData.sma_20 && (
                              <div className="bg-zinc-700 p-2 rounded">
                                <div className="text-xs text-orange-500">SMA 20</div>
                                <div className="text-sm">{formatPrice(currentData.sma_20)}</div>
                              </div>
                            )}
                            {currentData.ema_9 && (
                              <div className="bg-zinc-700 p-2 rounded">
                                <div className="text-xs text-purple-500">EMA 9</div>
                                <div className="text-sm">{formatPrice(currentData.ema_9)}</div>
                              </div>
                            )}
                            {currentData.rsi_14 && (
                              <div className="bg-zinc-700 p-2 rounded">
                                <div className="text-xs text-cyan-500">RSI 14</div>
                                <div className="text-sm">{currentData.rsi_14.toFixed(2)}</div>
                              </div>
                            )}
                          </div>
                        </div>
                      )}
                    </>
                  ) : (
                    <div className="text-center py-8">
                      <p className="text-zinc-400">
                        {selectedSymbol ? 'Waiting for market data...' : 'Select a company to view data'}
                      </p>
                    </div>
                  )}
                </div>
              </div>
              
              {/* Debug section */}
              <div className="mt-8 p-4 bg-zinc-800 rounded-lg shadow-lg">
                <div className="flex justify-between items-center mb-2">
                  <h3 className="text-lg font-semibold text-white">Raw Market Data</h3>
                  <div className="text-xs text-zinc-400">
                    {symbolHistory.length > 0 && tradingHours.start && (
                      <>
                        Trading Hours: {new Date(tradingHours.start).toLocaleTimeString()} - {new Date(tradingHours.end).toLocaleTimeString()}
                      </>
                    )}
                  </div>
                </div>
                {currentData ? (
                  <pre className="text-xs overflow-auto max-h-60 bg-zinc-900 p-4 rounded text-zinc-300">
                    {JSON.stringify(currentData, null, 2)}
                  </pre>
                ) : (
                  <p className="text-zinc-400">No data received yet. Check console for connection details.</p>
                )}
              </div>
            </div>
          </div>
        </div>
      </SidebarInset>
    </SidebarProvider>
  );
};

export default MarketDataPage;


================================================================================
FILE: apps/frontend/app/market-data/components/MarketChart.tsx
PURPOSE: Existing chart component
================================================================================

'use client';
import React, { useEffect, useRef, useState } from 'react';
import { createChart, ColorType, ISeriesApi, UTCTimestamp, LineData } from 'lightweight-charts';

interface MarketData {
  ltp: number;
  timestamp: number;
}

interface MarketChartProps {
  symbol: string;
  data: MarketData | null | undefined;
}

const MarketChart: React.FC<MarketChartProps> = ({ symbol, data }) => {
  const chartContainerRef = useRef<HTMLDivElement>(null);
  const chartRef = useRef<ReturnType<typeof createChart> | null>(null);
  const seriesRef = useRef<ISeriesApi<'Line'> | null>(null);
  const [isChartInitialized, setIsChartInitialized] = useState(false);
  const dataPointsRef = useRef<LineData[]>([]);
  const [isClient, setIsClient] = useState(false);
  const [chartHeight] = useState(500);
  const [initializationAttempt, setInitializationAttempt] = useState(0);

  useEffect(() => {
    setIsClient(true);
    console.log('MarketChart component mounted');
  }, []);

  const createDummyData = () => {
    const now = Math.floor(Date.now() / 1000);
    const initialData: LineData[] = [];
    
    for (let i = 10; i > 0; i--) {
      initialData.push({
        time: (now - i * 60) as UTCTimestamp,
        value: data?.ltp || 100 + Math.random() * 10
      });
    }
    
    return initialData;
  };

  const initializeChart = () => {
    if (!chartContainerRef.current) {
      console.log('Chart container ref is not available');
      return false;
    }

    try {
      const initialData = createDummyData();
      dataPointsRef.current = initialData;
      
      const containerWidth = chartContainerRef.current.clientWidth;
      const containerHeight = chartContainerRef.current.clientHeight;
      
      console.log(`Container dimensions: ${containerWidth}x${containerHeight}`);
      
      if (containerWidth <= 0 || containerHeight <= 0) {
        console.log('Container has zero dimensions, will retry');
        return false;
      }
      
      chartRef.current = createChart(chartContainerRef.current, {
        width: containerWidth,
        height: chartHeight,
        layout: {
          background: { type: ColorType.Solid, color: 'white' },
          textColor: '#333',
          fontSize: 12,
        },
        grid: {
          vertLines: { color: '#f0f0f0' },
          horzLines: { color: '#f0f0f0' },
        },
        timeScale: {
          timeVisible: true,
          secondsVisible: true,
          minBarSpacing: 10,
          fixLeftEdge: true,
          fixRightEdge: true,
        },
        rightPriceScale: {
          scaleMargins: {
            top: 0.1,
            bottom: 0.1,
          },
          borderVisible: false,
        },
        crosshair: {
          mode: 1,
        },
        handleScroll: true,
        handleScale: true,
      });
      
      seriesRef.current = chartRef.current.addSeries({
        color: '#2962FF',
        lineWidth: 2,
        lastValueVisible: true,
        priceLineVisible: true,
        title: symbol,
      });
      
      seriesRef.current.setData(initialData);
      
      chartRef.current.timeScale().fitContent();
      
      setIsChartInitialized(true);
      console.log('Chart initialized successfully');
      return true;
      
    } catch (error) {
      console.error('Error initializing chart:', error);
      
      if (chartRef.current) {
        try {
          chartRef.current.remove();
        } catch (e) {
          console.error('Error removing chart during cleanup:', e);
        }
        chartRef.current = null;
        seriesRef.current = null;
      }
      
      return false;
    }
  };

  useEffect(() => {
    if (!isClient || !chartContainerRef.current || chartRef.current) return;
    
    const frameId = requestAnimationFrame(() => {
      setTimeout(() => {
        const success = initializeChart();
        
        if (!success && initializationAttempt < 5) {
          setInitializationAttempt(prev => prev + 1);
        }
      }, 300); 
    });
    
    return () => {
      cancelAnimationFrame(frameId);
    };
  }, [isClient, initializationAttempt]);
  
  useEffect(() => {
    if (!isClient) return;
    
    const handleResize = () => {
      if (chartRef.current && chartContainerRef.current) {
        const width = chartContainerRef.current.clientWidth;
        if (width > 0) {
          chartRef.current.resize(width, chartHeight);
          chartRef.current.timeScale().fitContent();
        }
      }
    };
    
    window.addEventListener('resize', handleResize);
    
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, [isClient, chartHeight]);
  
  useEffect(() => {
    return () => {
      if (chartRef.current) {
        try {
          chartRef.current.remove();
        } catch (e) {
          console.error('Error removing chart:', e);
        }
        chartRef.current = null;
        seriesRef.current = null;
        setIsChartInitialized(false);
      }
    };
  }, []);
  
  useEffect(() => {
    if (
      !isClient || 
      !isChartInitialized ||
      !seriesRef.current ||
      !data ||
      typeof data.ltp !== 'number' ||
      typeof data.timestamp !== 'number'
    ) {
      return;
    }

    try {
      const newTime = Math.floor(data.timestamp) as UTCTimestamp;
      const newValue = data.ltp;
      
      const existingIndex = dataPointsRef.current.findIndex(p => p.time === newTime);
      
      if (existingIndex >= 0) {
        dataPointsRef.current[existingIndex].value = newValue;
        
        const sortedData = [...dataPointsRef.current].sort((a, b) => 
          (a.time as number) - (b.time as number)
        );
        seriesRef.current.setData(sortedData);
      } else {
        const newPoint: LineData = { time: newTime, value: newValue };
        dataPointsRef.current.push(newPoint);
        
        dataPointsRef.current.sort((a, b) => (a.time as number) - (b.time as number));
        
        seriesRef.current.update(newPoint);
      }
      
      if (dataPointsRef.current.length > 300) {
        dataPointsRef.current = dataPointsRef.current.slice(-300);
      }
      
      if (chartRef.current) {
        chartRef.current.timeScale().scrollToRealTime();
      }
    } catch (error) {
      console.error('Error updating chart:', error);
      
      if (seriesRef.current && dataPointsRef.current.length > 0) {
        try {
          console.log('Attempting recovery by setting all data');
          const sortedData = [...dataPointsRef.current].sort((a, b) => 
            (a.time as number) - (b.time as number)
          );
          seriesRef.current.setData(sortedData);
        } catch (recoveryError) {
          console.error('Recovery failed:', recoveryError);
        }
      }
    }
  }, [data, isChartInitialized, isClient]);

  useEffect(() => {
    if (!isClient || !isChartInitialized || !seriesRef.current) return;
    
    console.log(`Symbol changed to ${symbol}. Resetting chart data.`);
    
    try {
      const initialData = createDummyData();
      dataPointsRef.current = initialData;
      
      seriesRef.current.setData(initialData);
      
      seriesRef.current.applyOptions({
        title: symbol
      });
      
      if (chartRef.current) {
        chartRef.current.timeScale().fitContent();
      }
    } catch (error) {
      console.error('Error resetting chart on symbol change:', error);
    }
  }, [symbol, isChartInitialized, isClient]);

  if (!isClient) {
    return (
      <div className="w-full h-[500px] bg-gray-100 flex items-center justify-center">
        <div className="text-gray-500">Loading chart...</div>
      </div>
    );
  }

  return (
    <div className="relative w-full h-[500px] border border-gray-200 rounded shadow-sm bg-white overflow-hidden">
      {/* Chart title */}
      <div className="absolute top-2 left-2 z-10 text-sm font-medium text-gray-700">
        {symbol} Price Chart
      </div>
      
      {/* Chart container - explicit dimensions are crucial */}
      <div 
        className="w-full h-full" 
        style={{ 
          width: '100%',
          height: '100%',
          minWidth: '300px',
          minHeight: '300px'
        }} 
        ref={chartContainerRef}
      />
      
      {/* Loading overlay */}
      {!isChartInitialized && (
        <div className="absolute inset-0 bg-white bg-opacity-70 flex items-center justify-center">
          <div className="text-blue-500">
            {initializationAttempt > 0 
              ? `Initializing chart (attempt ${initializationAttempt}/5)...` 
              : 'Initializing chart...'}
          </div>
        </div>
      )}
    </div>
  );
};

export default MarketChart;


================================================================================
FILE: apps/frontend/app/market-data/components/MarketDataTable.tsx
PURPOSE: Data table component
================================================================================

import React from 'react';

interface MarketData {
  ltp: number;
  change: number;
  changePercent: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
  timestamp: number;
}

interface MarketDataTableProps {
  data: Record<string, MarketData>;
  onSymbolSelect: (symbol: string) => void;
  onRemoveSymbol: (symbol: string) => void;
  selectedSymbol: string;
}

const MarketDataTable: React.FC<MarketDataTableProps> = ({
  data,
  onSymbolSelect,
  onRemoveSymbol,
  selectedSymbol,
}) => {
  return (
    <div className="overflow-x-auto">
      <table className="w-full">
        <thead>
          <tr className="border-b">
            <th className="text-left py-2">Symbol</th>
            <th className="text-right py-2">LTP</th>
            <th className="text-right py-2">Change</th>
            <th className="text-right py-2">%Change</th>
            <th className="text-right py-2">Volume</th>
            <th className="text-center py-2">Actions</th>
          </tr>
        </thead>
        <tbody>
          {Object.entries(data).map(([symbol, marketData]) => (
            <tr 
              key={symbol}
              className={`border-b hover:bg-muted/50 cursor-pointer ${
                selectedSymbol === symbol ? 'bg-muted' : ''
              }`}
              onClick={() => onSymbolSelect(symbol)}
            >
              <td className="py-3 font-medium">{symbol}</td>
              <td className="text-right py-3">{marketData.ltp.toFixed(2)}</td>
              <td 
                className={`text-right py-3 ${
                  marketData.change >= 0 ? 'text-green-500' : 'text-red-500'
                }`}
              >
                {marketData.change >= 0 ? '+' : ''}
                {marketData.change.toFixed(2)}
              </td>
              <td 
                className={`text-right py-3 ${
                  marketData.changePercent >= 0 ? 'text-green-500' : 'text-red-500'
                }`}
              >
                {marketData.changePercent >= 0 ? '+' : ''}
                {marketData.changePercent.toFixed(2)}%
              </td>
              <td className="text-right py-3">{marketData.volume.toLocaleString()}</td>
              <td className="text-center py-3">
                <button
                  className="text-red-500 hover:text-red-700"
                  onClick={(e) => {
                    e.stopPropagation();
                    onRemoveSymbol(symbol);
                  }}
                >
                  Remove
                </button>
              </td>
            </tr>
          ))}
          
          {Object.keys(data).length === 0 && (
            <tr>
              <td colSpan={6} className="py-4 text-center text-muted-foreground">
                No symbols in watchlist. Add symbols to get started.
              </td>
            </tr>
          )}
        </tbody>
      </table>
    </div>
  );
};

export default MarketDataTable;


================================================================================
FILE: apps/frontend/app/components/charts/StockChart.tsx
PURPOSE: Stock chart implementation
================================================================================

'use client'
import React, { useMemo, useState, useEffect, useRef, useCallback } from 'react';
import dynamic from 'next/dynamic';
import { 
  LineChart, 
  CandlestickChart, 
  BarChart3, 
  TrendingUp, 
  Settings, 
  Palette,
  Grid3X3,
  MousePointer,
  Eraser,
  Circle,
  Square,
  Minus,
  ZoomIn,
  ZoomOut,
  RotateCcw,
  Sun,
  Moon,
  Eye,
  EyeOff,
  Clock,
  Maximize2,
  Minimize2,
  Monitor,
  Smartphone
} from 'lucide-react';

const Plot = dynamic(() => import('react-plotly.js'), { ssr: false });

const CHART_PERFORMANCE_CONFIG = {
  MAX_VISIBLE_POINTS: 2000,
  CHUNK_SIZE: 1000,
  WEBGL_THRESHOLD: 5000,
  MARKET_OPEN_MINUTES: 9 * 60 + 15,
  MARKET_CLOSE_MINUTES: 15 * 60 + 30,
  IST_OFFSET: 5.5 * 60 * 60 * 1000,
  ZOOM_WINDOW_MINUTES: 15,
  PRICE_PADDING_PERCENT: 0.08,
  SIDEBAR_WIDTH: 280,
  MIN_CHART_WIDTH: 400,
  MIN_CHART_HEIGHT: 300,
  RESIZE_DEBOUNCE_MS: 150,
  AUTO_RESIZE_ENABLED: true,
  RESPONSIVE_BREAKPOINTS: {
    MOBILE: 768,
    TABLET: 1024,
    DESKTOP: 1440
  },
  ASPECT_RATIOS: {
    WIDESCREEN: 16/9,
    STANDARD: 4/3,
    SQUARE: 1/1
  },
  RELAYOUT_DEBOUNCE: 500,
  UPDATE_DEBOUNCE: 500,
  STABLE_UI_REVISION: 'stable-v1',
  PRICE_CHART_HEIGHT_RATIO: 0.60, 
  VOLUME_CHART_HEIGHT_RATIO: 0.40, 
  INDICATOR_CHART_HEIGHT: 120, 
  CHART_GAP: 2 
};

const MARKET_HOLIDAYS_2025 = [
  // 2023 Holidays
  '2023-01-26',   // Republic Day
  '2023-03-07',   // Holi
  '2023-03-30',   // Ram Navami
  '2023-04-04',   // Mahavir Jayanti
  '2023-04-07',   // Good Friday
  '2023-04-14',   // Dr. Baba Saheb Ambedkar Jayanti
  '2023-04-22',   // Id-Ul-Fitr (Ramzan Id)
  '2023-05-01',   // Maharashtra Day
  '2023-06-28',   // Bakri Id
  '2023-08-15',   // Independence Day
  '2023-09-19',   // Ganesh Chaturthi
  '2023-10-02',   // Mahatma Gandhi Jayanti
  '2023-10-24',   // Dussehra
  '2023-11-12',   // Diwali Laxmi Pujan
  '2023-11-27',   // Gurunanak Jayanti
  '2023-12-25',   // Christmas

  // 2024 Holidays
  '2024-01-26',   // Republic Day
  '2024-03-08',   // Maha Shivaratri
  '2024-03-25',   // Holi
  '2024-03-29',   // Good Friday
  '2024-04-11',   // Id-Ul-Fitr (Ramzan Id)
  '2024-04-17',   // Ram Navami
  '2024-05-01',   // Maharashtra Day
  '2024-06-17',   // Bakri Id
  '2024-07-17',   // Muharram
  '2024-08-15',   // Independence Day
  '2024-10-02',   // Mahatma Gandhi Jayanti
  '2024-11-01',   // Diwali Laxmi Pujan
  '2024-11-15',   // Gurunanak Jayanti
  '2024-12-25',   // Christmas

  // 2025 Holidays
  '2025-02-26',   // Mahashivratri
  '2025-03-14',   // Holi
  '2025-03-31',   // Id-Ul-Fitra (Ramzan Id)
  '2025-04-10',   // Shri Mahavir Jayanti
  '2025-04-14',   // Dr. Baba Saheb Ambedkar Jayanti
  '2025-04-18',   // Good Friday
  '2025-05-01',   // Maharashtra Day
  '2025-08-15',   // Independence Day
  '2025-08-27',   // Ganesh Chaturthi
  '2025-10-02',   // Mahatma Gandhi Jayanti/Dussehra
  '2025-10-21',   // Diwali Laxmi Pujan
  '2025-10-22',   // Diwali Balipratipada
  '2025-11-05',   // Prakash Gurpurb Sri Guru Nanak Dev Jayanti
  '2025-12-25'    // Christmas
];

const STABLE_RANGEBREAKS = [
  { 
    bounds: ['sat', 'mon'], 
    pattern: 'day of week' 
  },
  { 
    bounds: [15.5, 9.25], 
    pattern: 'hour' 
  },
  {
    values: MARKET_HOLIDAYS_2025
  }
];

const availableIndicators = [
  { id: 'ma', name: 'Moving Average', periods: [5, 9, 20, 50, 100, 200], color: '#ffffff' },
  { id: 'ema', name: 'Exponential MA', periods: [5, 9, 20, 50, 100, 200], color: '#ffffff' },
  { id: 'bollinger', name: 'Bollinger Bands', period: 20, stdDev: 2, color: '#ffffff' },
  { id: 'rsi', name: 'RSI', period: 14, color: '#ffffff' },
  { id: 'macd', name: 'MACD', fastPeriod: 12, slowPeriod: 26, signalPeriod: 9, color: '#ffffff' },
];

const chartTypes = [
  { id: 'candlestick', name: 'Candlestick', icon: CandlestickChart },
  { id: 'ohlc', name: 'OHLC', icon: BarChart3 },
  { id: 'line', name: 'Line', icon: LineChart },
  { id: 'area', name: 'Area', icon: TrendingUp },
  { id: 'heiken-ashi', name: 'Heiken Ashi', icon: CandlestickChart }
];

const timeIntervals = [
  { id: '1m', name: '1m' },
  { id: '5m', name: '5m' },
  { id: '10m', name: '10m' },
  { id: '15m', name: '15m' },
  { id: '30m', name: '30m' },
  { id: '1h', name: '1h' },
  { id: '1d', name: '1D' }
];

const drawingTools = [
  { id: 'drawline', name: 'Trend Line', icon: Minus },
  { id: 'drawrect', name: 'Rectangle', icon: Square },
  { id: 'drawcircle', name: 'Circle', icon: Circle },
  { id: 'drawopenpath', name: 'Free Draw', icon: MousePointer },
  { id: 'eraseshape', name: 'Eraser', icon: Eraser }
];

interface StockDataPoint {
  interval_start: string;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
}

interface StockChartProps {
  companyId: string | null;
  data?: StockDataPoint[];
  startDate?: Date;
  endDate?: Date;
  interval?: string;
  indicators?: string[];
  loading?: boolean;
  error?: string | null;
  height?: number;
  width?: number;
  defaultChartType?: string;
  showControls?: boolean;
  theme?: 'light' | 'dark';
  onThemeChange?: (theme: 'light' | 'dark') => void;
  onIntervalChange?: (interval: string) => void;
  onRangeChange?: (startDate: Date, endDate: Date) => Promise<void>;
}

const LoadingIndicator = ({ show }: { show: boolean }) => {
  if (!show) return null;
  
  return (
    <div 
      className="fixed top-4 right-4 z-50 bg-gradient-to-r from-blue-500 to-blue-600 text-white px-6 py-3 rounded-lg shadow-2xl"
      style={{
        animation: 'slideInScale 0.3s ease-out forwards',
        transformOrigin: 'top right'
      }}
    >
      <div className="flex items-center space-x-3">
        <div 
          className="w-5 h-5 border-2 border-white border-t-transparent rounded-full"
          style={{
            animation: 'spin 1s linear infinite'
          }}
        ></div>
        <div className="flex flex-col">
          <span className="text-sm font-semibold">Loading Chart Data</span>
          <span className="text-xs opacity-90">Expanding timeline...</span>
        </div>
      </div>
      
      <div className="mt-2 w-full bg-blue-300 bg-opacity-30 rounded-full h-1">
        <div 
          className="bg-white h-1 rounded-full"
          style={{
            animation: 'progress 2s ease-in-out infinite'
          }}
        ></div>
      </div>
    </div>
  );
};

const isMarketHours = (date: Date): boolean => {
  const day = date.getDay();
  const hours = date.getHours();
  const minutes = date.getMinutes();
  const timeInMinutes = hours * 60 + minutes;
  
  if (day === 0 || day === 6) return false;
  
  return timeInMinutes >= CHART_PERFORMANCE_CONFIG.MARKET_OPEN_MINUTES && 
         timeInMinutes <= CHART_PERFORMANCE_CONFIG.MARKET_CLOSE_MINUTES;
};

const filterMarketHoursData = (data: StockDataPoint[]): StockDataPoint[] => {
  if (!data || !data.length) return [];
  
  return data.filter(item => {
    const date = new Date(item.interval_start);
    return isMarketHours(date);
  });
};

const generateMarketTimeline = (startDate: Date, endDate: Date, intervalMinutes: number): Date[] => {
  const timeline: Date[] = [];
  const current = new Date(startDate);
  
  while (current <= endDate) {
    if (isMarketHours(current)) {
      timeline.push(new Date(current));
    }
    current.setMinutes(current.getMinutes() + intervalMinutes);
  }
  
  return timeline;
};

export function StockChart({
  companyId,
  data = [],
  startDate,
  endDate,
  interval = '1m',
  indicators = [],
  loading = false,
  error = null,
  height = 1000,
  width = 1200,
  defaultChartType = 'candlestick',
  showControls = true,
  theme = 'dark',
  onThemeChange,
  onIntervalChange,
  onRangeChange
}: StockChartProps) {
  
  const [selectedInterval, setSelectedInterval] = useState(interval);
  const [selectedChartType, setSelectedChartType] = useState(defaultChartType);
  const [activeIndicators, setActiveIndicators] = useState<string[]>(indicators);
  const [selectedMAperiods, setSelectedMAperiods] = useState<number[]>([20, 50]);
  const [selectedEMAperiods, setSelectedEMAperiods] = useState<number[]>([9, 21]);
  const [showVolume, setShowVolume] = useState(true);
  const [showGridlines, setShowGridlines] = useState(true);
  const [logScale, setLogScale] = useState(false);
  const [crosshair, setCrosshair] = useState(true);
  const [sidebarVisible, setSidebarVisible] = useState(showControls);
  const [chartTheme, setChartTheme] = useState<'light' | 'dark'>(theme);
  
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [autoResize, setAutoResize] = useState(CHART_PERFORMANCE_CONFIG.AUTO_RESIZE_ENABLED);
  const [responsiveMode, setResponsiveMode] = useState<'auto' | 'manual'>('auto');
  const [aspectRatio, setAspectRatio] = useState<keyof typeof CHART_PERFORMANCE_CONFIG.ASPECT_RATIOS>('WIDESCREEN');
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 });
  const [chartDimensions, setChartDimensions] = useState({ width: 0, height: 0 });
  const [viewportSize, setViewportSize] = useState({ width: 0, height: 0 });
  const [deviceType, setDeviceType] = useState<'mobile' | 'tablet' | 'desktop'>('desktop');
  
  const [drawingMode, setDrawingMode] = useState<string | null>(null);
  const [annotations, setAnnotations] = useState<any[]>([]);
  const [autoRefresh, setAutoRefresh] = useState(false);
  const [refreshInterval, setRefreshInterval] = useState(5000);
  const [alertsEnabled, setAlertsEnabled] = useState(false);
  const [priceAlerts, setPriceAlerts] = useState<any[]>([]);
  
  const [priceChartHeight, setPriceChartHeight] = useState(0);
  const [volumeChartHeight, setVolumeChartHeight] = useState(0);
  const [rsiChartHeight, setRsiChartHeight] = useState(0);
  const [macdChartHeight, setMacdChartHeight] = useState(0);
  const [syncedXRange, setSyncedXRange] = useState<[string, string] | null>(null);
  
  const priceChartRef = useRef<any>(null);
  const volumeChartRef = useRef<any>(null);
  const rsiChartRef = useRef<any>(null);
  const macdChartRef = useRef<any>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const chartContainerRef = useRef<HTMLDivElement>(null);
  const resizeObserverRef = useRef<ResizeObserver | null>(null);
  const resizeTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  
  const [isLoadingMoreData, setIsLoadingMoreData] = useState(false);
  const [loadingStartTime, setLoadingStartTime] = useState<number | null>(null);
  const [showLoadingIndicator, setShowLoadingIndicator] = useState(false);
  const [dataRange, setDataRange] = useState<{ start: Date | null; end: Date | null }>({ start: null, end: null });
  const [allData, setAllData] = useState<StockDataPoint[]>([]);
  const loadingTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const lastFetchRangeRef = useRef<{ start: Date; end: Date } | null>(null);
  const [xRange, setXRange] = useState<[string, string] | null>(null);
  const [yRange, setYRange] = useState<[number, number] | null>(null);
  
  const loadingControllerRef = useRef<AbortController | null>(null);
  const minimumLoadingTimeRef = useRef<NodeJS.Timeout | null>(null);
  const stableTimelineRef = useRef<Date[]>([]);
  const relayoutTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const [isUserInteracting, setIsUserInteracting] = useState(false);
  const interactionTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    const loadingStyles = `
      @keyframes slideInScale {
        0% {
          opacity: 0;
          transform: translateX(100%) scale(0.8);
        }
        100% {
          opacity: 1;
          transform: translateX(0) scale(1);
        }
      }
      
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      
      @keyframes progress {
        0% { width: 0%; }
        50% { width: 70%; }
        100% { width: 100%; }
      }
    `;
    
    const styleSheet = document.createElement('style');
    styleSheet.textContent = loadingStyles;
    document.head.appendChild(styleSheet);
    
    return () => {
      if (document.head.contains(styleSheet)) {
        document.head.removeChild(styleSheet);
      }
    };
  }, []);

  const getIntervalInMs = useCallback((intervalStr: string): number => {
    const intervalMap: { [key: string]: number } = {
      '1m': 60 * 1000,
      '5m': 5 * 60 * 1000,
      '10m': 10 * 60 * 1000,
      '15m': 15 * 60 * 1000,
      '30m': 30 * 60 * 1000,
      '1h': 60 * 60 * 1000,
      '1d': 24 * 60 * 60 * 1000
    };
    return intervalMap[intervalStr] || 60 * 1000;
  }, []);

  const detectDataGaps = useCallback((visibleRange: [string, string]) => {
    if (!allData || allData.length === 0) {
      return null;
    }
    
    try {
      const [visibleStartStr, visibleEndStr] = visibleRange;
      const visibleStart = new Date(visibleStartStr);
      const visibleEnd = new Date(visibleEndStr);
      
      if (isNaN(visibleStart.getTime()) || isNaN(visibleEnd.getTime())) {
        return null;
      }
      
      const dataStart = new Date(allData[0].interval_start);
      const dataEnd = new Date(allData[allData.length - 1].interval_start);
      
      const gaps = [];
      const bufferTime = 30 * 60 * 1000;
      
      if (visibleStart < dataStart) {
        const gapStart = new Date(visibleStart.getTime() - bufferTime);
        gaps.push({
          type: 'before',
          start: gapStart,
          end: dataStart,
          priority: 'high'
        });
      }
      
      if (visibleEnd > dataEnd) {
        const gapEnd = new Date(visibleEnd.getTime() + bufferTime);
        gaps.push({
          type: 'after',
          start: dataEnd,
          end: gapEnd,
          priority: 'high'
        });
      }
      
      if (allData.length > 1) {
        const intervalMs = getIntervalInMs(selectedInterval);
        const maxGap = intervalMs * 3;
        
        for (let i = 1; i < allData.length; i++) {
          const currentTime = new Date(allData[i].interval_start).getTime();
          const previousTime = new Date(allData[i - 1].interval_start).getTime();
          const actualGap = currentTime - previousTime;
          
          if (actualGap > maxGap) {
            gaps.push({
              type: 'internal',
              start: new Date(previousTime + intervalMs),
              end: new Date(currentTime - intervalMs),
              priority: 'medium'
            });
          }
        }
      }
      
      return gaps.length > 0 ? gaps : null;
      
    } catch (error) {
      console.error('Error in detectDataGaps:', error);
      return null;
    }
  }, [allData, selectedInterval, getIntervalInMs]);

  const fetchMissingData = useCallback(async (gaps: Array<{type: string, start: Date, end: Date, priority?: string}>) => {
    if (!companyId || isLoadingMoreData) {
      console.log('Skipping fetch: no companyId or already loading');
      return;
    }
    
    const startTime = Date.now();
    setLoadingStartTime(startTime);
    setIsLoadingMoreData(true);
    
    const loadingDelay = setTimeout(() => {
      setShowLoadingIndicator(true);
    }, 300);
    
    if (loadingControllerRef.current) {
      loadingControllerRef.current.abort();
    }
    loadingControllerRef.current = new AbortController();
    
    try {
      console.log('Fetching data for gaps:', gaps);
      
      const fetchPromises = gaps.map(async (gap) => {
        if (lastFetchRangeRef.current) {
          const overlap = gap.start >= lastFetchRangeRef.current.start && 
                         gap.end <= lastFetchRangeRef.current.end;
          if (overlap) {
            console.log('Skipping duplicate fetch for gap:', gap);
            return [];
          }
        }
        
        try {
          const params = new URLSearchParams({
            exchange: 'NSE',
            startDate: gap.start.toISOString(),
            endDate: gap.end.toISOString(),
            interval: selectedInterval,
            indicators: activeIndicators.join(','),
            fetchType: 'incremental',
            gapType: gap.type || 'unknown'
          });
          
          const apiUrl = `/api/companies/${companyId}/ohlcv?${params}`;
          console.log('Fetching from:', apiUrl);
          
          const response = await fetch(apiUrl, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json',
              'Cache-Control': 'no-cache',
              'Accept': 'application/json'
            },
            signal: loadingControllerRef.current?.signal
          });
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error(`API Error ${response.status}:`, errorText);
            
            if (response.status === 404) {
              console.warn('API endpoint not found - check your backend');
              return [];
            } else if (response.status === 429) {
              console.warn('Rate limited - backing off');
              await new Promise(resolve => setTimeout(resolve, 1000));
              return [];
            }
            
            throw new Error(`API Error ${response.status}: ${errorText}`);
          }
          
          const responseData = await response.json();
          console.log('API Response:', responseData);
          
          let newData = [];
          if (Array.isArray(responseData)) {
            newData = responseData;
          } else if (responseData.data && Array.isArray(responseData.data)) {
            newData = responseData.data;
          } else if (responseData.results && Array.isArray(responseData.results)) {
            newData = responseData.results;
          } else if (responseData.ohlcv && Array.isArray(responseData.ohlcv)) {
            newData = responseData.ohlcv;
          } else {
            console.warn('Unexpected API response format:', responseData);
            return [];
          }
          
          if (newData.length === 0) {
            console.warn('No data returned from API for gap:', gap);
            return [];
          }
          
          lastFetchRangeRef.current = { start: gap.start, end: gap.end };
          
          const normalizedData = newData
            .map((item: any) => {
              try {
                return {
                  interval_start: typeof item.interval_start === 'string' 
                    ? item.interval_start 
                    : new Date(item.interval_start || item.timestamp || item.time).toISOString(),
                  open: Number(item.open || item.o) || 0,
                  high: Number(item.high || item.h) || 0,
                  low: Number(item.low || item.l) || 0,
                  close: Number(item.close || item.c) || 0,
                  volume: Number(item.volume || item.v) || 0
                };
              } catch (error) {
                console.error('Error normalizing data item:', item, error);
                return null;
              }
            })
            .filter((item): item is StockDataPoint => item !== null);
          
          console.log(`Normalized ${normalizedData.length} data points for gap:`, gap);
          
          return filterMarketHoursData(normalizedData);
          
        } catch (error) {
          if (error.name === 'AbortError') {
            console.log('Fetch aborted');
            return [];
          }
          console.error(`Error fetching gap data for ${gap.type}:`, error);
          
          return [];
        }
      });
      
      const results = await Promise.all(fetchPromises);
      const newDataPoints = results.flat();
      
      console.log(`Total new data points fetched: ${newDataPoints.length}`);
      
      if (newDataPoints.length > 0) {
        setAllData(prevData => {
          const combined = [...prevData, ...newDataPoints];
          
          const uniqueMap = new Map();
          combined.forEach(item => {
            const key = item.interval_start;
            const date = new Date(item.interval_start);
            
            if (!uniqueMap.has(key) || 
                (item.volume > 0 && uniqueMap.get(key).volume === 0)) {
              uniqueMap.set(key, item);
            }
          });
          
          const sortedData = Array.from(uniqueMap.values()).sort((a, b) => 
            new Date(a.interval_start).getTime() - new Date(b.interval_start).getTime()
          );
          
          console.log(`Final data array length: ${sortedData.length}`);
          return sortedData;
        });
        
        setDataRange(prev => {
          const allDates = newDataPoints.map(d => new Date(d.interval_start));
          const newStart = new Date(Math.min(...allDates.map(d => d.getTime())));
          const newEnd = new Date(Math.max(...allDates.map(d => d.getTime())));
          
          return {
            start: prev.start ? (newStart < prev.start ? newStart : prev.start) : newStart,
            end: prev.end ? (newEnd > prev.end ? newEnd : prev.end) : newEnd
          };
        });
      } else {
        console.warn('No new data points were fetched');
      }
      
    } catch (error) {
      if (error.name === 'AbortError') {
        console.log('Fetch operation aborted');
        return;
      }
      console.error('Error in fetchMissingData:', error);
      
      if (error.message.includes('fetch')) {
        console.error('Network error - check your API endpoint');
      }
    } finally {
      const elapsedTime = Date.now() - startTime;
      const minLoadingTime = 500;
      
      clearTimeout(loadingDelay);
      
      const finishLoading = () => {
        setIsLoadingMoreData(false);
        setShowLoadingIndicator(false);
        setLoadingStartTime(null);
      };
      
      if (elapsedTime < minLoadingTime) {
        minimumLoadingTimeRef.current = setTimeout(finishLoading, minLoadingTime - elapsedTime);
      } else {
        finishLoading();
      }
    }
  }, [companyId, selectedInterval, activeIndicators, isLoadingMoreData, getIntervalInMs]);

  const syncChartRanges = useCallback((newXRange: [string, string], sourceChart: string) => {
    setSyncedXRange(newXRange);
    setXRange(newXRange);
    
    const charts = [
      { ref: priceChartRef, name: 'price' },
      { ref: volumeChartRef, name: 'volume' },
      { ref: rsiChartRef, name: 'rsi' },
      { ref: macdChartRef, name: 'macd' }
    ];
    
    charts.forEach(chart => {
      if (sourceChart !== chart.name && chart.ref.current) {
        try {
          chart.ref.current.relayout({ 'xaxis.range': newXRange });
        } catch (error) {
          console.warn(`Failed to sync ${chart.name} chart range:`, error);
        }
      }
    });
  }, []);

  const handlePriceChartRelayout = useCallback((eventData: any) => {
    if (isLoadingMoreData) {
      console.log('Skipping price chart relayout handling - already loading');
      return;
    }

    setIsUserInteracting(true);
    
    if (interactionTimeoutRef.current) {
      clearTimeout(interactionTimeoutRef.current);
    }
    
    let newXRange = null;
    let newYRange = null;
    
    if (eventData['xaxis.range[0]'] && eventData['xaxis.range[1]']) {
      newXRange = [eventData['xaxis.range[0]'], eventData['xaxis.range[1]']];
    } else if (eventData['xaxis.range']) {
      newXRange = eventData['xaxis.range'];
    }
    
    if (eventData['yaxis.range[0]'] && eventData['yaxis.range[1]']) {
      newYRange = [eventData['yaxis.range[0]'], eventData['yaxis.range[1]']];
    }
    
    console.log('Price chart relayout event:', { newXRange, newYRange });
    
    if (newXRange) {
      syncChartRanges(newXRange, 'price');
    }
    if (newYRange) {
      setYRange(newYRange);
    }
    
    if (eventData['xaxis.autorange'] === true) {
      setSyncedXRange(null);
      setXRange(null);
    }
    if (eventData['yaxis.autorange'] === true) {
      setYRange(null);
    }
    
    if (relayoutTimeoutRef.current) {
      clearTimeout(relayoutTimeoutRef.current);
    }
    
    relayoutTimeoutRef.current = setTimeout(() => {
      if (!isLoadingMoreData && newXRange) {
        try {
          console.log('Checking for gaps in price chart range:', newXRange);
          const gaps = detectDataGaps(newXRange);
          if (gaps && gaps.length > 0) {
            console.log('Found gaps, fetching data:', gaps);
            fetchMissingData(gaps);
          } else {
            console.log('No gaps detected');
          }
        } catch (error) {
          console.error('Error in price chart gap detection:', error);
        }
      }
    }, CHART_PERFORMANCE_CONFIG.RELAYOUT_DEBOUNCE);
    
    interactionTimeoutRef.current = setTimeout(() => {
      setIsUserInteracting(false);
    }, CHART_PERFORMANCE_CONFIG.RELAYOUT_DEBOUNCE + 200);
    
  }, [detectDataGaps, fetchMissingData, isLoadingMoreData, syncChartRanges]);

  const handleVolumeChartRelayout = useCallback((eventData: any) => {
    if (isLoadingMoreData) {
      console.log('Skipping volume chart relayout handling - already loading');
      return;
    }

    setIsUserInteracting(true);
    
    if (interactionTimeoutRef.current) {
      clearTimeout(interactionTimeoutRef.current);
    }
    
    let newXRange = null;
    
    if (eventData['xaxis.range[0]'] && eventData['xaxis.range[1]']) {
      newXRange = [eventData['xaxis.range[0]'], eventData['xaxis.range[1]']];
    } else if (eventData['xaxis.range']) {
      newXRange = eventData['xaxis.range'];
    }
    
    console.log('Volume chart relayout event:', { newXRange });
    
    if (newXRange) {
      syncChartRanges(newXRange, 'volume');
    }
    
    if (eventData['xaxis.autorange'] === true) {
      setSyncedXRange(null);
      setXRange(null);
    }
    
    interactionTimeoutRef.current = setTimeout(() => {
      setIsUserInteracting(false);
    }, CHART_PERFORMANCE_CONFIG.RELAYOUT_DEBOUNCE + 200);
    
  }, [isLoadingMoreData, syncChartRanges]);

  const handleRsiChartRelayout = useCallback((eventData: any) => {
    if (isLoadingMoreData) return;

    setIsUserInteracting(true);
    
    if (interactionTimeoutRef.current) {
      clearTimeout(interactionTimeoutRef.current);
    }
    
    let newXRange = null;
    
    if (eventData['xaxis.range[0]'] && eventData['xaxis.range[1]']) {
      newXRange = [eventData['xaxis.range[0]'], eventData['xaxis.range[1]']];
    } else if (eventData['xaxis.range']) {
      newXRange = eventData['xaxis.range'];
    }
    
    if (newXRange) {
      syncChartRanges(newXRange, 'rsi');
    }
    
    if (eventData['xaxis.autorange'] === true) {
      setSyncedXRange(null);
      setXRange(null);
    }
    
    interactionTimeoutRef.current = setTimeout(() => {
      setIsUserInteracting(false);
    }, CHART_PERFORMANCE_CONFIG.RELAYOUT_DEBOUNCE + 200);
    
  }, [isLoadingMoreData, syncChartRanges]);

  const handleMacdChartRelayout = useCallback((eventData: any) => {
    if (isLoadingMoreData) return;

    setIsUserInteracting(true);
    
    if (interactionTimeoutRef.current) {
      clearTimeout(interactionTimeoutRef.current);
    }
    
    let newXRange = null;
    
    if (eventData['xaxis.range[0]'] && eventData['xaxis.range[1]']) {
      newXRange = [eventData['xaxis.range[0]'], eventData['xaxis.range[1]']];
    } else if (eventData['xaxis.range']) {
      newXRange = eventData['xaxis.range'];
    }
    
    if (newXRange) {
      syncChartRanges(newXRange, 'macd');
    }
    
    if (eventData['xaxis.autorange'] === true) {
      setSyncedXRange(null);
      setXRange(null);
    }
    
    interactionTimeoutRef.current = setTimeout(() => {
      setIsUserInteracting(false);
    }, CHART_PERFORMANCE_CONFIG.RELAYOUT_DEBOUNCE + 200);
    
  }, [isLoadingMoreData, syncChartRanges]);

  useEffect(() => {
    if (data && data.length > 0) {
      const marketHoursData = filterMarketHoursData(data);
      setAllData(marketHoursData);
      
      if (marketHoursData.length > 0) {
        const start = new Date(marketHoursData[0].interval_start);
        const end = new Date(marketHoursData[marketHoursData.length - 1].interval_start);
        setDataRange({ start, end });
      }
      
      setXRange(null);
      setYRange(null);
      setSyncedXRange(null);
    }
  }, [data]);

  useEffect(() => {
    if (companyId) {
      setXRange(null);
      setYRange(null);
      setSyncedXRange(null);
      setAllData([]);
      setDataRange({ start: null, end: null });
      lastFetchRangeRef.current = null;
      setIsUserInteracting(false);
    }
  }, [companyId]);

  useEffect(() => {
    const totalAvailableHeight = isFullscreen ? window.innerHeight - 20 : height - 20;
    const gap = CHART_PERFORMANCE_CONFIG.CHART_GAP;
    
    const hasRSI = activeIndicators.includes('rsi');
    const hasMACD = activeIndicators.includes('macd');
    
    let indicatorHeight = 0;
    if (hasRSI) indicatorHeight += CHART_PERFORMANCE_CONFIG.INDICATOR_CHART_HEIGHT + gap;
    if (hasMACD) indicatorHeight += CHART_PERFORMANCE_CONFIG.INDICATOR_CHART_HEIGHT + gap;
    
    const availableForMainCharts = totalAvailableHeight - indicatorHeight;
    
    if (showVolume) {
      const priceHeight = Math.floor(availableForMainCharts * CHART_PERFORMANCE_CONFIG.PRICE_CHART_HEIGHT_RATIO);
      const volumeHeight = Math.floor(availableForMainCharts * CHART_PERFORMANCE_CONFIG.VOLUME_CHART_HEIGHT_RATIO);
      
      setPriceChartHeight(priceHeight);
      setVolumeChartHeight(volumeHeight);
    } else {
      setPriceChartHeight(availableForMainCharts);
      setVolumeChartHeight(0);
    }
    
    setRsiChartHeight(hasRSI ? CHART_PERFORMANCE_CONFIG.INDICATOR_CHART_HEIGHT : 0);
    setMacdChartHeight(hasMACD ? CHART_PERFORMANCE_CONFIG.INDICATOR_CHART_HEIGHT : 0);
    
  }, [height, isFullscreen, showVolume, activeIndicators]);

  useEffect(() => {
    return () => {
      [loadingTimeoutRef, minimumLoadingTimeRef, relayoutTimeoutRef, interactionTimeoutRef].forEach(ref => {
        if (ref.current) clearTimeout(ref.current);
      });
      if (loadingControllerRef.current) {
        loadingControllerRef.current.abort();
      }
    };
  }, []);

  const detectDeviceType = useCallback((width: number) => {
    if (width < CHART_PERFORMANCE_CONFIG.RESPONSIVE_BREAKPOINTS.MOBILE) {
      return 'mobile';
    } else if (width < CHART_PERFORMANCE_CONFIG.RESPONSIVE_BREAKPOINTS.TABLET) {
      return 'tablet';
    } else {
      return 'desktop';
    }
  }, []);

  useEffect(() => {
    const updateViewportSize = () => {
      const newSize = {
        width: window.innerWidth,
        height: window.innerHeight
      };
      setViewportSize(newSize);
      setDeviceType(detectDeviceType(newSize.width));
    };

    updateViewportSize();
    
    const handleResize = () => {
      if (resizeTimeoutRef.current) {
        clearTimeout(resizeTimeoutRef.current);
      }
      resizeTimeoutRef.current = setTimeout(updateViewportSize, CHART_PERFORMANCE_CONFIG.RESIZE_DEBOUNCE_MS);
    };

    window.addEventListener('resize', handleResize);
    return () => {
      window.removeEventListener('resize', handleResize);
      if (resizeTimeoutRef.current) {
        clearTimeout(resizeTimeoutRef.current);
      }
    };
  }, [detectDeviceType]);

  useEffect(() => {
    if (!containerRef.current || !autoResize) return;

    const updateContainerDimensions = (entries: ResizeObserverEntry[]) => {
      if (!entries.length) return;
      
      const entry = entries[0];
      const { width: containerWidth, height: containerHeight } = entry.contentRect;
      
      if (containerWidth === 0 || containerHeight === 0) return;

      const sidebarWidth = sidebarVisible ? CHART_PERFORMANCE_CONFIG.SIDEBAR_WIDTH : 0;
      const availableWidth = containerWidth - sidebarWidth;
      const availableHeight = isFullscreen ? window.innerHeight : containerHeight;

      const newContainerDims = {
        width: containerWidth,
        height: containerHeight
      };

      const newChartDims = {
        width: Math.max(availableWidth, CHART_PERFORMANCE_CONFIG.MIN_CHART_WIDTH),
        height: Math.max(availableHeight, CHART_PERFORMANCE_CONFIG.MIN_CHART_HEIGHT)
      };

      if (responsiveMode === 'manual') {
        const targetRatio = CHART_PERFORMANCE_CONFIG.ASPECT_RATIOS[aspectRatio];
        const currentRatio = newChartDims.width / newChartDims.height;
        
        if (currentRatio > targetRatio) {
          newChartDims.width = newChartDims.height * targetRatio;
        } else {
          newChartDims.height = newChartDims.width / targetRatio;
        }
      }

      setContainerDimensions(newContainerDims);
      setChartDimensions(newChartDims);

      if (resizeTimeoutRef.current) {
        clearTimeout(resizeTimeoutRef.current);
      }
      resizeTimeoutRef.current = setTimeout(() => {
        try {
          if (priceChartRef.current?.resizeHandler) {
            priceChartRef.current.resizeHandler();
          }
          if (volumeChartRef.current?.resizeHandler) {
            volumeChartRef.current.resizeHandler();
          }
          if (rsiChartRef.current?.resizeHandler) {
            rsiChartRef.current.resizeHandler();
          }
          if (macdChartRef.current?.resizeHandler) {
            macdChartRef.current.resizeHandler();
          }
        } catch (error) {
          console.warn('Plotly resize failed:', error);
        }
      }, CHART_PERFORMANCE_CONFIG.RESIZE_DEBOUNCE_MS);
    };

    if (window.ResizeObserver) {
      resizeObserverRef.current = new ResizeObserver(updateContainerDimensions);
      resizeObserverRef.current.observe(containerRef.current);
    }

    return () => {
      if (resizeObserverRef.current && containerRef.current) {
        resizeObserverRef.current.unobserve(containerRef.current);
        resizeObserverRef.current.disconnect();
      }
      if (resizeTimeoutRef.current) {
        clearTimeout(resizeTimeoutRef.current);
      }
    };
  }, [autoResize, isFullscreen, sidebarVisible, responsiveMode, aspectRatio]);

  const filteredData = useMemo(() => {
    return filterMarketHoursData(allData);
  }, [allData]);

  const optimizedData = useMemo(() => {
    if (!filteredData.length) return filteredData;
    
    if (filteredData.length <= CHART_PERFORMANCE_CONFIG.MAX_VISIBLE_POINTS) {
      return filteredData;
    }
    
    const ratio = Math.ceil(filteredData.length / CHART_PERFORMANCE_CONFIG.MAX_VISIBLE_POINTS);
    const result: StockDataPoint[] = [];
    
    for (let i = 0; i < filteredData.length; i += ratio) {
      const chunk = filteredData.slice(i, i + ratio);
      if (chunk.length === 1) {
        result.push(chunk[0]);
      } else {
        const open = chunk[0].open;
        const close = chunk[chunk.length - 1].close;
        const high = Math.max(...chunk.map(d => d.high));
        const low = Math.min(...chunk.map(d => d.low));
        const volume = chunk.reduce((sum, d) => sum + d.volume, 0);
        
       result.push({
  interval_start: chunk[chunk.length - 1].interval_start,  
  open, high, low, close, volume
});

      }
    }
    
    return result;
  }, [filteredData]);

  const calculateIndicator = useCallback((type: string, prices: number[], options = {}) => {
    switch (type) {
      case 'ma': {
        const period = (options as any).period || 20;
        const result = new Array(prices.length);
        
        for (let i = 0; i < prices.length; i++) {
          if (i < period - 1) {
            result[i] = null;
          } else {
            let sum = 0;
            for (let j = i - period + 1; j <= i; j++) {
              sum += prices[j];
            }
            result[i] = sum / period;
          }
        }
        return result;
      }
      
      case 'ema': {
        const period = (options as any).period || 9;
        const k = 2 / (period + 1);
        const result = new Array(prices.length);
        result[0] = prices[0];
        
        for (let i = 1; i < prices.length; i++) {
          result[i] = prices[i] * k + result[i-1] * (1-k);
        }
        
        for (let i = 0; i < period - 1; i++) {
          result[i] = null;
        }
        
        return result;
      }
      
      case 'bollinger': {
        const period = (options as any).period || 20;
        const stdDevMultiplier = (options as any).stdDev || 2;
        const ma = calculateIndicator('ma', prices, { period }) as number[];
        
        const upperBand = new Array(prices.length);
        const lowerBand = new Array(prices.length);
        
        for (let i = 0; i < prices.length; i++) {
          if (ma[i] === null) {
            upperBand[i] = null;
            lowerBand[i] = null;
          } else {
            let sumSquares = 0;
            for (let j = i - period + 1; j <= i; j++) {
              const diff = prices[j] - ma[i];
              sumSquares += diff * diff;
            }
            const stdDev = Math.sqrt(sumSquares / period);
            upperBand[i] = ma[i] + (stdDev * stdDevMultiplier);
            lowerBand[i] = ma[i] - (stdDev * stdDevMultiplier);
          }
        }
        
        return { middle: ma, upper: upperBand, lower: lowerBand };
      }
      
      case 'rsi': {
        const period = (options as any).period || 14;
        const gains = new Array(prices.length - 1);
        const losses = new Array(prices.length - 1);
        
        for (let i = 1; i < prices.length; i++) {
          const change = prices[i] - prices[i-1];
          gains[i-1] = change > 0 ? change : 0;
          losses[i-1] = change < 0 ? -change : 0;
        }
        
        const result = new Array(prices.length).fill(null);
        
        if (gains.length >= period) {
          let avgGain = gains.slice(0, period).reduce((sum, gain) => sum + gain, 0) / period;
          let avgLoss = losses.slice(0, period).reduce((sum, loss) => sum + loss, 0) / period;
          
          for (let i = period; i < gains.length; i++) {
            avgGain = ((avgGain * (period - 1)) + gains[i]) / period;
            avgLoss = ((avgLoss * (period - 1)) + losses[i]) / period;
            
            const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
            result[i + 1] = 100 - (100 / (1 + rs));
          }
        }
        
        return result;
      }
      
      case 'macd': {
        const fastPeriod = (options as any).fastPeriod || 12;
        const slowPeriod = (options as any).slowPeriod || 26;
        const signalPeriod = (options as any).signalPeriod || 9;
        
        const fastEMA = calculateIndicator('ema', prices, { period: fastPeriod }) as number[];
        const slowEMA = calculateIndicator('ema', prices, { period: slowPeriod }) as number[];
        
        const macdLine = fastEMA.map((fast, i) => {
          if (fast === null || slowEMA[i] === null) return null;
          return fast - slowEMA[i];
        });
        
        const validMacd = macdLine.filter(val => val !== null) as number[];
        const signalLine = calculateIndicator('ema', validMacd, { period: signalPeriod }) as number[];
        
        const paddedSignalLine = Array(macdLine.length - validMacd.length + signalPeriod - 1).fill(null).concat(signalLine);
        
        const histogram = macdLine.map((macd, i) => {
          if (macd === null || paddedSignalLine[i] === null) return null;
          return macd - paddedSignalLine[i];
        });
        
        return { macdLine, signalLine: paddedSignalLine, histogram };
      }
      
      default:
        return [];
    }
  }, []);

  const convertToHeikenAshi = useCallback((data: StockDataPoint[]) => {
    if (!data || data.length === 0) return [];
    
    const haData: any[] = [];
    let prevHA: any = null;
    
    for (let i = 0; i < data.length; i++) {
      const current = data[i];
      const currentHigh = current.high;
      const currentLow = current.low;
      const currentOpen = current.open;
      const currentClose = current.close;

      let haOpen: number;
      let haClose: number;
      let haHigh: number;
      let haLow: number;

      haClose = (currentOpen + currentHigh + currentLow + currentClose) / 4;

      if (prevHA === null) {
        haOpen = (currentOpen + currentClose) / 2;
      } else {
        haOpen = (prevHA.ha_open + prevHA.ha_close) / 2;
      }

      haHigh = Math.max(currentHigh, haOpen, haClose);
      haLow = Math.min(currentLow, haOpen, haClose);

      const haCandle = {
        interval_start: current.interval_start,
        ha_open: haOpen,
        ha_high: haHigh,
        ha_low: haLow,
        ha_close: haClose,
        volume: current.volume,
        original_open: currentOpen,
        original_high: currentHigh,
        original_low: currentLow,
        original_close: currentClose,
        color: haClose >= haOpen ? 'green' : 'red',
        bodySize: Math.abs(haClose - haOpen),
        upperWick: haHigh - Math.max(haOpen, haClose),
        lowerWick: Math.min(haOpen, haClose) - haLow
      };

      haData.push(haCandle);
      prevHA = haCandle;
    }
    
    return haData;
  }, []);

  const colors = useMemo(() => {
    const baseColor = '#27272a';
    const lighterShades = {
      100: '#3f3f46',
      200: '#52525b',
      300: '#71717a',
      400: '#a1a1aa',
      500: '#d4d4d8'
    };
    
    if (chartTheme === 'dark') {
      return {
        bg: baseColor,
        paper: baseColor,
        text: lighterShades[500],
        grid: lighterShades[100],
        line: '#60a5fa',
        upColor: '#22c55e',
        downColor: '#ef4444',
        volume: {
          up: 'rgba(34, 197, 94, 0.8)',
          down: 'rgba(239, 68, 68, 0.8)'
        },
        indicators: {
          ma: ['#f59e0b', '#f97316', '#dc2626', '#7c3aed'],
          ema: ['#10b981', '#059669', '#047857', '#065f46'],
          bollinger: '#06b6d4',
          rsi: '#8b5cf6',
          macd: '#ec4899',
          obv: '#f59e0b',
          atr: '#14b8a6',
          stoch: '#f472b6',
          vwap: '#84cc16'
        },
        button: {
          bg: lighterShades[100],
          bgActive: '#60a5fa',
          bgHover: lighterShades[200],
          text: lighterShades[500]
        }
      };
    } else {
      return {
        bg: '#ffffff',
        paper: '#ffffff',
        text: baseColor,
        grid: lighterShades[400],
        line: '#3b82f6',
        upColor: '#059669',
        downColor: '#dc2626',
        volume: {
          up: 'rgba(5, 150, 105, 0.8)',
          down: 'rgba(220, 38, 38, 0.8)'
        },
        indicators: {
          ma: ['#f59e0b', '#f97316', '#dc2626', '#7c3aed'],
          ema: ['#10b981', '#059669', '#047857', '#065f46'],
          bollinger: '#0891b2',
          rsi: '#7c3aed',
          macd: '#be185d',
          obv: '#d97706',
          atr: '#0d9488',
          stoch: '#db2777',
          vwap: '#65a30d'
        },
        button: {
          bg: '#f8fafc',
          bgActive: '#3b82f6',
          bgHover: '#f1f5f9',
          text: baseColor
        }
      };
    }
  }, [chartTheme]);

  const priceChartData = useMemo(() => {
    if (!optimizedData.length) return [];

    const timeLabels = optimizedData.map(item => new Date(item.interval_start));
    const plotElements = [];
    
    const chartData = selectedChartType === 'heiken-ashi' ? convertToHeikenAshi(optimizedData) : optimizedData;

    let priceChart;
    
    switch (selectedChartType) {
      case 'candlestick':
        priceChart = {
          x: timeLabels,
          open: optimizedData.map(item => item.open),
          high: optimizedData.map(item => item.high),
          low: optimizedData.map(item => item.low),
          close: optimizedData.map(item => item.close),
          type: 'candlestick',
          name: 'Price',
          decreasing: { 
            line: { color: colors.downColor, width: 1 },
            fillcolor: colors.downColor
          },
          increasing: { 
            line: { color: colors.upColor, width: 1 },
            fillcolor: colors.upColor
          },
          whiskerwidth: 0.8,
          line: { width: 1 }
        };
        break;
        
      case 'ohlc':
        priceChart = {
          x: timeLabels,
          open: optimizedData.map(item => item.open),
          high: optimizedData.map(item => item.high),
          low: optimizedData.map(item => item.low),
          close: optimizedData.map(item => item.close),
          type: 'ohlc',
          name: 'Price',
          decreasing: { line: { color: colors.downColor, width: 2 } },
          increasing: { line: { color: colors.upColor, width: 2 } }
        };
        break;
        
      case 'heiken-ashi':
        priceChart = {
          x: timeLabels,
          open: chartData.map(item => item.ha_open),
          high: chartData.map(item => item.ha_high),
          low: chartData.map(item => item.ha_low),
          close: chartData.map(item => item.ha_close),
          type: 'candlestick',
          name: 'Heiken Ashi',
          decreasing: { 
            line: { color: colors.downColor, width: 1 },
            fillcolor: colors.downColor
          },
          increasing: { 
            line: { color: colors.upColor, width: 1 },
            fillcolor: colors.upColor
          },
          whiskerwidth: 0.8
        };
        break;
        
      case 'line':
        priceChart = {
          x: timeLabels,
          y: optimizedData.map(item => item.close),
          type: 'scatter',
          mode: 'lines',
          name: 'Price',
          line: { 
            color: colors.line, 
            width: 2.5,
            shape: 'linear'
          },
          connectgaps: true
        };
        break;
        
      case 'area':
        priceChart = {
          x: timeLabels,
          y: optimizedData.map(item => item.close),
          type: 'scatter',
          mode: 'lines',
          name: 'Price',
          fill: 'tozeroy',
          fillcolor: 'rgba(96, 165, 250, 0.2)',
          line: { 
            color: colors.line, 
            width: 2.5,
            shape: 'linear'
          },
          connectgaps: true
        };
        break;
    }
    
    plotElements.push(priceChart);

    const prices = optimizedData.map(item => item.close);

    if (activeIndicators.includes('ma')) {
      selectedMAperiods.forEach((period, index) => {
        const ma = calculateIndicator('ma', prices, { period });
        plotElements.push({
          x: timeLabels,
          y: ma,
          type: 'scatter',
          mode: 'lines',
          name: `MA(${period})`,
          line: { 
            color: colors.indicators.ma[index % colors.indicators.ma.length],
            width: 2,
            shape: 'linear'
          },
          connectgaps: false
        });
      });
    }

    if (activeIndicators.includes('ema')) {
      selectedEMAperiods.forEach((period, index) => {
        const ema = calculateIndicator('ema', prices, { period });
        plotElements.push({
          x: timeLabels,
          y: ema,
          type: 'scatter',
          mode: 'lines',
          name: `EMA(${period})`,
          line: { 
            color: colors.indicators.ema[index % colors.indicators.ema.length],
            width: 2,
            dash: 'dash',
            shape: 'linear'
          },
          connectgaps: false
        });
      });
    }

    if (activeIndicators.includes('bollinger')) {
      const bands = calculateIndicator('bollinger', prices, { period: 20, stdDev: 2 }) as any;
      
      plotElements.push({
        x: timeLabels,
        y: bands.upper,
        type: 'scatter',
        mode: 'lines',
        name: 'BB Upper',
        line: { 
          color: colors.indicators.bollinger, 
          width: 1.5, 
          dash: 'dot',
          shape: 'linear'
        },
        showlegend: false,
        connectgaps: false
      });
      
      plotElements.push({
        x: timeLabels,
        y: bands.lower,
        type: 'scatter',
        mode: 'lines',
        name: 'BB Lower',
        line: { 
          color: colors.indicators.bollinger, 
          width: 1.5, 
          dash: 'dot',
          shape: 'linear'
        },
        fill: 'tonexty',
        fillcolor: 'rgba(6, 182, 212, 0.1)',
        showlegend: false,
        connectgaps: false
      });
      
      plotElements.push({
        x: timeLabels,
        y: bands.middle,
        type: 'scatter',
        mode: 'lines',
        name: 'BB(20,2)',
        line: { 
          color: colors.indicators.bollinger, 
          width: 1.5,
          shape: 'linear'
        },
        connectgaps: false
      });
    }

    return plotElements;
  }, [
    optimizedData, 
    selectedChartType, 
    activeIndicators, 
    selectedMAperiods, 
    selectedEMAperiods, 
    colors,
    calculateIndicator,
    convertToHeikenAshi
  ]);

  const volumeChartData = useMemo(() => {
    if (!optimizedData.length) return [];

    const timeLabels = optimizedData.map(item => new Date(item.interval_start));
    const volumes = optimizedData.map(item => item.volume);
    
    const volumeColors = optimizedData.map((item, i) => {
      if (i === 0) return colors.volume.up;
      
      const currentClose = item.close;
      const previousClose = optimizedData[i - 1].close;
      
      return currentClose >= previousClose ? colors.volume.up : colors.volume.down;
    });

    const maxVolume = Math.max(...volumes);
    const minVolume = Math.min(...volumes.filter(v => v > 0));
    const avgVolume = volumes.reduce((sum, vol) => sum + vol, 0) / volumes.length;
    
    const normalizedVolumes = volumes.map(vol => {
      if (vol === 0) return 0;
      
      const minVisibleRatio = 0.02;
      const minVisibleVolume = maxVolume * minVisibleRatio;
      
      return Math.max(vol, minVisibleVolume);
    });

    const volumeChart = {
      x: timeLabels,
      y: normalizedVolumes,
      type: 'bar',
      name: 'Volume',
      marker: {
        color: volumeColors,
        line: { 
          width: deviceType === 'mobile' ? 0 : 0.5,
          color: 'rgba(255,255,255,0.1)' 
        },
        opacity: 0.9
      },
      text: volumes.map(vol => vol.toLocaleString()),
      hovertemplate: '<b>Volume:</b> %{text}<br><b>Time:</b> %{x}<extra></extra>',
      hoverlabel: {
        bgcolor: colors.bg,
        bordercolor: colors.line,
        font: { color: colors.text }
      }
    };

    return [volumeChart];
  }, [optimizedData, colors, deviceType]);

  const rsiChartData = useMemo(() => {
    if (!optimizedData.length || !activeIndicators.includes('rsi')) return [];

    const timeLabels = optimizedData.map(item => new Date(item.interval_start));
    const prices = optimizedData.map(item => item.close);
    const rsi = calculateIndicator('rsi', prices) as number[];

    return [{
      x: timeLabels,
      y: rsi,
      type: 'scatter',
      mode: 'lines',
      name: 'RSI(14)',
      line: { 
        color: colors.indicators.rsi, 
        width: 2,
        shape: 'linear'
      },
      connectgaps: false
    }];
  }, [optimizedData, activeIndicators, colors, calculateIndicator]);

  const macdChartData = useMemo(() => {
    if (!optimizedData.length || !activeIndicators.includes('macd')) return [];

    const timeLabels = optimizedData.map(item => new Date(item.interval_start));
    const prices = optimizedData.map(item => item.close);
    const macd = calculateIndicator('macd', prices) as any;
    
    return [
      {
        x: timeLabels,
        y: macd.macdLine,
        type: 'scatter',
        mode: 'lines',
        name: 'MACD',
        line: { 
          color: colors.indicators.macd, 
          width: 2,
          shape: 'linear'
        },
        connectgaps: false
      },
      {
        x: timeLabels,
        y: macd.signalLine,
        type: 'scatter',
        mode: 'lines',
        name: 'Signal',
        line: { 
          color: '#fbbf24', 
          width: 2,
          shape: 'linear'
        },
        connectgaps: false
      },
      {
        x: timeLabels,
        y: macd.histogram,
        type: 'bar',
        name: 'Histogram',
        marker: {
          color: macd.histogram.map((val: number | null) => 
            val === null ? 'rgba(0,0,0,0)' : 
            val >= 0 ? colors.upColor : colors.downColor
          ),
          opacity: 0.7
        }
      }
    ];
  }, [optimizedData, activeIndicators, colors, calculateIndicator]);

  const chartTitle = useMemo(() => {
    let title = companyId ? 
      `${companyId} - ${selectedInterval.toUpperCase()} Chart [${optimizedData.length} points]` : 
      'Select a Company';
    
    if (isLoadingMoreData) {
      title += '  Expanding...';
    }
    
    return title;
  }, [companyId, selectedInterval, optimizedData.length, isLoadingMoreData]);

  const priceChartLayout = useMemo(() => {
    const getResponsiveMargin = () => {
      switch (deviceType) {
        case 'mobile':
          return { r: 40, l: 40, b: 10, t: 60, pad: 2 };
        case 'tablet':
          return { r: 50, l: 50, b: 15, t: 70, pad: 3 };
        default:
          return { r: 60, l: 60, b: 40, t: 80, pad: 4 };
      }
    };

    const getResponsiveFontSizes = () => {
      switch (deviceType) {
        case 'mobile':
          return { title: 14, axis: 9, tick: 8, legend: 9 };
        case 'tablet':
          return { title: 15, axis: 10, tick: 9, legend: 10 };
        default:
          return { title: 16, axis: 12, tick: 10, legend: 11 };
      }
    };

    const responsiveMargin = getResponsiveMargin();
    const responsiveFonts = getResponsiveFontSizes();

    const baseLayout: any = {
      autosize: true,
      responsive: true,
      
      uirevision: CHART_PERFORMANCE_CONFIG.STABLE_UI_REVISION + '_price',
      
      dragmode: drawingMode || 'pan',
      selectdirection: 'diagonal',
      scrollZoom: true,
      doubleClick: 'reset+autosize',
      
      showlegend: true,
      legend: {
        x: 0,
        y: 1.02,
        orientation: deviceType === 'mobile' ? 'v' : 'h',
        bgcolor: 'rgba(0,0,0,0)',
        font: { color: colors.text, size: responsiveFonts.legend },
        xanchor: deviceType === 'mobile' ? 'left' : 'auto',
        yanchor: deviceType === 'mobile' ? 'bottom' : 'auto'
      },
      margin: responsiveMargin,
      paper_bgcolor: colors.paper,
      plot_bgcolor: colors.bg,
      font: { color: colors.text, family: 'Inter, system-ui, sans-serif' },
      
      xaxis: {
        rangeslider: { visible: false },
        type: 'date',
        showgrid: showGridlines,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text, size: responsiveFonts.tick },
        title: { text: 'Time', font: { color: colors.text, size: responsiveFonts.axis } },
        
        autorange: syncedXRange ? false : true,
        range: syncedXRange || undefined,
        fixedrange: false,
        
        rangebreaks: STABLE_RANGEBREAKS,
        
        nticks: deviceType === 'mobile' ? 5 : deviceType === 'tablet' ? 8 : 12,
        
        showticklabels: true
      },

      yaxis: {
        title: { text: 'Price ()', font: { color: colors.text, size: responsiveFonts.axis } },
        tickformat: ',.2f',
        showgrid: showGridlines,
        gridcolor: colors.grid,
        zerolinecolor: colors.grid,
        linecolor: colors.grid,
        type: logScale ? 'log' : 'linear',
        tickfont: { color: colors.text, size: responsiveFonts.tick },
        side: 'left',
        
        autorange: yRange ? false : true,
        range: yRange || undefined,
        fixedrange: false,
        
        nticks: deviceType === 'mobile' ? 6 : deviceType === 'tablet' ? 8 : 10
      },
      
      hovermode: crosshair ? 'x unified' : 'closest',
      hoverdistance: deviceType === 'mobile' ? 50 : 100,
      spikedistance: deviceType === 'mobile' ? 500 : 1000,
      hoverlabel: {
        bgcolor: colors.bg,
        bordercolor: colors.line,
        font: { color: colors.text, size: responsiveFonts.legend }
      },
      shapes: annotations,
      
      title: {
        text: chartTitle,
        font: { color: colors.text, size: responsiveFonts.title, family: 'Inter, system-ui, sans-serif' },
        x: 0.5,
        xanchor: 'center'
      }
    };
    
    return baseLayout;
  }, [
    showGridlines, 
    logScale, 
    drawingMode, 
    colors, 
    crosshair, 
    annotations, 
    deviceType,
    syncedXRange, 
    yRange,
    chartTitle
  ]);

  const volumeChartLayout = useMemo(() => {
    const getResponsiveMargin = () => {
      switch (deviceType) {
        case 'mobile':
          return { r: 40, l: 40, b: 40, t: 20, pad: 2 };
        case 'tablet':
          return { r: 50, l: 50, b: 45, t: 25, pad: 3 };
        default:
          return { r: 60, l: 60, b: 50, t: 30, pad: 4 };
      }
    };

    const getResponsiveFontSizes = () => {
      switch (deviceType) {
        case 'mobile':
          return { title: 12, axis: 9, tick: 8, legend: 9 };
        case 'tablet':
          return { title: 13, axis: 10, tick: 9, legend: 10 };
        default:
          return { title: 14, axis: 11, tick: 10, legend: 11 };
      }
    };

    const responsiveMargin = getResponsiveMargin();
    const responsiveFonts = getResponsiveFontSizes();

    return {
      autosize: true,
      responsive: true,
      
      uirevision: CHART_PERFORMANCE_CONFIG.STABLE_UI_REVISION + '_volume',
      
      dragmode: 'pan',
      selectdirection: 'diagonal',
      scrollZoom: true,
      doubleClick: 'reset+autosize',
      
      showlegend: false,
      margin: responsiveMargin,
      paper_bgcolor: colors.paper,
      plot_bgcolor: colors.bg,
      font: { color: colors.text, family: 'Inter, system-ui, sans-serif' },
      
      xaxis: {
        type: 'date',
        showgrid: showGridlines,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text, size: responsiveFonts.tick },
        title: { text: '', font: { color: colors.text, size: responsiveFonts.axis } },
        
        autorange: syncedXRange ? false : true,
        range: syncedXRange || undefined,
        fixedrange: false,
        
        rangebreaks: STABLE_RANGEBREAKS,
        
        nticks: deviceType === 'mobile' ? 5 : deviceType === 'tablet' ? 8 : 12,
        
        showticklabels: false
      },

      yaxis: {
        title: { text: 'Volume', font: { color: colors.text, size: responsiveFonts.axis } },
        tickformat: '.2s',
        showgrid: showGridlines,
        gridcolor: colors.grid,
        zerolinecolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text, size: responsiveFonts.tick },
        side: 'left',
        autorange: true,
        fixedrange: false,
        nticks: deviceType === 'mobile' ? 4 : deviceType === 'tablet' ? 6 : 8
      },
      
      hovermode: 'x unified',
      hoverdistance: deviceType === 'mobile' ? 50 : 100,
      spikedistance: deviceType === 'mobile' ? 500 : 1000,
      hoverlabel: {
        bgcolor: colors.bg,
        bordercolor: colors.line,
        font: { color: colors.text, size: responsiveFonts.legend }
      },
      
      title: {
        text: 'Trading Volume',
        font: { color: colors.text, size: responsiveFonts.title, family: 'Inter, system-ui, sans-serif' },
        x: 0.5,
        xanchor: 'center'
      }
    };
  }, [
    showGridlines, 
    colors, 
    deviceType,
    syncedXRange
  ]);

  const rsiChartLayout = useMemo(() => {
    const getResponsiveFontSizes = () => {
      switch (deviceType) {
        case 'mobile':
          return { title: 11, axis: 8, tick: 7, legend: 8 };
        case 'tablet':
          return { title: 12, axis: 9, tick: 8, legend: 9 };
        default:
          return { title: 13, axis: 10, tick: 9, legend: 10 };
      }
    };

    const responsiveFonts = getResponsiveFontSizes();

    return {
      autosize: true,
      responsive: true,
      uirevision: CHART_PERFORMANCE_CONFIG.STABLE_UI_REVISION + '_rsi',
      dragmode: 'pan',
      selectdirection: 'diagonal',
      scrollZoom: true,
      doubleClick: 'reset+autosize',
      showlegend: false,
      margin: { r: 60, l: 60, b: 50, t: 30, pad: 4 },
      paper_bgcolor: colors.paper,
      plot_bgcolor: colors.bg,
      font: { color: colors.text, family: 'Inter, system-ui, sans-serif' },
      
      xaxis: {
        type: 'date',
        showgrid: showGridlines,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text, size: responsiveFonts.tick },
        title: { text: '', font: { color: colors.text, size: responsiveFonts.axis } },
        autorange: syncedXRange ? false : true,
        range: syncedXRange || undefined,
        fixedrange: false,
        rangebreaks: STABLE_RANGEBREAKS,
        nticks: deviceType === 'mobile' ? 5 : deviceType === 'tablet' ? 8 : 12,
        showticklabels: false
      },

      yaxis: {
        title: { text: 'RSI', font: { color: colors.indicators.rsi, size: responsiveFonts.axis } },
        range: [0, 100],
        showgrid: true,
        gridcolor: colors.grid,
        tickfont: { color: colors.text, size: responsiveFonts.tick },
        tickvals: [20, 50, 80],
        side: 'left',
        nticks: 3
      },
      
      hovermode: 'x unified',
      hoverdistance: deviceType === 'mobile' ? 50 : 100,
      spikedistance: deviceType === 'mobile' ? 500 : 1000,
      hoverlabel: {
        bgcolor: colors.bg,
        bordercolor: colors.line,
        font: { color: colors.text, size: responsiveFonts.legend }
      },
      
      title: {
        text: 'RSI (14)',
        font: { color: colors.text, size: responsiveFonts.title, family: 'Inter, system-ui, sans-serif' },
        x: 0.5,
        xanchor: 'center'
      },

      shapes: [
        {
          type: 'line',
          x0: 0,
          x1: 1,
          xref: 'paper',
          y0: 70,
          y1: 70,
          line: { color: colors.downColor, width: 1, dash: 'dash' }
        },
        {
          type: 'line',
          x0: 0,
          x1: 1,
          xref: 'paper',
          y0: 30,
          y1: 30,
          line: { color: colors.upColor, width: 1, dash: 'dash' }
        }
      ]
    };
  }, [showGridlines, colors, deviceType, syncedXRange]);

  const macdChartLayout = useMemo(() => {
    const getResponsiveFontSizes = () => {
      switch (deviceType) {
        case 'mobile':
          return { title: 11, axis: 8, tick: 7, legend: 8 };
        case 'tablet':
          return { title: 12, axis: 9, tick: 8, legend: 9 };
        default:
          return { title: 13, axis: 10, tick: 9, legend: 10 };
      }
    };

    const responsiveFonts = getResponsiveFontSizes();

    return {
      autosize: true,
      responsive: true,
      uirevision: CHART_PERFORMANCE_CONFIG.STABLE_UI_REVISION + '_macd',
      dragmode: 'pan',
      selectdirection: 'diagonal',
      scrollZoom: true,
      doubleClick: 'reset+autosize',
      showlegend: true,
      legend: {
        x: 0,
        y: 1.02,
        orientation: 'h',
        bgcolor: 'rgba(0,0,0,0)',
        font: { color: colors.text, size: responsiveFonts.legend - 1 }
      },
      margin: { r: 60, l: 60, b: 50, t: 30, pad: 4 },
      paper_bgcolor: colors.paper,
      plot_bgcolor: colors.bg,
      font: { color: colors.text, family: 'Inter, system-ui, sans-serif' },
      
      xaxis: {
        type: 'date',
        showgrid: showGridlines,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text, size: responsiveFonts.tick },
        title: { text: 'Time', font: { color: colors.text, size: responsiveFonts.axis } },
        autorange: syncedXRange ? false : true,
        range: syncedXRange || undefined,
        fixedrange: false,
        rangebreaks: STABLE_RANGEBREAKS,
        nticks: deviceType === 'mobile' ? 5 : deviceType === 'tablet' ? 8 : 12,
        showticklabels: true
      },

      yaxis: {
        title: { text: 'MACD', font: { color: colors.indicators.macd, size: responsiveFonts.axis } },
        showgrid: true,
        gridcolor: colors.grid,
        tickfont: { color: colors.text, size: responsiveFonts.tick },
        side: 'left',
        nticks: deviceType === 'mobile' ? 3 : 5
      },
      
      hovermode: 'x unified',
      hoverdistance: deviceType === 'mobile' ? 50 : 100,
      spikedistance: deviceType === 'mobile' ? 500 : 1000,
      hoverlabel: {
        bgcolor: colors.bg,
        bordercolor: colors.line,
        font: { color: colors.text, size: responsiveFonts.legend }
      },
      
      title: {
        text: 'MACD (12,26,9)',
        font: { color: colors.text, size: responsiveFonts.title, family: 'Inter, system-ui, sans-serif' },
        x: 0.5,
        xanchor: 'center'
      }
    };
  }, [showGridlines, colors, deviceType, syncedXRange]);

  const config = useMemo(() => ({
    responsive: true,
    useResizeHandler: true,
    autosize: true,
    scrollZoom: true,
    displayModeBar: deviceType !== 'mobile',
    modeBarButtonsToAdd: deviceType !== 'mobile' ? [
      'drawline',
      'drawopenpath',
      'drawclosedpath',
      'drawcircle',
      'drawrect',
      'eraseshape'
    ] : [],
    modeBarButtonsToRemove: deviceType === 'mobile' ? 
      ['select2d', 'lasso2d', 'autoScale2d', 'resetScale2d'] : 
      ['select2d', 'lasso2d'],
    displaylogo: false,
    doubleClick: 'reset+autosize',
    showTips: false,
    plotGlPixelRatio: typeof window !== 'undefined' ? window.devicePixelRatio : 1,
    toImageButtonOptions: {
      format: 'png',
      filename: `${companyId || 'chart'}_${new Date().toISOString().split('T')[0]}`,
      height: priceChartHeight,
      width: chartDimensions.width,
      scale: deviceType === 'mobile' ? 1 : 2
    }
  }), [companyId, chartDimensions, deviceType, priceChartHeight]);

  const toggleFullscreen = useCallback(() => {
    setIsFullscreen(prev => !prev);
  }, []);

  const toggleAutoResize = useCallback(() => {
    setAutoResize(prev => !prev);
  }, []);

  const toggleResponsiveMode = useCallback(() => {
    setResponsiveMode(prev => prev === 'auto' ? 'manual' : 'auto');
  }, []);

  const handleAspectRatioChange = useCallback((ratio: keyof typeof CHART_PERFORMANCE_CONFIG.ASPECT_RATIOS) => {
    setAspectRatio(ratio);
  }, []);

  const toggleIndicator = useCallback((id: string) => {
    setActiveIndicators(prev => 
      prev.includes(id) 
        ? prev.filter(ind => ind !== id) 
        : [...prev, id]
    );
  }, []);

  const toggleMAPeriod = useCallback((period: number) => {
    setSelectedMAperiods(prev => 
      prev.includes(period) 
        ? prev.filter(p => p !== period) 
        : [...prev, period].sort((a, b) => a - b)
    );
  }, []);

  const toggleEMAPeriod = useCallback((period: number) => {
    setSelectedEMAperiods(prev => 
      prev.includes(period) 
        ? prev.filter(p => p !== period) 
        : [...prev, period].sort((a, b) => a - b)
    );
  }, []);

  const handleThemeToggle = useCallback(() => {
    const newTheme = chartTheme === 'dark' ? 'light' : 'dark';
    setChartTheme(newTheme);
    if (onThemeChange) {
      onThemeChange(newTheme);
    }
  }, [chartTheme, onThemeChange]);

  const handleIntervalChange = useCallback((newInterval: string) => {
    setSelectedInterval(newInterval);
    if (onIntervalChange) {
      onIntervalChange(newInterval);
    }
  }, [onIntervalChange]);

  const handleChartTypeChange = useCallback((type: string) => {
    setSelectedChartType(type);
  }, []);

  const handleDrawingModeChange = useCallback((mode: string | null) => {
    setDrawingMode(mode);
    if (priceChartRef.current) {
      const update = { dragmode: mode || 'pan' };
      priceChartRef.current.relayout(update);
    }
  }, []);

  const handlePlotUpdate = useCallback((figure: any) => {
    if (figure.layout?.shapes) {
      setAnnotations(figure.layout.shapes);
    }
  }, []);

  const resetChart = useCallback(() => {
    setXRange(null);
    setYRange(null);
    setSyncedXRange(null);
    
    const resetUpdate = { 
      'xaxis.autorange': true,
      'yaxis.autorange': true,
      'xaxis.range': undefined,
      'yaxis.range': undefined,
      dragmode: 'pan'
    };
    
    const charts = [priceChartRef, volumeChartRef, rsiChartRef, macdChartRef];
    
    charts.forEach(chartRef => {
      if (chartRef.current) {
        chartRef.current.relayout(resetUpdate);
      }
    });
    
    setAnnotations([]);
    setDrawingMode(null);
  }, []);

  const exportChartData = useCallback(() => {
    if (!optimizedData.length) return;

    const csvContent = [
      'Date,Open,High,Low,Close,Volume',
      ...optimizedData.map(item => 
        `${item.interval_start},${item.open},${item.high},${item.low},${item.close},${item.volume}`
      )
    ].join('\n');

    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${companyId || 'chart'}_${selectedInterval}_${new Date().toISOString().split('T')[0]}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, [optimizedData, companyId, selectedInterval]);

  useEffect(() => {
    if (!autoRefresh || !onIntervalChange) return;

    const interval = setInterval(() => {
      onIntervalChange(selectedInterval);
    }, refreshInterval);

    return () => clearInterval(interval);
  }, [autoRefresh, refreshInterval, selectedInterval, onIntervalChange]);

  const addPriceAlert = useCallback((price: number, type: 'above' | 'below') => {
    const newAlert = {
      id: Date.now(),
      price,
      type,
      triggered: false,
      createdAt: new Date()
    };
    setPriceAlerts(prev => [...prev, newAlert]);
  }, []);

  const removePriceAlert = useCallback((id: number) => {
    setPriceAlerts(prev => prev.filter(alert => alert.id !== id));
  }, []);

  useEffect(() => {
    if (!alertsEnabled || !optimizedData.length || !priceAlerts.length) return;

    const currentPrice = optimizedData[optimizedData.length - 1]?.close;
    if (!currentPrice) return;

    priceAlerts.forEach(alert => {
      if (alert.triggered) return;

      const shouldTrigger = 
        (alert.type === 'above' && currentPrice >= alert.price) ||
        (alert.type === 'below' && currentPrice <= alert.price);

      if (shouldTrigger) {
        setPriceAlerts(prev => 
          prev.map(a => a.id === alert.id ? { ...a, triggered: true } : a)
        );

        if ('Notification' in window && Notification.permission === 'granted') {
          new Notification(`Price Alert: ${companyId}`, {
            body: `Price ${alert.type} ${alert.price.toFixed(2)} (Current: ${currentPrice.toFixed(2)})`,
            icon: '/favicon.ico'
          });
        }
      }
    });
  }, [optimizedData, priceAlerts, alertsEnabled, companyId]);

  useEffect(() => {
    if (alertsEnabled && 'Notification' in window && Notification.permission === 'default') {
      Notification.requestPermission();
    }
  }, [alertsEnabled]);

  useEffect(() => {
    const handleKeyPress = (e: KeyboardEvent) => {
      if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
          case 't':
            e.preventDefault();
            handleThemeToggle();
            break;
          case 'g':
            e.preventDefault();
            setShowGridlines(prev => !prev);
            break;
          case 'v':
            e.preventDefault();
            setShowVolume(prev => !prev);
            break;
          case 'c':
            e.preventDefault();
            setCrosshair(prev => !prev);
            break;
          case 'l':
            e.preventDefault();
            setLogScale(prev => !prev);
            break;
          case 's':
            e.preventDefault();
            setSidebarVisible(prev => !prev);
            break;
          case 'r':
            e.preventDefault();
            resetChart();
            break;
          case 'f':
            e.preventDefault();
            toggleFullscreen();
            break;
          case 'a':
            e.preventDefault();
            toggleAutoResize();
            break;
        }
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [handleThemeToggle, resetChart, toggleFullscreen, toggleAutoResize]);

  useEffect(() => {
    setSelectedInterval(interval);
  }, [interval]);

  useEffect(() => {
    setChartTheme(theme);
  }, [theme]);

  const buttonStyle = {
    backgroundColor: colors.button.bg,
    color: colors.button.text,
    border: `1px solid ${colors.grid}`,
    borderRadius: '6px',
    padding: deviceType === 'mobile' ? '4px 8px' : '6px 12px',
    fontSize: deviceType === 'mobile' ? '11px' : '12px',
    fontWeight: '500',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    display: 'flex',
    alignItems: 'center',
    gap: '4px'
  };

  const activeButtonStyle = {
    ...buttonStyle,
    backgroundColor: colors.button.bgActive,
    color: '#ffffff',
    borderColor: colors.button.bgActive
  };

  const containerStyle = useMemo(() => ({
  width: '100%',
  height: isFullscreen ? '100vh' : `${height}px`,
  backgroundColor: colors.bg,
  fontFamily: 'Inter, system-ui, sans-serif',
  position: isFullscreen ? 'fixed' as const : 'relative' as const,
  top: isFullscreen ? 0 : 'auto',
  left: isFullscreen ? 0 : 'auto',
  zIndex: isFullscreen ? 9999 : 'auto',
  overflowX: isFullscreen ? 'auto' : 'hidden',
  overflowY: isFullscreen ? 'auto' : 'hidden',
  scrollBehavior: 'smooth'
}), [colors.bg, height, isFullscreen]);

  const chartContainerStyle = useMemo(() => {
    const sidebarWidth = sidebarVisible && deviceType !== 'mobile' ? CHART_PERFORMANCE_CONFIG.SIDEBAR_WIDTH : 0;
    return {
      marginLeft: deviceType === 'mobile' ? '0px' : `${sidebarWidth}px`,
      transition: 'margin-left 0.3s ease',
      height: '100%',
      width: deviceType === 'mobile' ? '100%' : sidebarVisible ? `calc(100% - ${sidebarWidth}px)` : '100%',
      minWidth: `${CHART_PERFORMANCE_CONFIG.MIN_CHART_WIDTH}px`,
      position: 'relative' as const,
      display: 'flex',
      flexDirection: 'column' as const
    };
  }, [sidebarVisible, deviceType]);

  const testDynamicLoading = useCallback(() => {
    console.log('=== Testing Dynamic Loading ===');
    console.log('Current allData length:', allData.length);
    console.log('Company ID:', companyId);
    console.log('Is loading:', isLoadingMoreData);
    
    if (!companyId) {
      console.error('No company ID set');
      return;
    }
    
    if (allData.length === 0) {
      console.error('No initial data available');
      return;
    }
    
    const now = new Date();
    const testRange: [string, string] = [
      new Date(now.getTime() - 6 * 60 * 60 * 1000).toISOString(),
      new Date(now.getTime() + 1 * 60 * 60 * 1000).toISOString()
    ];
    
    console.log('Test range:', testRange);
    
    const gaps = detectDataGaps(testRange);
    console.log('Detected gaps:', gaps);
    
    if (gaps && gaps.length > 0) {
      console.log('Triggering test fetch...');
      fetchMissingData(gaps);
    } else {
      console.log('No gaps detected in test range');
      
      const forcedGap = [{
        type: 'test',
        start: new Date(now.getTime() - 2 * 60 * 60 * 1000),
        end: new Date(now.getTime() - 1 * 60 * 60 * 1000),
        priority: 'high' as const
      }];
      
      console.log('Forcing test gap:', forcedGap);
      fetchMissingData(forcedGap);
    }
  }, [allData, companyId, detectDataGaps, fetchMissingData, isLoadingMoreData]);

  if (loading && allData.length === 0) {
    return (
      <div 
        className="flex items-center justify-center" 
        style={{ 
          height: `${height}px`, 
          backgroundColor: colors.bg,
          color: colors.text,
          fontFamily: 'Inter, system-ui, sans-serif'
        }}
      >
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4"></div>
          <p className="text-lg font-medium">Loading chart data...</p>
          <p className="text-sm opacity-70 mt-2">Optimizing for smooth performance</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div 
        className="flex items-center justify-center" 
        style={{ 
          height: `${height}px`, 
          backgroundColor: colors.bg,
          color: colors.text,
          fontFamily: 'Inter, system-ui, sans-serif'
        }}
      >
        <div className="text-center">
          <div className="text-red-500 text-6xl mb-4"></div>
          <p className="text-lg font-medium text-red-400">Error loading chart</p>
          <p className="text-sm opacity-70 mt-2">{error}</p>
        </div>
      </div>
    );
  }

  if (!data || data.length === 0) {
    return (
      <div 
        className="flex items-center justify-center" 
        style={{ 
          height: `${height}px`, 
          backgroundColor: colors.bg,
          color: colors.text,
          fontFamily: 'Inter, system-ui, sans-serif'
        }}
      >
        <div className="text-center">
          <div className="text-gray-400 text-6xl mb-4"></div>
          <p className="text-lg font-medium">No data available</p>
          <p className="text-sm opacity-70 mt-2">Select a company and date range to view the chart</p>
        </div>
      </div>
    );
  }

  return (
    <div 
      ref={containerRef}
      style={containerStyle}
    >
      <LoadingIndicator show={showLoadingIndicator || isLoadingMoreData} />

      {sidebarVisible && deviceType !== 'mobile' && (
        <div 
          className="absolute top-0 left-0 z-8 p-4 rounded-lg shadow-lg border max-h-full overflow-y-auto"
          style={{ 
            backgroundColor: colors.paper,
            borderColor: colors.grid,
            width: `${CHART_PERFORMANCE_CONFIG.SIDEBAR_WIDTH}px`,
            maxHeight: `${height - 20}px`
          }}
        >
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-lg font-semibold" style={{ color: colors.text }}>
              Chart Controls
            </h3>
            <div className="flex space-x-1">
              <button
                onClick={toggleFullscreen}
                style={buttonStyle}
                title={isFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen'}
                onMouseEnter={(e) => e.currentTarget.style.backgroundColor = colors.button.bgHover}
                onMouseLeave={(e) => e.currentTarget.style.backgroundColor = colors.button.bg}
              >
                {isFullscreen ? <Minimize2 size={16} /> : <Maximize2 size={16} />}
              </button>
              <button
                onClick={() => setSidebarVisible(false)}
                style={buttonStyle}
                onMouseEnter={(e) => e.currentTarget.style.backgroundColor = colors.button.bgHover}
                onMouseLeave={(e) => e.currentTarget.style.backgroundColor = colors.button.bg}
              >
                <EyeOff size={16} />
              </button>
            </div>
          </div>

          <div className="mb-4">
            <label className="block text-sm font-medium mb-2" style={{ color: colors.text }}>
              Theme
            </label>
            <button
              onClick={handleThemeToggle}
              style={buttonStyle}
              className="w-full justify-center"
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = colors.button.bgHover}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = colors.button.bg}
            >
              {chartTheme === 'dark' ? <Sun size={16} /> : <Moon size={16} />}
              {chartTheme === 'dark' ? 'Light Mode' : 'Dark Mode'}
            </button>
          </div>

          <div className="mb-4">
            <label className="block text-sm font-medium mb-2" style={{ color: colors.text }}>
              Time Interval
            </label>
            <div className="grid grid-cols-4 gap-1">
              {timeIntervals.map(interval => (
                <button
                  key={interval.id}
                  onClick={() => handleIntervalChange(interval.id)}
                  style={selectedInterval === interval.id ? activeButtonStyle : buttonStyle}
                  className="text-center"
                  onMouseEnter={(e) => {
                    if (selectedInterval !== interval.id) {
                      e.currentTarget.style.backgroundColor = colors.button.bgHover;
                    }
                  }}
                  onMouseLeave={(e) => {
                    if (selectedInterval !== interval.id) {
                      e.currentTarget.style.backgroundColor = colors.button.bg;
                    }
                  }}
                >
                  {interval.name}
                </button>
              ))}
            </div>
          </div>

          <div className="mb-4">
            <label className="block text-sm font-medium mb-2" style={{ color: colors.text }}>
              Chart Type
            </label>
            <div className="grid grid-cols-2 gap-1">
              {chartTypes.map(type => {
                const Icon = type.icon;
                return (
                  <button
                    key={type.id}
                    onClick={() => handleChartTypeChange(type.id)}
                    style={selectedChartType === type.id ? activeButtonStyle : buttonStyle}
                    onMouseEnter={(e) => {
                      if (selectedChartType !== type.id) {
                        e.currentTarget.style.backgroundColor = colors.button.bgHover;
                      }
                    }}
                    onMouseLeave={(e) => {
                      if (selectedChartType !== type.id) {
                        e.currentTarget.style.backgroundColor = colors.button.bg;
                      }
                    }}
                  >
                    <Icon size={14} />
                    {type.name}
                  </button>
                );
              })}
            </div>
          </div>

          <div className="mb-4">
            <label className="block text-sm font-medium mb-2" style={{ color: colors.text }}>
              Drawing Tools
            </label>
            <div className="grid grid-cols-2 gap-1">
              {drawingTools.map(tool => {
                const Icon = tool.icon;
                return (
                  <button
                    key={tool.id}
                    onClick={() => handleDrawingModeChange(drawingMode === tool.id ? null : tool.id)}
                    style={drawingMode === tool.id ? activeButtonStyle : buttonStyle}
                    onMouseEnter={(e) => {
                      if (drawingMode !== tool.id) {
                        e.currentTarget.style.backgroundColor = colors.button.bgHover;
                      }
                    }}
                    onMouseLeave={(e) => {
                      if (drawingMode !== tool.id) {
                        e.currentTarget.style.backgroundColor = colors.button.bg;
                      }
                    }}
                  >
                    <Icon size={14} />
                    {tool.name}
                  </button>
                );
              })}
            </div>
            <button
              onClick={resetChart}
              style={buttonStyle}
              className="w-full justify-center mt-2"
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = colors.button.bgHover}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = colors.button.bg}
            >
              <RotateCcw size={14} />
              Reset Chart
            </button>
            <button
              onClick={testDynamicLoading}
              style={buttonStyle}
              className="w-full justify-center mt-2"
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = colors.button.bgHover}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = colors.button.bg}
            >
               Test Dynamic Loading
            </button>
          </div>

          <div className="mb-4">
            <label className="block text-sm font-medium mb-2" style={{ color: colors.text }}>
              Technical Indicators
            </label>
            <div className="space-y-2">
              {availableIndicators.map(indicator => (
                <div key={indicator.id} className="flex items-center space-x-2">
                  <input
                    type="checkbox"
                    id={indicator.id}
                    checked={activeIndicators.includes(indicator.id)}
                    onChange={() => toggleIndicator(indicator.id)}
                    className="rounded"
                    style={{ 
                      accentColor: colors.button.bgActive,
                      backgroundColor: colors.button.bg
                    }}
                  />
                  <label 
                    htmlFor={indicator.id} 
                    className="text-sm cursor-pointer flex-1"
                    style={{ color: colors.text }}
                  >
                    {indicator.name}
                  </label>
                </div>
              ))}
            </div>
          </div>

          {activeIndicators.includes('ma') && (
            <div className="mb-4">
              <label className="block text-sm font-medium mb-2" style={{ color: colors.text }}>
                MA Periods
              </label>
              <div className="grid grid-cols-3 gap-1">
                {availableIndicators.find(ind => ind.id === 'ma')?.periods?.map(period => (
                  <button
                    key={period}
                    onClick={() => toggleMAPeriod(period)}
                    style={selectedMAperiods.includes(period) ? activeButtonStyle : buttonStyle}
                    onMouseEnter={(e) => {
                      if (!selectedMAperiods.includes(period)) {
                        e.currentTarget.style.backgroundColor = colors.button.bgHover;
                      }
                    }}
                    onMouseLeave={(e) => {
                      if (!selectedMAperiods.includes(period)) {
                        e.currentTarget.style.backgroundColor = colors.button.bg;
                      }
                    }}
                  >
                    {period}
                  </button>
                ))}
              </div>
            </div>
          )}

          {activeIndicators.includes('ema') && (
            <div className="mb-4">
              <label className="block text-sm font-medium mb-2" style={{ color: colors.text }}>
                EMA Periods
              </label>
              <div className="grid grid-cols-3 gap-1">
                {availableIndicators.find(ind => ind.id === 'ema')?.periods?.map(period => (
                  <button
                    key={period}
                    onClick={() => toggleEMAPeriod(period)}
                    style={selectedEMAperiods.includes(period) ? activeButtonStyle : buttonStyle}
                    onMouseEnter={(e) => {
                      if (!selectedEMAperiods.includes(period)) {
                        e.currentTarget.style.backgroundColor = colors.button.bgHover;
                      }
                    }}
                    onMouseLeave={(e) => {
                      if (!selectedEMAperiods.includes(period)) {
                        e.currentTarget.style.backgroundColor = colors.button.bg;
                      }
                    }}
                  >
                    {period}
                  </button>
                ))}
              </div>
            </div>
          )}

          <div className="mb-4">
            <label className="block text-sm font-medium mb-2" style={{ color: colors.text }}>
              Display Options
            </label>
            <div className="space-y-2">
              <div className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  id="volume"
                  checked={showVolume}
                  onChange={(e) => setShowVolume(e.target.checked)}
                  style={{ 
                    accentColor: colors.button.bgActive,
                    backgroundColor: colors.button.bg
                  }}
                />
                <label htmlFor="volume" className="text-sm cursor-pointer" style={{ color: colors.text }}>
                  Show Volume Chart
                </label>
              </div>
              
              <div className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  id="gridlines"
                  checked={showGridlines}
                  onChange={(e) => setShowGridlines(e.target.checked)}
                  style={{ 
                    accentColor: colors.button.bgActive,
                    backgroundColor: colors.button.bg
                  }}
                />
                <label htmlFor="gridlines" className="text-sm cursor-pointer" style={{ color: colors.text }}>
                  Show Gridlines
                </label>
              </div>
            </div>
          </div>

          <div className="mb-4">
            <div className="space-y-2">
              <button
                onClick={() => {
                  setAnnotations([]);
                  if (priceChartRef.current) {
                    priceChartRef.current.relayout({ shapes: [] });
                  }
                }}
                style={buttonStyle}
                className="w-full justify-center"
                onMouseEnter={(e) => e.currentTarget.style.backgroundColor = colors.button.bgHover}
                onMouseLeave={(e) => e.currentTarget.style.backgroundColor = colors.button.bg}
              >
                <Eraser size={14} />
                Clear Drawings
              </button>
            </div>
          </div>
        </div>
      )}

      {deviceType === 'mobile' && sidebarVisible && (
        <div 
          className="absolute bottom-0 left-0 right-0 z-10 p-3 border-t"
          style={{ 
            backgroundColor: colors.paper,
            borderColor: colors.grid,
            maxHeight: '40%',
            overflowY: 'auto'
          }}
        >
          <div className="flex justify-between items-center mb-3">
            <h4 className="text-sm font-semibold" style={{ color: colors.text }}>
              Controls
            </h4>
            <button
              onClick={() => setSidebarVisible(false)}
              style={buttonStyle}
            >
              <EyeOff size={14} />
            </button>
          </div>
          
          <div className="grid grid-cols-4 gap-2 mb-3">
            {timeIntervals.slice(0, 4).map(interval => (
              <button
                key={interval.id}
                onClick={() => handleIntervalChange(interval.id)}
                style={selectedInterval === interval.id ? activeButtonStyle : buttonStyle}
                className="text-center"
              >
                {interval.name}
              </button>
            ))}
          </div>
          
          <div className="grid grid-cols-3 gap-2">
            <button
              onClick={handleThemeToggle}
              style={buttonStyle}
              className="justify-center"
            >
              {chartTheme === 'dark' ? <Sun size={14} /> : <Moon size={14} />}
            </button>
            <button
              onClick={() => setShowVolume(!showVolume)}
              style={showVolume ? activeButtonStyle : buttonStyle}
              className="justify-center"
            >
              Volume
            </button>
            <button
              onClick={resetChart}
              style={buttonStyle}
              className="justify-center"
            >
              <RotateCcw size={14} />
            </button>
          </div>
        </div>
      )}

      {!sidebarVisible && (
        <button
          onClick={() => setSidebarVisible(true)}
          className="absolute top-4 left-4 z-10 rounded-lg shadow-lg"
          style={buttonStyle}
          onMouseEnter={(e) => e.currentTarget.style.backgroundColor = colors.button.bgHover}
          onMouseLeave={(e) => e.currentTarget.style.backgroundColor = colors.button.bg}
        >
          <Settings size={16} />
          {deviceType !== 'mobile' && 'Controls'}
        </button>
      )}

      <div 
        ref={chartContainerRef}
        style={chartContainerStyle}
      >
        <div 
          style={{ 
            height: `${priceChartHeight}px`,
            marginBottom: `${CHART_PERFORMANCE_CONFIG.CHART_GAP}px`
          }}
        >
          <Plot
            ref={priceChartRef}
            data={priceChartData}
            layout={priceChartLayout}
            config={config}
            style={{ width: '100%', height: '100%' }}
            onUpdate={handlePlotUpdate}
            onRelayout={handlePriceChartRelayout}
            useResizeHandler={true}
            onInitialized={() => {
              console.log('Price chart initialized');
            }}
          />
        </div>

        {showVolume && volumeChartHeight > 0 && (
          <div 
            style={{ 
              height: `${volumeChartHeight}px`,
              marginBottom: `${CHART_PERFORMANCE_CONFIG.CHART_GAP}px`
            }}
          >
            <Plot
              ref={volumeChartRef}
              data={volumeChartData}
              layout={volumeChartLayout}
              config={config}
              style={{ width: '100%', height: '100%' }}
              onRelayout={handleVolumeChartRelayout}
              useResizeHandler={true}
              onInitialized={() => {
                console.log('Volume chart initialized');
              }}
            />
          </div>
        )}

        {activeIndicators.includes('rsi') && rsiChartHeight > 0 && (
          <div 
            style={{ 
              height: `${rsiChartHeight}px`,
              marginBottom: `${CHART_PERFORMANCE_CONFIG.CHART_GAP}px`
            }}
          >
            <Plot
              ref={rsiChartRef}
              data={rsiChartData}
              layout={rsiChartLayout}
              config={config}
              style={{ width: '100%', height: '100%' }}
              onRelayout={handleRsiChartRelayout}
              useResizeHandler={true}
              onInitialized={() => {
                console.log('RSI chart initialized');
              }}
            />
          </div>
        )}

        {activeIndicators.includes('macd') && macdChartHeight > 0 && (
          <div 
            style={{ 
              height: `${macdChartHeight}px`,
              marginBottom: `${CHART_PERFORMANCE_CONFIG.CHART_GAP}px`
            }}
          >
            <Plot
              ref={macdChartRef}
              data={macdChartData}
              layout={macdChartLayout}
              config={config}
              style={{ width: '100%', height: '100%' }}
              onRelayout={handleMacdChartRelayout}
              useResizeHandler={true}
              onInitialized={() => {
                console.log('MACD chart initialized');
              }}
            />
          </div>
        )}

        <div 
          className="absolute bottom-4 right-4 p-3 rounded-lg shadow-lg border text-xs"
          style={{ 
            backgroundColor: colors.paper,
            borderColor: colors.grid,
            color: colors.text,
            maxWidth: deviceType === 'mobile' ? '200px' : '250px'
          }}
        >
        </div>

        <div className="absolute top-4 left-20">
          <div className="flex items-center space-x-2">
          </div>
        </div>
      </div>
    </div>
  );
}

export default StockChart;


================================================================================
FILE: apps/frontend/hooks/useMarketData.ts
PURPOSE: Market data hook
================================================================================

import { useState, useEffect, useCallback } from 'react';
import { getSocket } from '../lib/socket';

interface MarketData {
  ltp: number;
  change: number;
  changePercent: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
  timestamp: number;
}

interface UseMarketDataReturn {
  data: Record<string, MarketData>;
  isLoading: boolean;
  error: Error | null;
  subscribeToSymbol: (symbol: string) => void;
  unsubscribeFromSymbol: (symbol: string) => void;
}

export const useMarketData = (initialSymbols: string[] = []): UseMarketDataReturn => {
  const [data, setData] = useState<Record<string, MarketData>>({});
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<Error | null>(null);
  const [subscribedSymbols, setSubscribedSymbols] = useState<Set<string>>(
    new Set(initialSymbols)
  );

  const subscribeToSymbol = useCallback((symbol: string) => {
    setSubscribedSymbols((prev) => {
      const newSet = new Set(prev);
      newSet.add(symbol);
      return newSet;
    });
    
    getSocket().emit('subscribe', { symbol });
  }, []);

  const unsubscribeFromSymbol = useCallback((symbol: string) => {
    setSubscribedSymbols((prev) => {
      const newSet = new Set(prev);
      newSet.delete(symbol);
      return newSet;
    });
    
    getSocket().emit('unsubscribe', { symbol });
    
    setData((prev) => {
      const newData = { ...prev };
      delete newData[symbol];
      return newData;
    });
  }, []);

  useEffect(() => {
    const socket = getSocket();
    
    const handleMarketData = (message: { symbol: string; data: MarketData }) => {
      setData((prev) => ({
        ...prev,
        [message.symbol]: message.data,
      }));
      
      setIsLoading(false);
    };
    
    socket.on('marketData', handleMarketData);
    
    initialSymbols.forEach((symbol) => {
      socket.emit('subscribe', { symbol });
    });
    
    return () => {
      socket.off('marketData', handleMarketData);
      
      subscribedSymbols.forEach((symbol) => {
        socket.emit('unsubscribe', { symbol });
      });
    };
  }, [initialSymbols]);

  return {
    data,
    isLoading,
    error,
    subscribeToSymbol,
    unsubscribeFromSymbol,
  };
};


================================================================================
FILE: apps/frontend/hooks/useWatchlist.ts
PURPOSE: Watchlist hook
================================================================================

import { useState, useEffect, useRef, useCallback } from 'react';

interface MergedCompany {
  company_id?: number;
  company_code: string;
  name: string;
  exchange: string;
  marker: string;
  total_valid_days?: number;
  avg_daily_high_low_range?: number;
  median_daily_volume?: number;
  avg_trading_capital?: number;
  pe_ratio?: number;
  N1_Pattern_count?: number;
}

interface WatchlistResponse {
  companies: MergedCompany[];
  exists: boolean;
  total: number;
}

interface UseWatchlistOptions {
  externalWatchlist?: string;
}

export function useWatchlist(options: UseWatchlistOptions = {}) {
  const [selectedWatchlist, setSelectedWatchlist] = useState('A');
  const [companies, setCompanies] = useState<MergedCompany[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [exists, setExists] = useState(true);
  const [availableExchanges, setAvailableExchanges] = useState<string[]>([]);
  const [totalCompanies, setTotalCompanies] = useState(0);
  const [availableMarkers, setAvailableMarkers] = useState<string[]>([]);

  const prevExternalWatchlist = useRef(options.externalWatchlist);
  
  const activeWatchlist = options.externalWatchlist || selectedWatchlist;

  useEffect(() => {
    if (options.externalWatchlist && 
        options.externalWatchlist !== prevExternalWatchlist.current && 
        options.externalWatchlist !== selectedWatchlist) {
      console.log(`[useWatchlist] External watchlist changed from ${prevExternalWatchlist.current} to ${options.externalWatchlist}`);
      prevExternalWatchlist.current = options.externalWatchlist;
      setSelectedWatchlist(options.externalWatchlist);
    }
  }, [options.externalWatchlist, selectedWatchlist]);

  useEffect(() => {
    let isCancelled = false;
    
    async function fetchWatchlist() {
      console.log(`[useWatchlist] Starting to fetch watchlist: ${activeWatchlist}`);
      setLoading(true);
      setError(null);

      try {
        const today = "2025-06-05";
        const apiUrl = `http://localhost:5000/api/watchlist/${activeWatchlist}?date=${today}`;
        
        console.log(`[useWatchlist] Fetching from: ${apiUrl}`);

        try {
          const healthCheck = await fetch('http://localhost:5000/health', {
            method: 'GET',
            signal: AbortSignal.timeout(5000)
          });
          console.log(`[useWatchlist] Backend health check: ${healthCheck.status}`);
        } catch (healthError) {
          console.error(`[useWatchlist] Backend health check failed:`, healthError);
          throw new Error('Backend server is not running on localhost:3001. Please start the backend server.');
        }

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000);

        const response = await fetch(apiUrl, { 
          signal: controller.signal,
          method: 'GET',
          headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Cache-Control': 'no-cache'
          },
          mode: 'cors'
        });
        
        clearTimeout(timeoutId);

        console.log(`[useWatchlist] Response status: ${response.status}`);
        console.log(`[useWatchlist] Response headers:`, Object.fromEntries(response.headers.entries()));

        if (!response.ok) {
          const errorText = await response.text();
          console.error(`[useWatchlist] Error response body:`, errorText);
          
          if (response.status === 404) {
            throw new Error(`Watchlist ${activeWatchlist} not found for date ${today}. Check if the endpoint exists.`);
          } else if (response.status === 500) {
            throw new Error(`Server error (${response.status}): ${errorText || 'Internal server error'}`);
          } else {
            throw new Error(`HTTP error ${response.status}: ${errorText || response.statusText}`);
          }
        }

        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
          const responseText = await response.text();
          console.error(`[useWatchlist] Non-JSON response:`, responseText);
          throw new Error('Server returned non-JSON response. Check API endpoint.');
        }

        const data: WatchlistResponse = await response.json();
        
        if (isCancelled) return;
        
        console.log(`[useWatchlist] Raw API response for watchlist ${activeWatchlist}:`, data);

        if (!data || typeof data !== 'object') {
          throw new Error('Invalid response format from server');
        }

        if (!Array.isArray(data.companies)) {
          console.warn(`[useWatchlist] No companies array in response:`, data);
          setCompanies([]);
          setExists(false);
          setTotalCompanies(0);
          setAvailableExchanges([]);
          setAvailableMarkers([]);
          setError(`No companies found for watchlist ${activeWatchlist} on ${today}`);
          return;
        }

        const validCompanies = data.companies.filter((company: MergedCompany) => {
          const isValid = company.company_code && 
                          company.name && 
                          company.exchange &&
                          company.marker;
          
          if (!isValid) {
            console.warn(`[useWatchlist] Invalid company filtered out:`, company);
          }
          return isValid;
        });

        console.log(`[useWatchlist] Valid companies after filtering for ${activeWatchlist}: ${validCompanies.length} out of ${data.companies.length}`);

        setCompanies(validCompanies);
        setExists(data.exists !== false); // Default to true if not specified
        setTotalCompanies(data.total || validCompanies.length);
        
        const exchanges = [...new Set(validCompanies.map((c: MergedCompany) => c.exchange))];
        const markers = [...new Set(validCompanies.map((c: MergedCompany) => c.marker))];
        
        setAvailableExchanges(exchanges);
        setAvailableMarkers(markers);
        
        console.log(`[useWatchlist] Successfully loaded ${validCompanies.length} companies from watchlist ${activeWatchlist}`);
        console.log(`[useWatchlist] Available exchanges: ${exchanges.join(', ')}`);
        
      } catch (err: any) {
        if (isCancelled) return;
        
        console.error(`[useWatchlist] Error fetching watchlist ${activeWatchlist}:`, err);
        console.error(`[useWatchlist] Error details:`, {
          name: err.name,
          message: err.message,
          stack: err.stack
        });
        
        let errorMessage = 'Failed to fetch watchlist data.';
        
        if (err.name === 'AbortError') {
          errorMessage = 'Request timed out. Please try again.';
        } else if (err.message.includes('Backend server is not running')) {
          errorMessage = err.message;
        } else if (err.message.includes('Failed to fetch') || err.name === 'TypeError') {
          errorMessage = 'Cannot connect to backend server. Please ensure:\n1. Backend is running on http://localhost:3001\n2. No firewall blocking the connection\n3. CORS is properly configured';
        } else if (err.message.includes('not found')) {
          errorMessage = err.message;
        } else {
          errorMessage = `Error: ${err.message}`;
        }
        
        setError(errorMessage);
        setCompanies([]);
        setExists(false);
        setAvailableExchanges([]);
        setAvailableMarkers([]);
        setTotalCompanies(0);
      } finally {
        if (!isCancelled) {
          setLoading(false);
        }
      }
    }

    fetchWatchlist();
    
    return () => {
      isCancelled = true;
    };
  }, [activeWatchlist]);

  const getCompanyByCode = useCallback(async (companyCode: string, exchange?: string): Promise<MergedCompany | null> => {
    try {
      const queryParams = new URLSearchParams({ companyCode });
      if (exchange) {
        queryParams.append('exchange', exchange);
      }
      
      const response = await fetch(`http://localhost:5000/api/watchlist/company/${companyCode}?${queryParams}`);
      
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      
      const data = await response.json();
      return data.company;
    } catch (error) {
      console.error('[useWatchlist] Error fetching company by code:', error);
      return null;
    }
  }, []);

  const getFilteredCompanies = useCallback((filters: {
    exchange?: string;
    marker?: string;
    minValidDays?: number;
  }) => {
    return companies.filter(company => {
      if (filters.exchange && company.exchange.toUpperCase() !== filters.exchange.toUpperCase()) {
        return false;
      }
      if (filters.marker && company.marker.toUpperCase() !== filters.marker.toUpperCase()) {
        return false;
      }
      if (filters.minValidDays && (!company.total_valid_days || company.total_valid_days < filters.minValidDays)) {
        return false;
      }
      return true;
    });
  }, [companies]);

  return { 
    selectedWatchlist: activeWatchlist, 
    setSelectedWatchlist, 
    companies, 
    loading, 
    error, 
    exists,
    availableExchanges,
    availableMarkers,
    totalCompanies,
    getCompanyByCode,
    getFilteredCompanies
  };
}


================================================================================
FILE: apps/frontend/lib/socket.ts
PURPOSE: Socket connection configuration
================================================================================


import { io, Socket } from 'socket.io-client';

let socket: Socket | null = null;
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;

export const getSocket = (): Socket => {
  if (!socket) {
    const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL || 'http://localhost:5001';
    console.log(`Connecting to WebSocket server at ${SOCKET_URL}`);
    
    socket = io(SOCKET_URL, {
      reconnectionAttempts: MAX_RECONNECT_ATTEMPTS,
      reconnectionDelay: 1000,
      timeout: 10000,
      transports: ['websocket', 'polling']
    });
    
    socket.on('connect', () => {
      console.log(`Connected to WebSocket server with ID: ${socket?.id}`);
      reconnectAttempts = 0;
    });
    
    socket.on('connect_error', (error) => {
      console.error('Socket connection error:', error.message);
      reconnectAttempts++;
    });
    
    socket.on('disconnect', (reason) => {
      console.log(`Disconnected from WebSocket server. Reason: ${reason}`);
    });
    
    socket.on('error', (error) => {
      console.error('Socket error:', error);
    });
    
    socket.on('heartbeat', (data) => {
      console.log('Heartbeat received:', data);
    });
  }
  
  return socket;
};

export const disconnectSocket = (): void => {
  if (socket) {
    console.log('Manually disconnecting socket');
    socket.disconnect();
    socket = null;
  }
};


################################################################################
SECTION 3: DATA FILES
################################################################################

================================================================================
FILE: apps/backend/data/watchlists/watchlist_A_2025-02-16.csv (FIRST 10 ROWS)
PURPOSE: Sample watchlist A data
================================================================================

[FILE NOT FOUND OR EMPTY] 


################################################################################
SECTION 4: CONFIGURATION FILES
################################################################################

================================================================================
FILE: apps/backend/src/app.module.ts
PURPOSE: Main app module structure
================================================================================

import { Module } from '@nestjs/common';
import { StockModule } from './stock/stocks.module';
import { WatchlistModule } from './watchlist/watchlist.module';
import { AppController } from './app.controller';
import { AppService } from './app.service';
// import { MarketDataModule } from './market-data/market-data.module';

@Module({
  imports: [
   
    WatchlistModule, 
    StockModule,     
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}


================================================================================
FILE: apps/frontend/app/layout.tsx
PURPOSE: App layout for navigation integration
================================================================================

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { ThemeProvider } from "./components/theme-provider";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <ThemeProvider
            attribute="class"
            defaultTheme="system"
            enableSystem
            disableTransitionOnChange
          >
            {children}
          </ThemeProvider>
      </body>
    </html>
  );
}


################################################################################
END OF IMPLEMENTATION ANALYSIS EXTRACTION
################################################################################

EXTRACTION SUMMARY:
===================
Backend Files (Python and NestJS): 10 files
Frontend Files (Next.js/React): 7 files
Data Files: 1 file
Configuration Files: 2 files

TOTAL FILES PROCESSED: 20 FILES
################################################################################
