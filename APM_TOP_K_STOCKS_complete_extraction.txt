================================================================================
APM-TOP-K-STOCKS PROJECT - COMPLETE FILE EXTRACTION
Generated on: 02-11-2025 22:41:12.18
================================================================================

PROJECT: Stock Market Analytics and Real-time Trading Dashboard
TECH STACK: Next.js 15 + NestJS + Python + PostgreSQL

FILE CATEGORIES:
?? CRITICAL FILES (Core Functionality) - 16 files
   1. Frontend Files - 8 files
   2. Backend Files - 5 files
   3. Configuration Files - 3 files

?? IMPORTANT FILES (Recommended) - 11 files
   4. Chart Components - 4 files
   5. Data Management - 3 files
   6. Layout and UI - 4 files

?? OPTIONAL FILES (Context) - 6 files
   7. Reference Files - 6 files

?? PYTHON SERVICE FILES (Backend Integration) - 4 files
   8. Python Services - 4 files

TOTAL: 37 FILES
================================================================================


################################################################################
?? SECTION 1: CRITICAL FILES - FRONTEND FILES
################################################################################

================================================================================
FILE 1/37: apps/frontend/app/market-data/page.tsx
CATEGORY: Frontend - Core Page
PURPOSE: Main market data page component
PRIORITY: ?? CRITICAL
================================================================================

// ============ COMPLETELY FIXED: Market Data Component - No Hook Errors ============
'use client';
import React, { useEffect, useState, useCallback, useMemo, useRef } from 'react';
import { getSocket } from '@/lib/socket';
import dynamic from 'next/dynamic';
import { AppSidebar } from "../components/app-sidebar";
import {
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
  BreadcrumbSeparator,
} from "@/components/ui/breadcrumb";
import { Separator } from "@/components/ui/separator";
import {
  SidebarInset,
  SidebarProvider,
  SidebarTrigger,
} from "@/components/ui/sidebar";
import { ModeToggle } from "../components/toggleButton";
import { Card, CardContent } from "@/components/ui/card";
import { WatchlistSelector } from "../components/controllers/WatchlistSelector2/WatchlistSelector";
import { ImageCarousel } from "./components/ImageCarousel";
import { useWatchlist } from "@/hooks/useWatchlist";
import { ViewInDashboardButton } from "../components/ViewInDashboardButton";
import { TrendingUp, TrendingDown, Minus, Database, Wifi, Award } from 'lucide-react';


const PlotlyChart = dynamic(() => import('./components/charts/PlotlyChart'), { 
  ssr: false,
  loading: () => (
    <div className="w-full h-full flex items-center justify-center bg-zinc-900">
      <div className="animate-pulse text-blue-500">Loading chart...</div>
    </div>
  )
});


interface MarketData {
  symbol: string;
  ltp: number;
  change?: number;
  changePercent?: number;
  open?: number;
  high?: number;
  low?: number;
  close?: number;
  volume?: number;
  bid?: number;
  ask?: number;
  timestamp: number;
  sma_20?: number;
  ema_9?: number;
  rsi_14?: number;
}


interface ChartUpdate {
  symbol: string;
  price: number;
  timestamp: number;
  volume: number;
  change: number;
  changePercent: number;
}


interface OHLCData {
  timestamp: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
}


interface TradingHours {
  start: string;
  end: string;
  current: string;
  isActive: boolean;
}


const MarketDataPage: React.FC = () => {
  const [isClient, setIsClient] = useState(false);
  const [selectedSymbol, setSelectedSymbol] = useState<string>('');
  const [selectedCompany, setSelectedCompany] = useState<string | null>(null);
  const [selectedExchange, setSelectedExchange] = useState<string | null>(null);
  const [selectedWatchlist, setSelectedWatchlist] = useState('A');


  // State management
  const [marketData, setMarketData] = useState<Record<string, MarketData>>({});
  const [historicalData, setHistoricalData] = useState<Record<string, MarketData[]>>({});
  const [ohlcData, setOhlcData] = useState<Record<string, OHLCData[]>>({});
  const [chartUpdates, setChartUpdates] = useState<Record<string, ChartUpdate[]>>({});


  const [socketStatus, setSocketStatus] = useState<string>('Disconnected');
  const [lastDataReceived, setLastDataReceived] = useState<Date | null>(null);
  const [dataCount, setDataCount] = useState<number>(0);
  const [updateFrequency, setUpdateFrequency] = useState<number>(0);
  const [tradingHours, setTradingHours] = useState<TradingHours>({
    start: '',
    end: '',
    current: '',
    isActive: false
  });


  const [activeSymbols, setActiveSymbols] = useState<string[]>([]);
  const [backgroundDataPoints, setBackgroundDataPoints] = useState<number>(0);
  const [gradientMode, setGradientMode] = useState<'profit' | 'loss' | 'neutral'>('neutral');

  // New state for usefulness score
  const [usefulnessScore, setUsefulnessScore] = useState<number | null>(null);
  const [showScoreTooltip, setShowScoreTooltip] = useState(false);


  // Refs
  const updateCountRef = useRef(0);
  const lastUpdateTimeRef = useRef(Date.now());
  const frequencyIntervalRef = useRef<NodeJS.Timeout>();
  const socketRef = useRef<any>(null);
  const isSubscribedRef = useRef<Set<string>>(new Set());


  const { 
    companies, 
    loading: watchlistLoading, 
    error: watchlistError,
    selectedWatchlist: currentWatchlist,
    setSelectedWatchlist: setWatchlist,
  } = useWatchlist();


  // ============ FIXED: All stable functions defined at component level ============
  const validateAndFormatSymbol = useCallback((companyCode: string, exchange: string, marker: string = 'EQ'): string => {
    const cleanSymbol = companyCode.replace(/[^A-Z0-9]/g, '').toUpperCase();


    if (!cleanSymbol || cleanSymbol.length === 0) {
      return '';
    }


    switch (exchange.toUpperCase()) {
      case 'NSE':
        return `NSE:${cleanSymbol}-${marker}`;
      case 'BSE':
        return `BSE:${cleanSymbol}-${marker}`;
      default:
        return `${exchange}:${cleanSymbol}-${marker}`;
    }
  }, []);


  const handleCompanyChange = useCallback((companyCode: string | null, exchange?: string, marker?: string) => {
    console.log(`Company selected: ${companyCode} (${exchange}, ${marker})`);


    setSelectedCompany(companyCode);
    setSelectedExchange(exchange || null);


    if (companyCode && exchange) {
      const formattedSymbol = validateAndFormatSymbol(companyCode, exchange, marker);
      console.log(`Formatted symbol: ${formattedSymbol}`);
      setSelectedSymbol(formattedSymbol);
    } else {
      setSelectedSymbol('');
    }
  }, [validateAndFormatSymbol]);


  const handleWatchlistChange = useCallback((watchlist: string) => {
    console.log(`Watchlist changed to: ${watchlist}`);
    setSelectedWatchlist(watchlist);
    setWatchlist(watchlist);
    setSelectedCompany(null);
    setSelectedSymbol('');
  }, [setWatchlist]);


  // ============ NEW: Usefulness Score Handler ============
  const handleFetchUsefulnessScore = useCallback(() => {
    // Simulate fetching score - replace with actual server call
    setUsefulnessScore(90);
  }, []);

  const getScoreEvaluation = useCallback((score: number) => {
    if (score >= 80) return { text: 'Great', color: 'text-green-400', bgColor: 'bg-green-500/10', borderColor: 'border-green-500/40' };
    if (score >= 60) return { text: 'Good', color: 'text-blue-400', bgColor: 'bg-blue-500/10', borderColor: 'border-blue-500/40' };
    if (score >= 40) return { text: 'Average', color: 'text-yellow-400', bgColor: 'bg-yellow-500/10', borderColor: 'border-yellow-500/40' };
    return { text: 'Poor', color: 'text-red-400', bgColor: 'bg-red-500/10', borderColor: 'border-red-500/40' };
  }, []);


  // ============ FIXED: Event handlers defined at component level ============
  const handleConnect = useCallback(() => {
    console.log('‚úÖ Connected to server');
    setSocketStatus('Connected');


    if (socketRef.current) {
      socketRef.current.emit('get_trading_status', {}, (response: any) => {
        if (response) {
          setTradingHours({
            start: response.trading_start || '',
            end: response.trading_end || '',
            current: response.current_time || '',
            isActive: response.trading_active || false
          });


          if (response.active_symbols) {
            setActiveSymbols(response.active_symbols);
          }
          if (response.total_data_points) {
            setBackgroundDataPoints(response.total_data_points);
          }
        }
      });
    }
  }, []);


  const handleDisconnect = useCallback((reason: string) => {
    console.log('‚ùå Disconnected:', reason);
    setSocketStatus(`Disconnected: ${reason}`);
  }, []);


  const handleError = useCallback((error: any) => {
    console.error('‚ùå Socket error:', error);
    setSocketStatus(`Error: ${error.message || 'Unknown'}`);
  }, []);


  const handleMarketDataUpdate = useCallback((data: MarketData) => {
    if (!data || !data.symbol) return;


    updateCountRef.current++;
    setLastDataReceived(new Date());
    setDataCount(prev => prev + 1);


    setMarketData(prev => ({
      ...prev,
      [data.symbol]: data
    }));


    setHistoricalData(prev => {
      const symbol = data.symbol;
      const existingHistory = prev[symbol] || [];


      const exists = existingHistory.some(item => item.timestamp === data.timestamp);
      if (exists) return prev;


      const newHistory = [...existingHistory, data].slice(-10000);
      newHistory.sort((a, b) => a.timestamp - b.timestamp);


      return {
        ...prev,
        [symbol]: newHistory
      };
    });
  }, []);


  const handleChartUpdate = useCallback((update: ChartUpdate) => {
    if (!update || !update.symbol) return;


    updateCountRef.current++;


    setChartUpdates(prev => {
      const symbolUpdates = prev[update.symbol] || [];
      const newUpdates = [...symbolUpdates, update].slice(-1000);


      return {
        ...prev,
        [update.symbol]: newUpdates
      };
    });
  }, []);


  const handleHistoricalData = useCallback((data: { symbol: string, data: MarketData[] }) => {
    if (!data || !data.symbol || !Array.isArray(data.data)) return;


    console.log(`üìà Received historical data for ${data.symbol}: ${data.data.length} points`);


    const sortedData = [...data.data].sort((a, b) => a.timestamp - b.timestamp);


    setHistoricalData(prev => ({
      ...prev,
      [data.symbol]: sortedData
    }));


    if (sortedData.length > 0) {
      setMarketData(prev => ({
        ...prev,
        [data.symbol]: sortedData[sortedData.length - 1]
      }));


      const chartData = sortedData.map(item => ({
        symbol: data.symbol,
        price: item.ltp,
        timestamp: item.timestamp,
        volume: item.volume || 0,
        change: item.change || 0,
        changePercent: item.changePercent || 0
      }));


      setChartUpdates(prev => ({
        ...prev,
        [data.symbol]: chartData
      }));
    }
  }, []);


  const handleOhlcData = useCallback((data: { symbol: string, data: OHLCData[] }) => {
    if (!data || !data.symbol || !Array.isArray(data.data)) return;


    console.log(`üìä Received OHLC data for ${data.symbol}: ${data.data.length} candles`);


    const sortedData = [...data.data].sort((a, b) => a.timestamp - b.timestamp);


    setOhlcData(prev => ({
      ...prev,
      [data.symbol]: sortedData
    }));
  }, []);


  const handleHeartbeat = useCallback((data: any) => {
    if (!data) return;


    setTradingHours(prev => ({
      ...prev,
      current: new Date().toISOString(),
      isActive: data.trading_active || false
    }));


    if (data.active_symbols && Array.isArray(data.active_symbols)) {
      setActiveSymbols(data.active_symbols);
    }
    if (typeof data.total_cached_points === 'number') {
      setBackgroundDataPoints(data.total_cached_points);
    }
  }, []);


  // Utility functions
  const formatPrice = useCallback((price?: number) => {
    return price?.toFixed(2) || '0.00';
  }, []);


  const formatChange = useCallback((change?: number, percent?: number) => {
    if ((!change && change !== 0) || (!percent && percent !== 0)) return '-';
    const sign = change >= 0 ? '+' : '';
    return `${sign}${change.toFixed(2)} (${sign}${percent.toFixed(2)}%)`;
  }, []);


  const getChangeClass = useCallback((change?: number) => {
    if (!change && change !== 0) return '';
    return change >= 0 ? 'text-green-500' : 'text-red-500';
  }, []);


  const getSentimentIndicator = useCallback((mode: 'profit' | 'loss' | 'neutral') => {
    switch (mode) {
      case 'profit':
        return {
          background: 'bg-gradient-to-r from-green-500/10 to-green-900/10 border-green-500/40',
          text: 'text-green-400',
          icon: TrendingUp,
          label: 'Positive Sentiment'
        };
      case 'loss':
        return {
          background: 'bg-gradient-to-r from-red-500/10 to-red-900/10 border-red-500/40',
          text: 'text-red-400',
          icon: TrendingDown,
          label: 'Negative Sentiment'
        };
      case 'neutral':
      default:
        return {
          background: 'bg-gradient-to-r from-zinc-500/30 to-zinc-600/20 border-zinc-500/40',
          text: 'text-zinc-400',
          icon: Minus,
          label: 'Neutral Sentiment'
        };
    }
  }, []);


  // ============ FIXED: Update frequency calculation ============
  useEffect(() => {
    const interval = setInterval(() => {
      const now = Date.now();
      const timeDiff = (now - lastUpdateTimeRef.current) / 1000;
      const frequency = timeDiff > 0 ? Math.round(updateCountRef.current / timeDiff) : 0;
      setUpdateFrequency(frequency);
      updateCountRef.current = 0;
      lastUpdateTimeRef.current = now;
    }, 1000);


    return () => clearInterval(interval);
  }, []);


  // ============ FIXED: Auto-select first company ============
  useEffect(() => {
    if (companies.length > 0 && !selectedCompany) {
      const firstCompany = companies[0];
      console.log(`Auto-selecting first company: ${firstCompany.company_code}`);
      handleCompanyChange(firstCompany.company_code, firstCompany.exchange, firstCompany.marker);
    }
  }, [companies.length, selectedCompany, handleCompanyChange]);


  // ============ FIXED: Client initialization ============
  useEffect(() => {
    setIsClient(true);
    console.log('Component mounted');
  }, []);


  // ============ FIXED: WebSocket connection ============
  useEffect(() => {
    if (!isClient) return;


    console.log('üöÄ Initializing WebSocket connection...');


    const socket = getSocket();
    socketRef.current = socket;


    // Register event handlers
    socket.on('connect', handleConnect);
    socket.on('disconnect', handleDisconnect);
    socket.on('error', handleError);
    socket.on('marketDataUpdate', handleMarketDataUpdate);
    socket.on('chartUpdate', handleChartUpdate);
    socket.on('historicalData', handleHistoricalData);
    socket.on('ohlcData', handleOhlcData);
    socket.on('heartbeat', handleHeartbeat);


    return () => {
      socket.off('connect', handleConnect);
      socket.off('disconnect', handleDisconnect);
      socket.off('error', handleError);
      socket.off('marketDataUpdate', handleMarketDataUpdate);
      socket.off('chartUpdate', handleChartUpdate);
      socket.off('historicalData', handleHistoricalData);
      socket.off('ohlcData', handleOhlcData);
      socket.off('heartbeat', handleHeartbeat);
    };
  }, [isClient, handleConnect, handleDisconnect, handleError, handleMarketDataUpdate, handleChartUpdate, handleHistoricalData, handleOhlcData, handleHeartbeat]);


  // ============ FIXED: Symbol subscription management ============
  useEffect(() => {
    if (!isClient || !selectedSymbol || !socketRef.current) return;


    const socket = socketRef.current;


    if (isSubscribedRef.current.has(selectedSymbol)) {
      console.log(`Already subscribed to ${selectedSymbol}`);
      return;
    }


    console.log('üîÑ Subscribing to symbol:', selectedSymbol);


    socket.emit('subscribe', { symbol: selectedSymbol }, (response: any) => {
      if (response && response.success) {
        isSubscribedRef.current.add(selectedSymbol);
        console.log(`‚úÖ Successfully subscribed to ${selectedSymbol}`);
      }
    });


    return () => {
      if (isSubscribedRef.current.has(selectedSymbol)) {
        console.log('üõë Unsubscribing from:', selectedSymbol);
        socket.emit('unsubscribe', { symbol: selectedSymbol });
        isSubscribedRef.current.delete(selectedSymbol);
      }
    };
  }, [selectedSymbol, isClient]);


  // Memoized data calculations
  const currentData = useMemo(() => 
    marketData[selectedSymbol] || null, 
    [marketData, selectedSymbol]
  );


  const symbolHistory = useMemo(() => 
    historicalData[selectedSymbol] || [], 
    [historicalData, selectedSymbol]
  );


  const symbolOhlc = useMemo(() => 
    ohlcData[selectedSymbol] || [], 
    [ohlcData, selectedSymbol]
  );


  const symbolChartUpdates = useMemo(() => 
    chartUpdates[selectedSymbol] || [], 
    [chartUpdates, selectedSymbol]
  );


  const totalCachedSymbols = useMemo(() => Object.keys(marketData).length, [marketData]);
  const totalHistoricalPoints = useMemo(() => 
    Object.values(historicalData).reduce((sum, data) => sum + data.length, 0), 
    [historicalData]
  );


  if (!isClient) {
    return (
      <SidebarProvider>
        <AppSidebar />
        <SidebarInset>
          <header className="flex h-16 shrink-0 items-center gap-2 w-full">
            <div className="flex items-center gap-2 px-4">
              <SidebarTrigger className="-ml-1" />
              <Separator orientation="vertical" className="mr-2 h-4" />
              <Breadcrumb className="flex items-center justify-end gap-2">
                <BreadcrumbList>
                  <BreadcrumbItem className="hidden md:block">
                    <BreadcrumbLink href="#">
                      Home
                    </BreadcrumbLink>
                  </BreadcrumbItem>
                  <BreadcrumbSeparator className="hidden md:block" />
                  <BreadcrumbItem>
                    <BreadcrumbPage>Market Data</BreadcrumbPage>
                  </BreadcrumbItem>
                </BreadcrumbList>
                <ModeToggle />
              </Breadcrumb>
            </div>
          </header>
          <div className="flex flex-1 flex-col gap-4 p-4 pt-0">
            <div className="container mx-auto p-4 bg-zinc-900 text-white flex items-center justify-center h-[80vh]">
              <div className="text-xl animate-pulse">Loading market data...</div>
            </div>
          </div>
        </SidebarInset>
      </SidebarProvider>
    );
  }


  return (
    <SidebarProvider>
      <AppSidebar />
      <SidebarInset>
        <header className="flex h-16 shrink-0 items-center gap-2 w-full">
          <div className="flex items-center gap-2 px-4 w-full">
            <SidebarTrigger className="-ml-1" />
            <Separator orientation="vertical" className="mr-2 h-4" />
            <Breadcrumb className="flex items-center justify-between w-full">
              <BreadcrumbList>
                <BreadcrumbItem className="hidden md:block">
                  <BreadcrumbLink href="#">
                    Home
                  </BreadcrumbLink>
                </BreadcrumbItem>
                <BreadcrumbSeparator className="hidden md:block" />
                <BreadcrumbItem>
                  <BreadcrumbPage>Live Market Data</BreadcrumbPage>
                </BreadcrumbItem>
              </BreadcrumbList>
              <ModeToggle />
            </Breadcrumb>
          </div>
        </header>


        <div className="flex flex-1 flex-col gap-4 p-4 pt-0">
          <Card className="w-full">
            <CardContent className="p-4">
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <h3 className="text-lg font-medium">Live Market Data</h3>
                  <div className="flex items-center space-x-4">
                    <div className="flex items-center space-x-2">
                      <span className={`inline-block w-2 h-2 rounded-full ${
                        socketStatus.includes('Connected') ? 'bg-green-500 animate-pulse' : 'bg-red-500'
                      }`}></span>
                      <span className="text-sm text-muted-foreground">{socketStatus}</span>
                    </div>
                  </div>
                </div>


                <div className="p-3 border border-opacity-30 rounded-md h-24 flex items-center justify-between">
                  <WatchlistSelector
                    onCompanySelect={handleCompanyChange}
                    selectedWatchlist={selectedWatchlist}
                    onWatchlistChange={handleWatchlistChange}
                    showExchangeFilter={true}
                    showMarkerFilter={true}
                  />
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                  <div className="p-3 bg-zinc-800 rounded">
                    <div className="flex items-center space-x-2 mb-2">
                      <Wifi className="h-4 w-4 text-green-500" />
                      <span className="text-green-400 font-medium">Active Background ({activeSymbols.length})</span>
                    </div>
                    <div className="max-h-20 overflow-y-auto">
                      {activeSymbols.length > 0 ? (
                        <div className="flex flex-wrap gap-1">
                          {activeSymbols.slice(0, 5).map(symbol => (
                            <span key={symbol} className="text-xs bg-green-900/50 text-green-300 px-2 py-1 rounded">
                              {symbol.split(':')[1]?.split('-')[0] || symbol}
                            </span>
                          ))}
                          {activeSymbols.length > 5 && (
                            <span className="text-xs bg-green-900/50 text-green-300 px-2 py-1 rounded">
                              +{activeSymbols.length - 5} more
                            </span>
                          )}
                        </div>
                      ) : (
                        <span className="text-zinc-500 text-xs">No active symbols</span>
                      )}
                    </div>
                  </div>


                  <div className="p-3 bg-zinc-800 rounded">
                    <div className="flex items-center space-x-2 mb-2">
                      <Database className="h-4 w-4 text-blue-500" />
                      <span className="text-blue-400 font-medium">Cached Data ({Object.keys(historicalData).length})</span>
                    </div>
                    <div className="max-h-20 overflow-y-auto">
                      {Object.keys(historicalData).length > 0 ? (
                        <div className="flex flex-wrap gap-1">
                          {Object.keys(historicalData).slice(0, 5).map(symbol => (
                            <span key={symbol} className="text-xs bg-blue-900/50 text-blue-300 px-2 py-1 rounded">
                              {symbol.split(':')[1]?.split('-')[0] || symbol}
                            </span>
                          ))}
                          {Object.keys(historicalData).length > 5 && (
                            <span className="text-xs bg-blue-900/50 text-blue-300 px-2 py-1 rounded">
                              +{Object.keys(historicalData).length - 5} more
                            </span>
                          )}
                        </div>
                      ) : (
                        <span className="text-zinc-500 text-xs">No cached data</span>
                      )}
                    </div>
                  </div>
                </div>
                </div>


                {watchlistError && (
                  <div className="bg-red-50 border border-red-200 text-red-700 px-3 py-2 rounded-md text-sm">
                    ‚ùå {watchlistError}
                  </div>
                )}
              </div>
            </CardContent>
          </Card>


          <div className="min-h-screen bg-zinc-900 text-zinc-100 rounded-lg">
            <div className="container w-full p-4">
              <div className="grid grid-cols-1 lg:grid-cols-4 gap-6 mb-6">
                <div className="lg:col-span-3">
                  <div className="bg-zinc-800 p-4 rounded-lg shadow-lg h-[600px]">
                    {symbolHistory.length > 0 || symbolChartUpdates.length > 0 ? (
                      <PlotlyChart 
                        symbol={selectedSymbol} 
                        data={currentData} 
                        historicalData={symbolHistory}
                        ohlcData={symbolOhlc}
                        chartUpdates={symbolChartUpdates}
                        tradingHours={tradingHours}
                        updateFrequency={updateFrequency}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center">
                        <p className="text-zinc-400">
                          {selectedSymbol ? `Loading data for ${selectedSymbol}...` : 'Select a company'}
                        </p>
                      </div>
                    )}
                  </div>
                </div>


                <div className="bg-zinc-800 p-4 w-full rounded-lg shadow-lg">
                  {currentData ? (
                    <>
                      <div className="flex items-center justify-between mb-2">
                        <h2 className="text-xl font-semibold text-white">{selectedSymbol}</h2>
                        <div className="text-xs text-green-400 animate-pulse">
                          LIVE ‚Ä¢
                        </div>
                      </div>
                      <div className="text-3xl font-bold mb-2 text-white">‚Çπ{formatPrice(currentData.ltp)}</div>
                      <div className={`text-lg ${getChangeClass(currentData.change)}`}>
                        {formatChange(currentData.change, currentData.changePercent)}
                      </div>


                      {(() => {
                        const sentiment = getSentimentIndicator(gradientMode);
                        return (
                          <div className={`mt-3 p-3 rounded-lg border-2 ${sentiment.background} backdrop-blur-sm`}>
                            <div className="flex items-center gap-2">
                              <span className={`text-sm font-medium ${sentiment.text}`}>
                                {sentiment.label}
                              </span>
                            </div>
                          </div>
                        );
                      })()}


                      {/* ============ NEW: Usefulness Score Section ============ */}
                      <div className="mt-3">
                        {usefulnessScore === null ? (
                          <button
                            onClick={handleFetchUsefulnessScore}
                            className="w-full p-3 rounded-lg border-2 bg-gradient-to-r from-zinc-500/30 to-zinc-600/20 border-zinc-500/40 backdrop-blur-sm hover:from-zinc-500/40 hover:to-zinc-600/30 transition-all duration-200"
                          >
                            <div className="flex items-center justify-center gap-2">
                              <Award className="h-4 w-4 text-zinc-400" />
                              <span className="text-sm font-medium text-zinc-400">
                                Fetch Usefulness Score
                              </span>
                            </div>
                          </button>
                        ) : (
                          <div 
                            className="relative"
                            onMouseEnter={() => setShowScoreTooltip(true)}
                            onMouseLeave={() => setShowScoreTooltip(false)}
                          >
                            {(() => {
                              const scoreEval = getScoreEvaluation(usefulnessScore);
                              return (
                                <div className={`p-3 rounded-lg border-2 bg-gradient-to-r ${scoreEval.bgColor} ${scoreEval.borderColor} backdrop-blur-sm cursor-pointer`}>
                                  <div className="flex items-center justify-between">
                                    <div className="flex items-center gap-2">
                                      <Award className={`h-5 w-5 ${scoreEval.color}`} />
                                      <div>
                                        <div className="text-xs text-zinc-400">Usefulness Score</div>
                                        <div className={`text-2xl font-bold ${scoreEval.color}`}>
                                          {usefulnessScore}
                                        </div>
                                      </div>
                                    </div>
                                    <div className={`text-lg font-semibold ${scoreEval.color}`}>
                                      {scoreEval.text}
                                    </div>
                                  </div>
                                </div>
                              );
                            })()}
                            
                            {/* Tooltip with Formula */}
                            {showScoreTooltip && (
                              <div className="absolute z-50 w-80 p-4 mt-2 bg-zinc-900 border-2 border-zinc-700 rounded-lg shadow-2xl">
                                <div className="text-sm font-semibold text-zinc-300 mb-2">
                                  Mean Square Error (MSE) Formula:
                                </div>
                                <div className="bg-zinc-800 p-3 rounded border border-zinc-700">
                                  <div className="text-center font-mono text-zinc-200 text-base">
                                    <div className="mb-2">
                                      MSE = <span className="text-lg">1</span>/<sub>n</sub>
                                    </div>
                                    <div className="text-2xl mb-2">
                                      <span className="text-3xl">‚àë</span>
                                      <sup className="text-xs">n</sup>
                                      <sub className="text-xs">i=1</sub>
                                    </div>
                                    <div className="border-t border-zinc-600 pt-2">
                                      (Y<sub>i</sub> - ≈∂<sub>i</sub>)<sup>2</sup>
                                    </div>
                                  </div>
                                </div>
                                <div className="mt-3 text-xs text-zinc-400">
                                  <div><strong>Where:</strong></div>
                                  <div>‚Ä¢ n = number of data points</div>
                                  <div>‚Ä¢ Y<sub>i</sub> = actual value</div>
                                  <div>‚Ä¢ ≈∂<sub>i</sub> = predicted value</div>
                                </div>
                              </div>
                            )}
                          </div>
                        )}
                      </div>


                      <div className="grid grid-cols-2 gap-4 mt-6">
                        <div className="bg-zinc-700 p-3 rounded">
                          <div className="text-xs text-zinc-400">Open</div>
                          <div className="text-lg">‚Çπ{formatPrice(currentData.open)}</div>
                        </div>
                        <div className="bg-zinc-700 p-3 rounded">
                          <div className="text-xs text-zinc-400">Close</div>
                          <div className="text-lg">‚Çπ{formatPrice(currentData.close)}</div>
                        </div>
                        <div className="bg-zinc-700 p-3 rounded">
                          <div className="text-xs text-zinc-400">High</div>
                          <div className="text-lg">‚Çπ{formatPrice(currentData.high)}</div>
                        </div>
                        <div className="bg-zinc-700 p-3 rounded">
                          <div className="text-xs text-zinc-400">Low</div>
                          <div className="text-lg">‚Çπ{formatPrice(currentData.low)}</div>
                        </div>
                      </div>


                      <div className="mt-6 border-t border-zinc-700 pt-4">
                        <div className="grid grid-cols-2 gap-y-2">
                          <div>
                            <div className="text-xs text-zinc-400">Volume</div>
                            <div>{currentData.volume?.toLocaleString() || '0'}</div>
                          </div>
                          <div>
                            <div className="text-xs text-zinc-400">Updated</div>
                            <div className="text-green-400">
                              {new Date(currentData.timestamp * 1000).toLocaleTimeString()}
                            </div>
                          </div>
                        </div>
                      </div>


                      {(currentData.sma_20 || currentData.ema_9 || currentData.rsi_14) && (
                        <div className="mt-6 border-t border-zinc-700 pt-4">
                          <h3 className="text-sm font-medium mb-2 text-zinc-300">Technical Indicators</h3>
                          <div className="grid grid-cols-3 gap-2">
                            {currentData.sma_20 && (
                              <div className="bg-zinc-700 p-2 rounded">
                                <div className="text-xs text-orange-500">SMA 20</div>
                                <div className="text-sm">‚Çπ{formatPrice(currentData.sma_20)}</div>
                              </div>
                            )}
                            {currentData.ema_9 && (
                              <div className="bg-zinc-700 p-2 rounded">
                                <div className="text-xs text-purple-500">EMA 9</div>
                                <div className="text-sm">‚Çπ{formatPrice(currentData.ema_9)}</div>
                              </div>
                            )}
                            {currentData.rsi_14 && (
                              <div className="bg-zinc-700 p-2 rounded">
                                <div className="text-xs text-cyan-500">RSI 14</div>
                                <div className="text-sm">{currentData.rsi_14.toFixed(2)}</div>
                              </div>
                            )}
                          </div>
                        </div>
                      )}


                    </>
                  ) : (
                    <div className="text-center py-8">
                      <p className="text-zinc-400">
                        {selectedSymbol ? 'Connecting...' : 'Select a company'}
                      </p>
                    </div>
                  )}
                </div>
              </div>


              <div className="mb-8">
                <ImageCarousel
                  companyCode={selectedCompany || ''}
                  exchange={selectedExchange || ''}
                  gradientMode={gradientMode}
                  onGradientModeChange={setGradientMode}
                />
              </div>
            </div>
          </div>
        </div>
      </SidebarInset>
    </SidebarProvider>
  );
};


export default MarketDataPage;


================================================================================
FILE 2/37: apps/frontend/app/market-data/components/MarketChart.tsx
CATEGORY: Frontend - Chart Component
PURPOSE: Main chart visualization component
PRIORITY: ?? CRITICAL
================================================================================

'use client';
import React, { useEffect, useRef, useState } from 'react';
import { createChart, ColorType, ISeriesApi, UTCTimestamp, LineData } from 'lightweight-charts';
interface MarketData {
  ltp: number;
  timestamp: number;
}
interface MarketChartProps {
  symbol: string;
  data: MarketData | null | undefined;
}
const MarketChart: React.FC<MarketChartProps> = ({ symbol, data }) => {
  const chartContainerRef = useRef<HTMLDivElement>(null);
  const chartRef = useRef<ReturnType<typeof createChart> | null>(null);
  const seriesRef = useRef<ISeriesApi<'Line'> | null>(null);
  const [isChartInitialized, setIsChartInitialized] = useState(false);
  const dataPointsRef = useRef<LineData[]>([]);
  const [isClient, setIsClient] = useState(false);
  const [chartHeight] = useState(500);
  const [initializationAttempt, setInitializationAttempt] = useState(0);
  useEffect(() => {
    setIsClient(true);
    console.log('MarketChart component mounted');
  }, []);
  const createDummyData = () => {
    const now = Math.floor(Date.now() / 1000);
    const initialData: LineData[] = [];
    for (let i = 10; i > 0; i--) {
      initialData.push({
        time: (now - i * 60) as UTCTimestamp,
        value: data?.ltp || 100 + Math.random() * 10
      });
    }
    return initialData;
  };
  const initializeChart = () => {
    if (!chartContainerRef.current) {
      console.log('Chart container ref is not available');
      return false;
    }
    try {
      const initialData = createDummyData();
      dataPointsRef.current = initialData;
      const containerWidth = chartContainerRef.current.clientWidth;
      const containerHeight = chartContainerRef.current.clientHeight;
      console.log(`Container dimensions: ${containerWidth}x${containerHeight}`);
      if (containerWidth <= 0 || containerHeight <= 0) {
        console.log('Container has zero dimensions, will retry');
        return false;
      }
      chartRef.current = createChart(chartContainerRef.current, {
        width: containerWidth,
        height: chartHeight,
        layout: {
          background: { type: ColorType.Solid, color: 'white' },
          textColor: '#333',
          fontSize: 12,
        },
        grid: {
          vertLines: { color: '#f0f0f0' },
          horzLines: { color: '#f0f0f0' },
        },
        timeScale: {
          timeVisible: true,
          secondsVisible: true,
          minBarSpacing: 10,
          fixLeftEdge: true,
          fixRightEdge: true,
        },
        rightPriceScale: {
          scaleMargins: {
            top: 0.1,
            bottom: 0.1,
          },
          borderVisible: false,
        },
        crosshair: {
          mode: 1,
        },
        handleScroll: true,
        handleScale: true,
      });
      seriesRef.current = chartRef.current.addSeries({
        color: '#2962FF',
        lineWidth: 2,
        lastValueVisible: true,
        priceLineVisible: true,
        title: symbol,
      });
      seriesRef.current.setData(initialData);
      chartRef.current.timeScale().fitContent();
      setIsChartInitialized(true);
      console.log('Chart initialized successfully');
      return true;
    } catch (error) {
      console.error('Error initializing chart:', error);
      if (chartRef.current) {
        try {
          chartRef.current.remove();
        } catch (e) {
          console.error('Error removing chart during cleanup:', e);
        }
        chartRef.current = null;
        seriesRef.current = null;
      }
      return false;
    }
  };
  useEffect(() => {
    if (!isClient || !chartContainerRef.current || chartRef.current) return;
    const frameId = requestAnimationFrame(() => {
      setTimeout(() => {
        const success = initializeChart();
        if (!success && initializationAttempt < 5) {
          setInitializationAttempt(prev => prev + 1);
        }
      }, 300); 
    });
    return () => {
      cancelAnimationFrame(frameId);
    };
  }, [isClient, initializationAttempt]);
  useEffect(() => {
    if (!isClient) return;
    const handleResize = () => {
      if (chartRef.current && chartContainerRef.current) {
        const width = chartContainerRef.current.clientWidth;
        if (width > 0) {
          chartRef.current.resize(width, chartHeight);
          chartRef.current.timeScale().fitContent();
        }
      }
    };
    window.addEventListener('resize', handleResize);
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, [isClient, chartHeight]);
  useEffect(() => {
    return () => {
      if (chartRef.current) {
        try {
          chartRef.current.remove();
        } catch (e) {
          console.error('Error removing chart:', e);
        }
        chartRef.current = null;
        seriesRef.current = null;
        setIsChartInitialized(false);
      }
    };
  }, []);
  useEffect(() => {
    if (
      !isClient || 
      !isChartInitialized ||
      !seriesRef.current ||
      !data ||
      typeof data.ltp !== 'number' ||
      typeof data.timestamp !== 'number'
    ) {
      return;
    }
    try {
      const newTime = Math.floor(data.timestamp) as UTCTimestamp;
      const newValue = data.ltp;
      const existingIndex = dataPointsRef.current.findIndex(p => p.time === newTime);
      if (existingIndex >= 0) {
        dataPointsRef.current[existingIndex].value = newValue;
        const sortedData = [...dataPointsRef.current].sort((a, b) => 
          (a.time as number) - (b.time as number)
        );
        seriesRef.current.setData(sortedData);
      } else {
        const newPoint: LineData = { time: newTime, value: newValue };
        dataPointsRef.current.push(newPoint);
        dataPointsRef.current.sort((a, b) => (a.time as number) - (b.time as number));
        seriesRef.current.update(newPoint);
      }
      if (dataPointsRef.current.length > 300) {
        dataPointsRef.current = dataPointsRef.current.slice(-300);
      }
      if (chartRef.current) {
        chartRef.current.timeScale().scrollToRealTime();
      }
    } catch (error) {
      console.error('Error updating chart:', error);
      if (seriesRef.current && dataPointsRef.current.length > 0) {
        try {
          console.log('Attempting recovery by setting all data');
          const sortedData = [...dataPointsRef.current].sort((a, b) => 
            (a.time as number) - (b.time as number)
          );
          seriesRef.current.setData(sortedData);
        } catch (recoveryError) {
          console.error('Recovery failed:', recoveryError);
        }
      }
    }
  }, [data, isChartInitialized, isClient]);
  useEffect(() => {
    if (!isClient || !isChartInitialized || !seriesRef.current) return;
    console.log(`Symbol changed to ${symbol}. Resetting chart data.`);
    try {
      const initialData = createDummyData();
      dataPointsRef.current = initialData;
      seriesRef.current.setData(initialData);
      seriesRef.current.applyOptions({
        title: symbol
      });
      if (chartRef.current) {
        chartRef.current.timeScale().fitContent();
      }
    } catch (error) {
      console.error('Error resetting chart on symbol change:', error);
    }
  }, [symbol, isChartInitialized, isClient]);
  if (!isClient) {
    return (
      <div className="w-full h-[500px] bg-gray-100 flex items-center justify-center">
        <div className="text-gray-500">Loading chart...</div>
      </div>
    );
  }
  return (
    <div className="relative w-full h-[500px] border border-gray-200 rounded shadow-sm bg-white overflow-hidden">
      {}
      <div className="absolute top-2 left-2 z-10 text-sm font-medium text-gray-700">
        {symbol} Price Chart
      </div>
      {}
      <div 
        className="w-full h-full" 
        style={{ 
          width: '100%',
          height: '100%',
          minWidth: '300px',
          minHeight: '300px'
        }} 
        ref={chartContainerRef}
      />
      {}
      {!isChartInitialized && (
        <div className="absolute inset-0 bg-white bg-opacity-70 flex items-center justify-center">
          <div className="text-blue-500">
            {initializationAttempt > 0 
              ? `Initializing chart (attempt ${initializationAttempt}/5)...` 
              : 'Initializing chart...'}
          </div>
        </div>
      )}
    </div>
  );
};
export default MarketChart;



================================================================================
FILE 3/37: apps/frontend/app/market-data/components/SymbolSearch.tsx
CATEGORY: Frontend - Search Component
PURPOSE: Symbol search and selection component
PRIORITY: ?? CRITICAL
================================================================================

'use client';
import React, { useState } from 'react';
import { Input } from '../../../components/ui/input';
import { Button } from '../../../components/ui/button';
interface SymbolSearchProps {
  onSymbolSelect: (symbol: string) => void;
}
const commonSymbols = [
  { symbol: 'NSE:NIFTY50-INDEX', name: 'Nifty 50' },
  { symbol: 'NSE:BANKNIFTY-INDEX', name: 'Bank Nifty' },
  { symbol: 'NSE:RELIANCE-EQ', name: 'Reliance Industries' },
  { symbol: 'NSE:TCS-EQ', name: 'Tata Consultancy Services' },
  { symbol: 'NSE:INFY-EQ', name: 'Infosys' },
  { symbol: 'NSE:HDFCBANK-EQ', name: 'HDFC Bank' },
  { symbol: 'NSE:ICICIBANK-EQ', name: 'ICICI Bank' },
  { symbol: 'NSE:HINDUNILVR-EQ', name: 'Hindustan Unilever' },
  { symbol: 'NSE:ITC-EQ', name: 'ITC' },
  { symbol: 'NSE:SBIN-EQ', name: 'State Bank of India' },
];
const SymbolSearch: React.FC<SymbolSearchProps> = ({ onSymbolSelect }) => {
  const [searchTerm, setSearchTerm] = useState('');
  const [showDropdown, setShowDropdown] = useState(false);
  const [customSymbol, setCustomSymbol] = useState('');
  const filteredSymbols = searchTerm
    ? commonSymbols.filter(
        (item) =>
          item.symbol.toLowerCase().includes(searchTerm.toLowerCase()) ||
          item.name.toLowerCase().includes(searchTerm.toLowerCase())
      )
    : commonSymbols;
  const handleSymbolSelect = (symbol: string) => {
    onSymbolSelect(symbol);
    setSearchTerm('');
    setShowDropdown(false);
  };
  const handleCustomSymbolSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (customSymbol) {
      onSymbolSelect(customSymbol);
      setCustomSymbol('');
    }
  };
  return (
    <div className="relative">
      <div className="flex">
        <Input
          type="text"
          placeholder="Search symbol..."
          value={searchTerm}
          onChange={(e) => {
            setSearchTerm(e.target.value);
            setShowDropdown(true);
          }}
          onFocus={() => setShowDropdown(true)}
          className="w-64"
        />
      </div>
      {showDropdown && (
        <div className="absolute z-10 mt-1 w-full bg-popover rounded-md shadow-lg">
          <ul className="py-1 max-h-60 overflow-auto">
            {filteredSymbols.map((item) => (
              <li
                key={item.symbol}
                className="px-4 py-2 hover:bg-muted cursor-pointer"
                onClick={() => handleSymbolSelect(item.symbol)}
              >
                <div className="font-medium">{item.name}</div>
                <div className="text-sm text-muted-foreground">{item.symbol}</div>
              </li>
            ))}
            {filteredSymbols.length === 0 && (
              <li className="px-4 py-2 text-muted-foreground">
                No results found. Try adding a custom symbol.
              </li>
            )}
          </ul>
          <div className="border-t p-2">
            <form onSubmit={handleCustomSymbolSubmit} className="flex gap-2">
              <Input
                type="text"
                placeholder="Add custom symbol (e.g., NSE:SYMBOL-EQ)"
                value={customSymbol}
                onChange={(e) => setCustomSymbol(e.target.value)}
                className="flex-1"
              />
              <Button type="submit" size="sm">Add</Button>
            </form>
          </div>
        </div>
      )}
    </div>
  );
};
export default SymbolSearch;



================================================================================
FILE 4/37: apps/frontend/hooks/useMarketData.ts
CATEGORY: Frontend - Custom Hook
PURPOSE: Market data state management hook
PRIORITY: ?? CRITICAL
================================================================================

import { useState, useEffect, useCallback, useRef } from 'react';
import { getSocket } from '../lib/socket';

interface MarketData {
  ltp: number;
  change: number;
  changePercent: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
  timestamp: number;
  sma_20?: number;
  ema_9?: number;
  rsi_14?: number;
}

interface ChartUpdate {
  symbol: string;
  price: number;
  timestamp: number;
  volume: number;
  change: number;
  changePercent: number;
}

interface UseMarketDataReturn {
  data: Record<string, MarketData>;
  isLoading: boolean;
  error: Error | null;
  subscribeToSymbol: (symbol: string) => void;
  unsubscribeFromSymbol: (symbol: string) => void;
  chartUpdates: Record<string, ChartUpdate[]>;
  lastUpdate: Date | null;
  activeSymbols: string[];
  cachedSymbols: string[];
  backgroundDataPoints: number;
}

// ============ FIXED: Stable constants ============
const STORAGE_KEY = 'market_data_cache_v2';
const CHART_STORAGE_KEY = 'chart_updates_cache_v2';
const MAX_CACHE_AGE = 24 * 60 * 60 * 1000; // 24 hours
const MAX_POINTS_PER_SYMBOL = 10000;

// ============ FIXED: Stable storage helpers ============
const saveToStorage = (key: string, data: any) => {
  try {
    const serializedData = JSON.stringify({
      timestamp: Date.now(),
      data: data
    });
    localStorage.setItem(key, serializedData);
  } catch (error) {
    console.warn('Failed to save to localStorage:', error);
  }
};

const loadFromStorage = (key: string) => {
  try {
    const stored = localStorage.getItem(key);
    if (!stored) return null;

    const parsed = JSON.parse(stored);
    const age = Date.now() - parsed.timestamp;

    if (age < MAX_CACHE_AGE) {
      return parsed.data;
    } else {
      localStorage.removeItem(key);
      return null;
    }
  } catch (error) {
    console.warn('Failed to load from localStorage:', error);
    return null;
  }
};

export const useMarketData = (initialSymbols: string[] = []): UseMarketDataReturn => {
  // ============ FIXED: Stable state initialization ============
  const [data, setData] = useState<Record<string, MarketData>>(() => {
    if (typeof window !== 'undefined') {
      return loadFromStorage(STORAGE_KEY) || {};
    }
    return {};
  });

  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<Error | null>(null);

  const [chartUpdates, setChartUpdates] = useState<Record<string, ChartUpdate[]>>(() => {
    if (typeof window !== 'undefined') {
      return loadFromStorage(CHART_STORAGE_KEY) || {};
    }
    return {};
  });

  const [lastUpdate, setLastUpdate] = useState<Date | null>(null);
  const [subscribedSymbols, setSubscribedSymbols] = useState<Set<string>>(() => 
    new Set(initialSymbols)
  );

  // ============ FIXED: Stable background tracking ============
  const [activeSymbols, setActiveSymbols] = useState<string[]>([]);
  const [cachedSymbols, setCachedSymbols] = useState<string[]>([]);
  const [backgroundDataPoints, setBackgroundDataPoints] = useState<number>(0);

  // ============ FIXED: Stable refs ============
  const socketRef = useRef<any>(null);
  const saveTimeoutRef = useRef<NodeJS.Timeout>();
  const isInitializedRef = useRef(false);

  // ============ FIXED: Stable data saving with debouncing ============
  useEffect(() => {
    if (!isInitializedRef.current) {
      isInitializedRef.current = true;
      return;
    }

    // Clear existing timeout
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
    }

    // Debounce saves to prevent excessive localStorage writes
    saveTimeoutRef.current = setTimeout(() => {
      if (Object.keys(data).length > 0) {
        saveToStorage(STORAGE_KEY, data);
      }
      if (Object.keys(chartUpdates).length > 0) {
        saveToStorage(CHART_STORAGE_KEY, chartUpdates);
      }
    }, 5000); // Save after 5 seconds of inactivity

    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, [data, chartUpdates]);

  // ============ FIXED: Stable subscription functions ============
  const subscribeToSymbol = useCallback((symbol: string) => {
    setSubscribedSymbols((prev) => {
      if (prev.has(symbol)) return prev; // Prevent unnecessary updates
      const newSet = new Set(prev);
      newSet.add(symbol);
      return newSet;
    });

    if (socketRef.current) {
      socketRef.current.emit('subscribe', { symbol }, (response: any) => {
        if (response && response.success) {
          console.log(`‚úÖ Subscribed to ${symbol}. Cached: ${response.cached_points || 0}`);
        }
      });
    }
  }, []);

  const unsubscribeFromSymbol = useCallback((symbol: string) => {
    setSubscribedSymbols((prev) => {
      if (!prev.has(symbol)) return prev; // Prevent unnecessary updates
      const newSet = new Set(prev);
      newSet.delete(symbol);
      return newSet;
    });

    if (socketRef.current) {
      socketRef.current.emit('unsubscribe', { symbol });
    }

    console.log(`Unsubscribed from ${symbol} (data preserved)`);
  }, []);

  // ============ FIXED: Stable socket initialization ============
  useEffect(() => {
    if (typeof window === 'undefined') return;

    const socket = getSocket();
    socketRef.current = socket;

    // ============ FIXED: Stable event handlers ============
    const handleMarketDataUpdate = (marketData: MarketData) => {
      if (!marketData || !marketData.symbol) return;

      setData((prev) => {
        // Prevent unnecessary updates if data is the same
        const existing = prev[marketData.symbol];
        if (existing && existing.timestamp === marketData.timestamp && existing.ltp === marketData.ltp) {
          return prev;
        }

        return {
          ...prev,
          [marketData.symbol]: marketData,
        };
      });

      setLastUpdate(new Date());
      setIsLoading(false);
    };

    const handleChartUpdate = (update: ChartUpdate) => {
      if (!update || !update.symbol) return;

      setChartUpdates((prev) => {
        const symbolUpdates = prev[update.symbol] || [];

        // Check for duplicate timestamps
        if (symbolUpdates.length > 0) {
          const lastUpdate = symbolUpdates[symbolUpdates.length - 1];
          if (lastUpdate.timestamp === update.timestamp && lastUpdate.price === update.price) {
            return prev; // Skip duplicate
          }
        }

        const newUpdates = [...symbolUpdates, update].slice(-MAX_POINTS_PER_SYMBOL);

        return {
          ...prev,
          [update.symbol]: newUpdates
        };
      });

      setLastUpdate(new Date());
    };

    const handleHistoricalData = (message: { symbol: string; data: MarketData[] }) => {
      if (!message || !message.symbol || !Array.isArray(message.data) || message.data.length === 0) return;

      console.log(`üìà Received ${message.data.length} historical points for ${message.symbol}`);

      const latestData = message.data[message.data.length - 1];
      setData((prev) => ({
        ...prev,
        [message.symbol]: latestData,
      }));

      const chartData = message.data.map((item) => ({
        symbol: message.symbol,
        price: item.ltp,
        timestamp: item.timestamp,
        volume: item.volume || 0,
        change: item.change || 0,
        changePercent: item.changePercent || 0
      }));

      setChartUpdates((prev) => ({
        ...prev,
        [message.symbol]: chartData
      }));

      setIsLoading(false);
    };

    const handleChartUpdatesHistory = (message: { symbol: string; data: ChartUpdate[] }) => {
      if (!message || !message.symbol || !Array.isArray(message.data) || message.data.length === 0) return;

      console.log(`üîÑ Received ${message.data.length} cached updates for ${message.symbol}`);

      setChartUpdates((prev) => ({
        ...prev,
        [message.symbol]: message.data
      }));
    };

    const handleHeartbeat = (heartbeat: any) => {
      if (!heartbeat) return;

      if (Array.isArray(heartbeat.active_symbols)) {
        setActiveSymbols(heartbeat.active_symbols);
      }
      if (typeof heartbeat.total_cached_points === 'number') {
        setBackgroundDataPoints(heartbeat.total_cached_points);
      }
    };

    const handleConnect = () => {
      console.log('‚úÖ Socket connected for fixed market data');
      setError(null);
    };

    const handleDisconnect = () => {
      console.log('‚ùå Socket disconnected');
      setError(new Error('Connection lost'));
    };

    const handleError = (err: any) => {
      console.error('‚ùå Socket error:', err);
      setError(new Error(err.message || 'Socket error'));
    };

    // ============ FIXED: Register event listeners ONCE ============
    socket.on('connect', handleConnect);
    socket.on('disconnect', handleDisconnect);
    socket.on('error', handleError);
    socket.on('marketDataUpdate', handleMarketDataUpdate);
    socket.on('chartUpdate', handleChartUpdate);
    socket.on('historicalData', handleHistoricalData);
    socket.on('chartUpdatesHistory', handleChartUpdatesHistory);
    socket.on('heartbeat', handleHeartbeat);

    // Subscribe to initial symbols once
    initialSymbols.forEach((symbol) => {
      socket.emit('subscribe', { symbol });
    });

    // ============ FIXED: Cleanup function ============
    return () => {
      socket.off('connect', handleConnect);
      socket.off('disconnect', handleDisconnect);
      socket.off('error', handleError);
      socket.off('marketDataUpdate', handleMarketDataUpdate);
      socket.off('chartUpdate', handleChartUpdate);
      socket.off('historicalData', handleHistoricalData);
      socket.off('chartUpdatesHistory', handleChartUpdatesHistory);
      socket.off('heartbeat', handleHeartbeat);

      // Unsubscribe from all symbols
      subscribedSymbols.forEach((symbol) => {
        socket.emit('unsubscribe', { symbol });
      });
    };
  }, []); // ‚úÖ FIXED: Empty dependency array - initialize once

  // ============ FIXED: Stable cleanup with proper dependencies ============
  useEffect(() => {
    const cleanupInterval = setInterval(() => {
      const cutoffTime = Date.now() - MAX_CACHE_AGE;

      setChartUpdates((prev) => {
        const cleaned: Record<string, ChartUpdate[]> = {};
        let hasChanges = false;

        Object.entries(prev).forEach(([symbol, updates]) => {
          const recentUpdates = updates.filter(
            update => (update.timestamp * 1000) > cutoffTime
          );

          if (recentUpdates.length > 0) {
            cleaned[symbol] = recentUpdates;
          }

          if (recentUpdates.length !== updates.length) {
            hasChanges = true;
          }
        });

        return hasChanges ? cleaned : prev;
      });

      setData((prev) => {
        const cleaned: Record<string, MarketData> = {};
        let hasChanges = false;

        Object.entries(prev).forEach(([symbol, marketData]) => {
          if ((marketData.timestamp * 1000) > cutoffTime) {
            cleaned[symbol] = marketData;
          } else {
            hasChanges = true;
          }
        });

        return hasChanges ? cleaned : prev;
      });

    }, 3600000); // Cleanup every hour

    return () => clearInterval(cleanupInterval);
  }, []); // ‚úÖ FIXED: Empty dependency array

  // ============ FIXED: Update cached symbols list ============
  useEffect(() => {
    setCachedSymbols(Object.keys(data));
  }, [data]);

  return {
    data,
    isLoading,
    error,
    subscribeToSymbol,
    unsubscribeFromSymbol,
    chartUpdates,
    lastUpdate,
    activeSymbols,
    cachedSymbols,
    backgroundDataPoints
  };
};


================================================================================
FILE 5/37: apps/frontend/lib/socket.ts
CATEGORY: Frontend - WebSocket Client
PURPOSE: Socket.IO client setup and configuration
PRIORITY: ?? CRITICAL
================================================================================


import { io, Socket } from 'socket.io-client';
let socket: Socket | null = null;
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;
export const getSocket = (): Socket => {
  if (!socket) {
    const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL || 'http://localhost:5001';
    console.log(`Connecting to WebSocket server at ${SOCKET_URL}`);
    socket = io(SOCKET_URL, {
      reconnectionAttempts: MAX_RECONNECT_ATTEMPTS,
      reconnectionDelay: 1000,
      timeout: 10000,
      transports: ['websocket', 'polling']
    });
    socket.on('connect', () => {
      console.log(`Connected to WebSocket server with ID: ${socket?.id}`);
      reconnectAttempts = 0;
    });
    socket.on('connect_error', (error) => {
      console.error('Socket connection error:', error.message);
      reconnectAttempts++;
    });
    socket.on('disconnect', (reason) => {
      console.log(`Disconnected from WebSocket server. Reason: ${reason}`);
    });
    socket.on('error', (error) => {
      console.error('Socket error:', error);
    });
    socket.on('heartbeat', (data) => {
      console.log('Heartbeat received:', data);
    });
  }
  return socket;
};
export const disconnectSocket = (): void => {
  if (socket) {
    console.log('Manually disconnecting socket');
    socket.disconnect();
    socket = null;
  }
};



================================================================================
FILE 6/37: apps/frontend/lib/utils.ts
CATEGORY: Frontend - Utilities
PURPOSE: Utility functions and helpers
PRIORITY: ?? CRITICAL
================================================================================

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


================================================================================
FILE 7/37: apps/frontend/app/globals.css
CATEGORY: Frontend - Styles
PURPOSE: Global CSS styles and theme variables
PRIORITY: ?? CRITICAL
================================================================================

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --sidebar-background: 0 0% 98%;
    --sidebar-foreground: 240 5.3% 26.1%;
    --sidebar-primary: 240 5.9% 10%;
    --sidebar-primary-foreground: 0 0% 98%;
    --sidebar-accent: 240 4.8% 95.9%;
    --sidebar-accent-foreground: 240 5.9% 10%;
    --sidebar-border: 220 13% 91%;
    --sidebar-ring: 217.2 91.2% 59.8%;
    
    /* Add missing color variables */
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --radius: 0.5rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
  }
  
  .dark {
    --sidebar-background: 240 5.9% 10%;
    --sidebar-foreground: 240 4.8% 95.9%;
    --sidebar-primary: 224.3 76.3% 48%;
    --sidebar-primary-foreground: 0 0% 100%;
    --sidebar-accent: 240 3.7% 15.9%;
    --sidebar-accent-foreground: 240 4.8% 95.9%;
    --sidebar-border: 240 3.7% 15.9%;
    --sidebar-ring: 217.2 91.2% 59.8%;
    
    /* Dark mode colors */
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}


================================================================================
FILE 8/37: apps/frontend/next.config.ts
CATEGORY: Frontend - Configuration
PURPOSE: Next.js framework configuration
PRIORITY: ?? CRITICAL
================================================================================

/** @type {import('next').NextConfig} */
const nextConfig = {
  transpilePackages: ['lightweight-charts'],
  
  // Disable error overlay temporarily
  reactStrictMode: true,
  
  async rewrites() {
    return [
      {
        source: '/api/:path*',
        destination: 'http://localhost:5000/api/:path*', // Adjust to your NestJS port
      },
    ];
  },

  // Hide error overlays in development
  onError: (err) => {
    // Suppress errors from showing in overlay
    console.error('Suppressed error:', err);
  },

  // For Next.js 13+ - disable error overlay
  experimental: {
    errorOverlay: false,
  },

  // Additional option to reduce noise
  compiler: {
    removeConsole: false, // Set to true if you want to remove console.logs in production
  },
};

module.exports = nextConfig;

################################################################################
?? SECTION 2: CRITICAL FILES - BACKEND FILES
################################################################################

================================================================================
FILE 9/37: apps/backend/src/market-data/market-data.controller.ts
CATEGORY: Backend - REST Controller
PURPOSE: Market data REST API endpoints
PRIORITY: ?? CRITICAL
================================================================================

import { Controller, Get, Param, Query } from '@nestjs/common';
import { MarketDataService } from './market-data.service';

@Controller('market-data')
export class MarketDataController {
  constructor(private readonly marketDataService: MarketDataService) {}

  @Get(':symbol')
  getMarketData(@Param('symbol') symbol: string) {
    return this.marketDataService.getMarketData(symbol);
  }

  /*
  @Get('status')
  getMarketStatus() {
    return this.marketDataService.getMarketStatus();
  }

  @Get('quotes')
  getQuotes(@Query('symbols') symbols: string) {
    const symbolArray = symbols.split(',');
    return this.marketDataService.getQuotes(symbolArray);
  }

  @Get('history/:symbol')
  getHistoricalData(
    @Param('symbol') symbol: string,
    @Query('resolution') resolution: string,
    @Query('from') from: string,
    @Query('to') to: string,
  ) {
    return this.marketDataService.getHistoricalData(symbol, resolution, from, to);
  }

  @Get('depth/:symbol')
  getMarketDepth(@Param('symbol') symbol: string) {
    return this.marketDataService.getMarketDepth(symbol);
  }

  @Get('option-chain/:symbol')
  getOptionChain(@Param('symbol') symbol: string) {
    return this.marketDataService.getOptionChain(symbol);
  }
  */
}


================================================================================
FILE 10/37: apps/backend/src/market-data/market-data.service.ts
CATEGORY: Backend - Service Layer
PURPOSE: Market data business logic and data processing
PRIORITY: ?? CRITICAL
================================================================================


import { Injectable, Logger } from '@nestjs/common';

@Injectable()
export class MarketDataService {
  private readonly logger = new Logger(MarketDataService.name);
  private marketData = new Map<string, any>();

  getAccessToken(): string {
    const token = process.env.FYERS_ACCESS_TOKEN;
    if (!token) {
      this.logger.error('FYERS_ACCESS_TOKEN is not defined in environment');
      throw new Error('Missing Fyers access token');
    }
    return token;
  }

  updateMarketData(symbol: string, data: any) {
    this.marketData.set(symbol, data);
    this.logger.debug(`Updated market data for ${symbol}`);
  }

  getMarketData(symbol: string) {
    return this.marketData.get(symbol) || null;
  }

  isMarketCurrentlyOpen(): boolean {
    const today = new Date().getDay();
    if (today === 0 || today === 6) {
      this.logger.warn('Today is a weekend. Markets are closed.');
      return false;
    }
    
    const now = new Date();
    const hours = now.getHours();
    const minutes = now.getMinutes();
    const currentTime = hours * 100 + minutes;
    
    if (currentTime < 915 || currentTime > 1530) {
      this.logger.warn('Outside market hours (9:15 AM - 3:30 PM IST). Real-time data may not be available.');
      return false;
    }
    
    return true;
  }
}


================================================================================
FILE 11/37: apps/backend/src/market-data/market-data.module.ts
CATEGORY: Backend - Module Configuration
PURPOSE: Market data module dependency injection
PRIORITY: ?? CRITICAL
================================================================================

// // import { Module } from '@nestjs/common';
// // import { MarketDataController } from './market-data.controller';
// // import { MarketDataService } from './market-data.service';
// // import { MarketDataGateway } from './websocket/market-data.gateway';
// // import { PythonBridgeGateway } from './websocket/python-bridge.gateway';

// // @Module({
// //   controllers: [MarketDataController],
// //   providers: [
// //     MarketDataService,
// //     MarketDataGateway,
// //     PythonBridgeGateway
// //   ],
// //   exports: [MarketDataService],
// // })
// // export class MarketDataModule {}

// import { Module } from '@nestjs/common';
// import { MarketDataController } from './market-data.controller';
// import { MarketDataService } from './market-data.service';
// import { MarketDataGateway } from './websocket/market-data.gateway';
// import { PythonBridgeGateway } from './websocket/python-bridge.gateway';

// @Module({
//   controllers: [MarketDataController],
//   providers: [
//     MarketDataService,
//     MarketDataGateway,
//     PythonBridgeGateway
//   ],
//   exports: [MarketDataService],
// })
// export class MarketDataModule {}


================================================================================
FILE 12/37: apps/backend/src/market-data/dto/market-data.dto.ts
CATEGORY: Backend - Data Transfer Objects
PURPOSE: Request/response data structures
PRIORITY: ?? CRITICAL
================================================================================

export class MarketDataDto {
    symbol: string;
    ltp: number;
    change: number;
    changePercent: number;
    open: number;
    high: number;
    low: number;
    close: number;
    volume: number;
    timestamp: number;
  }
  
  export class HistoricalDataRequestDto {
    symbol: string;
    resolution: string;
    from: string;
    to: string;
  }
  
  export class SubscriptionDto {
    symbol: string;
  }
  

================================================================================
FILE 13/37: apps/backend/src/market-data/websocket/market-data.gateway.ts
CATEGORY: Backend - WebSocket Gateway
PURPOSE: Real-time data streaming via WebSocket
PRIORITY: ?? CRITICAL
================================================================================

// // import {
// //   WebSocketGateway,
// //   WebSocketServer,
// //   SubscribeMessage,
// //   ConnectedSocket,
// //   MessageBody,
// // } from '@nestjs/websockets';
// // import { Server, Socket } from 'socket.io';
// // import { Logger } from '@nestjs/common';
// // import { MarketDataService } from '../market-data.service';
// // import { SubscriptionDto } from '../dto/market-data.dto';
// // import { io } from 'socket.io-client';

// // @WebSocketGateway({
// //   cors: {
// //     origin: '*',
// //   },
// // })
// // export class MarketDataGateway {
// //   @WebSocketServer()
// //   server: Server;
  
// //   private readonly logger = new Logger(MarketDataGateway.name);
// //   private clients = new Map<string, Socket>();
// //   private pythonClient: any;
// //   private symbolToClients = new Map<string, Set<string>>();
  
// //   constructor(private readonly marketDataService: MarketDataService) {
// //     // Connect to the Python bridge
// //     this.pythonClient = io('http://localhost:5001');
    
// //     this.pythonClient.on('connect', () => {
// //       this.logger.log('Connected to Python bridge');
// //     });
    
// //     this.pythonClient.on('disconnect', () => {
// //       this.logger.log('Disconnected from Python bridge');
// //     });
    
// //     this.pythonClient.on('marketData', (data) => {
// //       // Forward the exact data to all connected clients
// //       this.clients.forEach(client => {
// //         if (this.symbolToClients.get(data.symbol)?.has(client.id)) {
// //           client.emit('marketData', data);
// //         }
// //       });
      
// //       // Log the data for debugging
// //       console.log("Response:", data);
// //     });
    
// //   }

// //   handleConnection(client: Socket) {
// //     this.logger.log(`Client connected: ${client.id}`);
// //     this.clients.set(client.id, client);
// //   }

// //   handleDisconnect(client: Socket) {
// //     this.logger.log(`Client disconnected: ${client.id}`);
// //     this.clients.delete(client.id);
// //   }

// //   @SubscribeMessage('subscribe')
// //   handleSubscribe(
// //     @ConnectedSocket() client: Socket,
// //     @MessageBody() data: SubscriptionDto
// //   ) {
// //     const symbol = data.symbol;
// //     this.logger.log(`Client ${client.id} subscribing to ${symbol}`);
    
// //     // Forward subscription to Python bridge
// //     this.pythonClient.emit('subscribe', { symbol });
    
// //     // Send current data if available
// //     const currentData = this.marketDataService.getMarketData(symbol);
// //     if (currentData) {
// //       client.emit('marketData', { symbol, data: currentData });
// //     }
    
// //     return { success: true, symbol };
// //   }

// //   @SubscribeMessage('unsubscribe')
// //   handleUnsubscribe(
// //     @ConnectedSocket() client: Socket,
// //     @MessageBody() data: SubscriptionDto
// //   ) {
// //     const symbol = data.symbol;
// //     this.logger.log(`Client ${client.id} unsubscribing from ${symbol}`);
    
// //     // Forward unsubscription to Python bridge
// //     this.pythonClient.emit('unsubscribe', { symbol });
    
// //     return { success: true, symbol };
// //   }
// // }


// import {
//   WebSocketGateway,
//   WebSocketServer,
//   SubscribeMessage,
//   ConnectedSocket,
//   MessageBody,
// } from '@nestjs/websockets';
// import { Server, Socket } from 'socket.io';
// import { Logger } from '@nestjs/common';
// import { MarketDataService } from '../market-data.service';
// import { SubscriptionDto } from '../dto/market-data.dto';
// import { io } from 'socket.io-client';

// @WebSocketGateway({
//   cors: {
//     origin: '*',
//   },
// })
// export class MarketDataGateway {
//   @WebSocketServer()
//   server: Server;
  
//   private readonly logger = new Logger(MarketDataGateway.name);
//   private clients = new Map<string, Socket>();
//   private pythonClient: any;
//   private symbolToClients = new Map<string, Set<string>>();
  
//   constructor(private readonly marketDataService: MarketDataService) {
//     // Connect to the Python bridge
//     this.pythonClient = io('http://localhost:5001');
    
//     this.pythonClient.on('connect', () => {
//       this.logger.log('Connected to Python bridge');
//     });
    
//     this.pythonClient.on('disconnect', () => {
//       this.logger.log('Disconnected from Python bridge');
//     });
    
//     this.pythonClient.on('marketData', (data) => {
//       // Log the raw data received from Python bridge
//       this.logger.log(`Market data received from Python: ${JSON.stringify(data)}`);
      
//       // Store the data in the service
//       if (data && data.symbol) {
//         this.marketDataService.updateMarketData(data.symbol, data);
        
//         // Forward to all connected clients
//         this.clients.forEach(client => {
//           client.emit('marketData', data);
//         });
//       }
//     });
//   }

//   handleConnection(client: Socket) {
//     this.logger.log(`Client connected: ${client.id}`);
//     this.clients.set(client.id, client);
    
//     // Initialize empty set for this client's subscriptions
//     this.symbolToClients.set(client.id, new Set<string>());
//   }

//   handleDisconnect(client: Socket) {
//     this.logger.log(`Client disconnected: ${client.id}`);
//     // Clean up subscriptions
//     this.symbolToClients.delete(client.id);
//     this.clients.delete(client.id);
//   }

//   @SubscribeMessage('subscribe')
//   handleSubscribe(
//     @ConnectedSocket() client: Socket,
//     @MessageBody() data: SubscriptionDto
//   ) {
//     const symbol = data.symbol;
//     this.logger.log(`Client ${client.id} subscribing to ${symbol}`);
    
//     // Add to client's subscriptions
//     const clientSymbols = this.symbolToClients.get(client.id);
//     if (clientSymbols) {
//       clientSymbols.add(symbol);
//     } else {
//       this.symbolToClients.set(client.id, new Set([symbol]));
//     }
    
//     // Forward subscription to Python bridge
//     this.pythonClient.emit('subscribe', { symbols: [symbol] });
    
//     // Send current data if available
//     const currentData = this.marketDataService.getMarketData(symbol);
//     if (currentData) {
//       client.emit('marketData', currentData);
//     }
    
//     return { success: true, symbol };
//   }

//   @SubscribeMessage('unsubscribe')
//   handleUnsubscribe(
//     @ConnectedSocket() client: Socket,
//     @MessageBody() data: SubscriptionDto
//   ) {
//     const symbol = data.symbol;
//     this.logger.log(`Client ${client.id} unsubscribing from ${symbol}`);
    
//     // Remove from client's subscriptions
//     const clientSymbols = this.symbolToClients.get(client.id);
//     if (clientSymbols) {
//       clientSymbols.delete(symbol);
//     }
    
//     // Forward unsubscription to Python bridge
//     this.pythonClient.emit('unsubscribe', { symbols: [symbol] });
    
//     return { success: true, symbol };
//   }
// }


################################################################################
?? SECTION 3: CRITICAL FILES - CONFIGURATION FILES
################################################################################

================================================================================
FILE 14/37: apps/frontend/.env
CATEGORY: Configuration - Environment Variables
PURPOSE: Frontend environment configuration
PRIORITY: ?? CRITICAL
NOTE: Contains sensitive data - handle with care
================================================================================

REACT_APP_BACKEND_URL=http://localhost:5000

================================================================================
FILE 15/37: apps/backend/.env
CATEGORY: Configuration - Environment Variables
PURPOSE: Backend environment configuration
PRIORITY: ?? CRITICAL
NOTE: Contains sensitive data - handle with care
================================================================================

# # DB_HOST=100.93.172.21
# # DB_PORT=5432
# # DB_USERNAME=temp_raghav
# # DB_PASSWORD=password
# # DB_DATABASE=temp_db

# DB_HOST=100.93.172.21
# DB_PORT=5432
# DB_USERNAME=readonly_user
# DB_PASSWORD=db_read_5432
# DB_DATABASE=nse_hist_db






# FYERS_CLIENT_ID=150HUKJSWG-100


# FYERS_SECRET_ID=18YYNXCAS7
# # FYERS_REDIRECT_URI=https://daksphere.com/
# FYERS_REDIRECT_URI=https://raghavjaiswal709.github.io/DAKSphere_redirect/
# FYERS_ACCESS_TOKEN=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsiZDoxIiwiZDoyIiwieDowIiwieDoxIiwieDoyIl0sImF0X2hhc2giOiJnQUFBQUFCb0Z1eVBBNl9GQzdtcUVIRXNKMWhPUWdUSjBYTC1aMG9jN2hiR1hTNXp2cUFjVXNFUmRxeHNwdE15di1NRUU5YXZrUHBoTFN1MEpDRkt5T20xZzVDNmY5OGVXaGNhOVhMM243aTM4VElpS3RXT3pvYz0iLCJkaXNwbGF5X25hbWUiOiIiLCJvbXMiOiJLMSIsImhzbV9rZXkiOiIzNGQ2OTFmZmUyZjIzMjZjYTU3OWQ3ODljMGM2ZWVmYmVmOWQ2YTM3NzU5YjdmMmUzOGRjODhjZiIsImlzRGRwaUVuYWJsZWQiOiJOIiwiaXNNdGZFbmFibGVkIjoiTiIsImZ5X2lkIjoiRkFBMjQwNjciLCJhcHBUeXBlIjoxMDAsImV4cCI6MTc0NjQwNTAwMCwiaWF0IjoxNzQ2MzMyODE1LCJpc3MiOiJhcGkuZnllcnMuaW4iLCJuYmYiOjE3NDYzMzI4MTUsInN1YiI6ImFjY2Vzc190b2tlbiJ9.SZjiDs0riKHumlyYK4SphhQWzvS5hj1QgPCslWhXuU8
# PORT=5000


# Company Historical Database Connection (Primary)
# DB_HOST=localhost
# DB_PORT=5432
# DB_USERNAME=your_user
# DB_PASSWORD=your_password
# DB_DATABASE=company_hist_db

DB_HOST=100.93.172.21
DB_PORT=5432
DB_USERNAME=readonly_user
DB_PASSWORD=db_read_5432
DB_DATABASE=nse_hist_db

# Fyers API Configuration
FYERS_CLIENT_ID=150HUKJSWG-100
FYERS_SECRET_ID=18YYNXCAS7
FYERS_REDIRECT_URI=https://raghavjaiswal709.github.io/DAKSphere_redirect/
FYERS_ACCESS_TOKEN=your_access_token

# SIPR Pattern Analysis API
SIPR_API_URL=http://100.93.172.21:8510

# Server Port
PORT=5000

# Environment
NODE_ENV=development


================================================================================
FILE 16/37: apps/backend/src/config/fyers.config.ts
CATEGORY: Configuration - API Configuration
PURPOSE: Fyers API integration configuration
PRIORITY: ?? CRITICAL
================================================================================

export const fyersConfig = {
    clientId: process.env.FYERS_CLIENT_ID || '',
    secretId: process.env.FYERS_SECRET_ID || '',
    redirectUri: process.env.FYERS_REDIRECT_URI || 'http://127.0.0.1:5000',
    responseType: 'code',
    state: 'fyers',
    grantType: 'authorization_code',
  };
  

################################################################################
?? SECTION 4: IMPORTANT FILES - CHART COMPONENTS
################################################################################

================================================================================
FILE 17/37: apps/frontend/app/market-data/components/charts/PlotlyChart.tsx
CATEGORY: Charts - Plotly Integration
PURPOSE: Plotly.js chart component implementation
PRIORITY: ?? IMPORTANT
================================================================================

'use client';
import React, { useState, useEffect, useRef } from 'react';
import Plot from 'react-plotly.js';
import { ChevronRight, TrendingUp, BarChart3, LineChart, CandlestickChart, ArrowLeftRight, ShoppingCart, TrendingDown } from 'lucide-react';

// Add Plotly import for restyle operations
declare const Plotly: any;

interface DataPoint {
  ltp: number;
  timestamp: number;
  open?: number;
  high?: number;
  low?: number;
  close?: number;
  volume?: number;
  change?: number;
  changePercent?: number;
  sma20?: number;
  ema9?: number;
  rsi14?: number;
  bid?: number;
  ask?: number;
  buyVolume?: number;
  sellVolume?: number;
}

interface OHLCPoint {
  timestamp: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
  buyVolume?: number;
  sellVolume?: number;
}

// ‚ú® NEW: Ultra-fast chart update interface
interface ChartUpdate {
  symbol: string;
  price: number;
  timestamp: number;
  volume: number;
  change: number;
  changePercent: number;
}

interface PlotlyChartProps {
  symbol: string;
  data: DataPoint | null;
  historicalData: DataPoint[];
  ohlcData?: OHLCPoint[];
  chartUpdates: ChartUpdate[];        // ‚ú® NEW PROP
  updateFrequency?: number;           // ‚ú® NEW PROP
  tradingHours: {
    start: string;
    end: string;
    current: string;
    isActive: boolean;
  };
}

const PlotlyChart: React.FC<PlotlyChartProps> = ({ 
  symbol, 
  data, 
  historicalData, 
  ohlcData = [], 
  chartUpdates = [],          // ‚ú® NEW PROP
  updateFrequency = 0,        // ‚ú® NEW PROP
  tradingHours,
}) => {
  const chartRef = useRef<any>(null);
  const spreadChartRef = useRef<any>(null);
  const bidAskChartRef = useRef<any>(null);
  const buySellVolumeChartRef = useRef<any>(null);
  const buySellLineChartRef = useRef<any>(null);
  const buySellSpreadChartRef = useRef<any>(null);
  const volumeChartRef = useRef<any>(null);

  const [initialized, setInitialized] = useState(false);
  // const [selectedTimeframe, setSelectedTimeframe] = useState<string>('1D');
  const [selectedTimeframe, setSelectedTimeframe] = useState<string>('1m');

  // const [chartType, setChartType] = useState<'line' | 'candle'>('candle');
  const [chartType, setChartType] = useState<'line' | 'candle'>('line');

  const [mainMode, setMainMode] = useState<'none' | 'bidAsk' | 'buySell'>('none');
  const [secondaryView, setSecondaryView] = useState<'line' | 'spread' | 'std'>('line');
  const [showIndicators, setShowIndicators] = useState({
    sma20: false,
    ema9: false,
    rsi: false,
    macd: false,
    bb: false,
    vwap: false,
    volume: false,
  });

  const [preservedAxisRanges, setPreservedAxisRanges] = useState<{
    xaxis?: [Date, Date];
    yaxis?: [number, number];
  }>({});

  // ============ OPTIMIZED: Ultra-fast chart updates ============
  const [isUpdating, setIsUpdating] = useState(false);
  const lastUpdateRef = useRef<number>(0);
  const chartDataRef = useRef<any[]>([]);

  // Ultra-fast chart updates using chartUpdates prop
  useEffect(() => {
    if (!chartUpdates || chartUpdates.length === 0 || !chartRef.current) return;

    const now = Date.now();
    // Throttle updates to maximum 10 fps (100ms) to prevent browser lag
    if (now - lastUpdateRef.current < 100) return;

    const latestUpdate = chartUpdates[chartUpdates.length - 1];
    const plotDiv = document.getElementById('plotly-chart');

    if (plotDiv && !isUpdating) {
      setIsUpdating(true);

      try {
        // For line charts - update the price trace
        if (chartType === 'line') {
          const timeValues = chartUpdates.map(update => new Date(update.timestamp * 1000));
          const priceValues = chartUpdates.map(update => update.price);

          // Use Plotly.restyle for ultra-fast updates
          if (typeof Plotly !== 'undefined' && Plotly.restyle) {
            Plotly.restyle(plotDiv, {
              'x': [timeValues],
              'y': [priceValues]
            }, [0]); // Update first trace (LTP line)
          }
        }
        // For candlestick charts - just update the last candle close price
        else if (data && ohlcData && ohlcData.length > 0) {
          const lastCandle = ohlcData[ohlcData.length - 1];
          if (lastCandle && latestUpdate.price !== lastCandle.close) {
            // Update the last candle's close price in real-time
            const updatedClose = [...ohlcData.map(candle => candle.close)];
            updatedClose[updatedClose.length - 1] = latestUpdate.price;

            if (typeof Plotly !== 'undefined' && Plotly.restyle) {
              Plotly.restyle(plotDiv, {
                'close': [updatedClose]
              }, [0]); // Update candlestick trace
            }
          }
        }

        lastUpdateRef.current = now;
      } catch (error) {
        console.error('Ultra-fast chart update error:', error);
      } finally {
        setIsUpdating(false);
      }
    }
  }, [chartUpdates, chartType, data, ohlcData, isUpdating]);

  // ‚ú® OPTIONAL: Performance monitoring
  useEffect(() => {
    if (chartUpdates.length > 0) {
      const fps = updateFrequency;
      if (fps > 15) {
        console.warn(`High chart update frequency: ${fps} fps - consider throttling`);
      }
    }
  }, [chartUpdates, updateFrequency]);

  // ============ YOUR EXISTING CALCULATION FUNCTIONS (Keep all as is) ============
  const calculateBuySellVolume = (dataPoint: DataPoint | OHLCPoint) => {
    let buyVolume = 0;
    let sellVolume = 0;
    const totalVolume = dataPoint.volume || 0;

    if ('buyVolume' in dataPoint && 'sellVolume' in dataPoint) {
      buyVolume = dataPoint.buyVolume || 0;
      sellVolume = dataPoint.sellVolume || 0;
    } else {
      let priceChange = 0;
      if ('open' in dataPoint && 'close' in dataPoint) {
        priceChange = (dataPoint.close - dataPoint.open) / dataPoint.open;
      } else if ('ltp' in dataPoint) {
        const currentIndex = historicalData.findIndex(p => p.timestamp === dataPoint.timestamp);
        if (currentIndex > 0) {
          const prevPrice = historicalData[currentIndex - 1].ltp;
          priceChange = (dataPoint.ltp - prevPrice) / prevPrice;
        }
      }

      const buyRatio = Math.max(0, Math.min(1, 0.5 + priceChange * 2));
      buyVolume = totalVolume * buyRatio;
      sellVolume = totalVolume * (1 - buyRatio);
    }

    return { buyVolume, sellVolume };
  };

  const calculateBuySellPrices = (dataPoint: DataPoint | OHLCPoint, index: number) => {
    let currentPrice = 0;
    if ('ltp' in dataPoint) {
      currentPrice = dataPoint.ltp;
    } else if ('close' in dataPoint) {
      currentPrice = dataPoint.close;
    }

    // Calculate spread based on volatility and volume
    const windowSize = 20;
    let prices: number[] = [];
    
    if (chartType === 'line') {
      const startIndex = Math.max(0, index - windowSize + 1);
      prices = historicalData.slice(startIndex, index + 1).map(p => p.ltp);
    } else {
      const startIndex = Math.max(0, index - windowSize + 1);
      prices = ohlcData.slice(startIndex, index + 1).map(c => c.close);
    }
    
    // Calculate volatility (standard deviation)
    if (prices.length > 1) {
      const mean = prices.reduce((sum, p) => sum + p, 0) / prices.length;
      const squaredDiffs = prices.map(p => Math.pow(p - mean, 2));
      const avgSquaredDiff = squaredDiffs.reduce((sum, sq) => sum + sq, 0) / squaredDiffs.length;
      const volatility = Math.sqrt(avgSquaredDiff);
      
      // Spread based on volatility (typically 0.1% to 1% of price)
      const spreadPercent = Math.min(Math.max(volatility / currentPrice, 0.001), 0.01);
      const halfSpread = currentPrice * spreadPercent / 2;
      
      return {
        buyPrice: currentPrice + halfSpread,
        sellPrice: currentPrice - halfSpread
      };
    }
    
    // Fallback to simple 0.1% spread
    const defaultSpread = currentPrice * 0.001;
    return {
      buyPrice: currentPrice + defaultSpread,
      sellPrice: currentPrice - defaultSpread
    };
  };

  // ============ ENHANCED: prepareLineChartData with chartUpdates integration ============
  const prepareLineChartData = () => {
    const allData = [...historicalData];

    // ‚ú® ENHANCED: Merge chart updates for ultra-smooth line
    if (chartUpdates && chartUpdates.length > 0) {
      const latestHistoricalTime = historicalData.length > 0 ? 
        historicalData[historicalData.length - 1].timestamp : 0;

      // Add chart updates that are newer than historical data
      const recentUpdates = chartUpdates
        .filter(update => update.timestamp > latestHistoricalTime)
        .map(update => ({
          symbol: update.symbol,
          ltp: update.price,
          timestamp: update.timestamp,
          volume: update.volume,
          change: update.change,
          changePercent: update.changePercent
        }));

      allData.push(...recentUpdates);
    } else if (data && data.ltp) {
      const lastPoint = historicalData.length > 0 ? historicalData[historicalData.length - 1] : null;
      if (!lastPoint || lastPoint.timestamp !== data.timestamp) {
        allData.push(data);
      }
    }

    allData.sort((a, b) => a.timestamp - b.timestamp);

    const x = allData.map(point => new Date(point.timestamp * 1000));
    const y = allData.map(point => point.ltp);
    const bid = allData.map(point => point.bid || null);
    const ask = allData.map(point => point.ask || null);

    const spread = allData.map(point => {
      if (point.ask && point.bid) {
        return point.ask - point.bid;
      }
      return null;
    });

    const sma20 = allData.map(point => point.sma20 || null);
    const ema9 = allData.map(point => point.ema9 || null);
    const rsi = allData.map(point => point.rsi14 || null);

    const buyVolumes = allData.map(point => calculateBuySellVolume(point).buyVolume);
    const sellVolumes = allData.map(point => calculateBuySellVolume(point).sellVolume);

    // Calculate buy/sell prices (simplified calculation)
    const buyPrices = allData.map(point => point.ltp * 1.001); // Slightly above LTP
    const sellPrices = allData.map(point => point.ltp * 0.999); // Slightly below LTP

    const buySellSpreads = allData.map((point, index) => buyPrices[index] - sellPrices[index]);

    return {
      x,
      y,
      allData,
      sma20,
      ema9,
      rsi,
      bid,
      ask,
      spread,
      buyVolumes,
      sellVolumes,
      buyPrices,
      sellPrices,
      buySellSpreads
    };
  };

  const calculateStandardDeviation = (values: number[], usePopulation = false) => {
    if (values.length === 0) return 0;
    const mean = values.reduce((acc, val) => acc + val, 0) / values.length;
    const sumOfSquaredDifferences = values.reduce((acc, val) => acc + (val - mean) ** 2, 0);
    return Math.sqrt(sumOfSquaredDifferences / (values.length - (usePopulation ? 0 : 1)));
  };

  const calculateVolumeStandardDeviation = (dataPoint: DataPoint | OHLCPoint, index: number) => {
    const windowSize = 20;
    let volumes: number[] = [];
    if (chartType === 'line') {
      const startIndex = Math.max(0, index - windowSize + 1);
      volumes = historicalData.slice(startIndex, index + 1)
        .map(point => point.volume || 0)
        .filter(vol => vol > 0);
    } else {
      const startIndex = Math.max(0, index - windowSize + 1);
      volumes = ohlcData.slice(startIndex, index + 1)
        .map(candle => candle.volume || 0)
        .filter(vol => vol > 0);
    }
    return volumes.length > 1 ? calculateStandardDeviation(volumes) : 0;
  };

  const calculateBidAskStandardDeviation = () => {
    const { bid, ask, x } = prepareLineChartData();
    const windowSize = 20;
    const bidStdDev = [];
    const askStdDev = [];
    for (let i = 0; i < bid.length; i++) {
      const startIndex = Math.max(0, i - windowSize + 1);
      const bidWindow = bid.slice(startIndex, i + 1).filter(b => b !== null && b !== undefined) as number[];
      const askWindow = ask.slice(startIndex, i + 1).filter(a => a !== null && a !== undefined) as number[];
      bidStdDev.push(bidWindow.length > 1 ? calculateStandardDeviation(bidWindow) : 0);
      askStdDev.push(askWindow.length > 1 ? calculateStandardDeviation(askWindow) : 0);
    }
    return { x, bidStdDev, askStdDev };
  };

  const calculateBuySellStandardDeviation = () => {
    let x: Date[] = [];
    let buyPrices: number[] = [];
    let sellPrices: number[] = [];
    if (chartType === 'line') {
      const data = prepareLineChartData();
      x = data.x;
      buyPrices = data.buyPrices;
      sellPrices = data.sellPrices;
    } else {
      const data = prepareCandlestickData();
      x = data.x;
      buyPrices = data.buyPrices;
      sellPrices = data.sellPrices;
    }
    const windowSize = 20;
    const buyStdDev = [];
    const sellStdDev = [];
    for (let i = 0; i < buyPrices.length; i++) {
      const startIndex = Math.max(0, i - windowSize + 1);
      const buyWindow = buyPrices.slice(startIndex, i + 1).filter(p => p !== null && p !== undefined && !isNaN(p)) as number[];
      const sellWindow = sellPrices.slice(startIndex, i + 1).filter(p => p !== null && p !== undefined && !isNaN(p)) as number[];
      buyStdDev.push(buyWindow.length > 1 ? calculateStandardDeviation(buyWindow) : 0);
      sellStdDev.push(sellWindow.length > 1 ? calculateStandardDeviation(sellWindow) : 0);
    }
    return { x, buyStdDev, sellStdDev };
  };

  const calculateSMA = (prices: number[], period: number) => {
    if (prices.length < period) return [];
    const smaValues = [];
    for (let i = period - 1; i < prices.length; i++) {
      const sum = prices.slice(i - period + 1, i + 1).reduce((acc, val) => acc + val, 0);
      smaValues.push(sum / period);
    }
    return smaValues;
  };

  const calculateEMA = (prices: number[], period: number) => {
    if (prices.length < period) return [];
    const multiplier = 2 / (period + 1);
    const emaValues = [];
    const firstSMA = prices.slice(0, period).reduce((acc, val) => acc + val, 0) / period;
    emaValues.push(firstSMA);

    for (let i = period; i < prices.length; i++) {
      const ema = (prices[i] * multiplier) + (emaValues[emaValues.length - 1] * (1 - multiplier));
      emaValues.push(ema);
    }
    return emaValues;
  };

  const calculateRSI = (prices: number[], period: number) => {
    if (prices.length < period + 1) return [];
    const gains = [];
    const losses = [];
    for (let i = 1; i < prices.length; i++) {
      const change = prices[i] - prices[i - 1];
      gains.push(change > 0 ? change : 0);
      losses.push(change < 0 ? Math.abs(change) : 0);
    }

    const rsiValues = [];
    for (let i = period - 1; i < gains.length; i++) {
      const avgGain = gains.slice(i - period + 1, i + 1).reduce((acc, val) => acc + val, 0) / period;
      const avgLoss = losses.slice(i - period + 1, i + 1).reduce((acc, val) => acc + val, 0) / period;
      if (avgLoss === 0) {
        rsiValues.push(100);
      } else {
        const rs = avgGain / avgLoss;
        const rsi = 100 - (100 / (1 + rs));
        rsiValues.push(rsi);
      }
    }
    return rsiValues;
  };

  const calculateBollingerBands = (prices: number[], period: number, stdDev: number) => {
    if (prices.length < period) return null;
    const smaValues = calculateSMA(prices, period);
    const upper = [];
    const middle = [];
    const lower = [];

    for (let i = 0; i < smaValues.length; i++) {
      const startIndex = i + period - 1;
      const slice = prices.slice(startIndex - period + 1, startIndex + 1);
      const std = calculateStandardDeviation(slice);
      middle.push(smaValues[i]);
      upper.push(smaValues[i] + (std * stdDev));
      lower.push(smaValues[i] - (std * stdDev));
    }
    return { upper, middle, lower };
  };

  const calculateMACD = (prices: number[], fastPeriod: number, slowPeriod: number, signalPeriod: number) => {
    if (prices.length < slowPeriod) return null;
    const fastEMA = calculateEMA(prices, fastPeriod);
    const slowEMA = calculateEMA(prices, slowPeriod);
    if (fastEMA.length === 0 || slowEMA.length === 0) return null;

    const macdLine = [];
    const startIndex = slowPeriod - fastPeriod;
    for (let i = 0; i < slowEMA.length; i++) {
      macdLine.push(fastEMA[i + startIndex] - slowEMA[i]);
    }

    const signalLine = calculateEMA(macdLine, signalPeriod);
    const histogram = [];
    for (let i = signalPeriod - 1; i < macdLine.length; i++) {
      histogram.push(macdLine[i] - signalLine[i - signalPeriod + 1]);
    }

    return { macdLine, signalLine, histogram };
  };

  const calculateVWAP = (close: number[], high: number[], low: number[], volume: number[]) => {
    const vwapValues = [];
    let cumulativePriceVolume = 0;
    let cumulativeVolume = 0;

    for (let i = 0; i < close.length; i++) {
      const typicalPrice = (high[i] + low[i] + close[i]) / 3;
      cumulativePriceVolume += typicalPrice * volume[i];
      cumulativeVolume += volume[i];
      vwapValues.push(cumulativeVolume > 0 ? cumulativePriceVolume / cumulativeVolume : typicalPrice);
    }
    return vwapValues;
  };

  const prepareCandlestickData = () => {
    if (!ohlcData || ohlcData.length === 0) {
      return { x: [], open: [], high: [], low: [], close: [], volume: [], volumeStdDev: [], buyVolumes: [], sellVolumes: [], buyPrices: [], sellPrices: [], buySellSpreads: [] };
    }

    const validOhlcData = ohlcData.filter(candle => 
      candle.open !== null && candle.open !== undefined &&
      candle.high !== null && candle.high !== undefined &&
      candle.low !== null && candle.low !== undefined &&
      candle.close !== null && candle.close !== undefined
    );

    if (validOhlcData.length === 0) {
      return { x: [], open: [], high: [], low: [], close: [], volume: [], volumeStdDev: [], buyVolumes: [], sellVolumes: [], buyPrices: [], sellPrices: [], buySellSpreads: [] };
    }

    const sortedData = [...validOhlcData].sort((a, b) => a.timestamp - b.timestamp);
    const buyVolumes = sortedData.map(candle => calculateBuySellVolume(candle).buyVolume);
    const sellVolumes = sortedData.map(candle => calculateBuySellVolume(candle).sellVolume);
    const volumeStdDev = sortedData.map((candle, index) => 
      calculateVolumeStandardDeviation(candle, index)
    );
    const buyPrices = sortedData.map((candle, index) => calculateBuySellPrices(candle, index).buyPrice);
    const sellPrices = sortedData.map((candle, index) => calculateBuySellPrices(candle, index).sellPrice);
    const buySellSpreads = sortedData.map((candle, index) => {
      const { buyPrice, sellPrice } = calculateBuySellPrices(candle, index);
      return buyPrice - sellPrice;
    });

    const processedVolume = sortedData.map(candle => {
      const vol = candle.volume;
      if (vol === null || vol === undefined || isNaN(vol)) {
        return 0;
      }
      return Number(vol);
    });

    return {
      x: sortedData.map(candle => new Date(candle.timestamp * 1000)),
      open: sortedData.map(candle => Number(candle.open)),
      high: sortedData.map(candle => Number(candle.high)),
      low: sortedData.map(candle => Number(candle.low)),
      close: sortedData.map(candle => Number(candle.close)),
      volume: processedVolume,
      volumeStdDev: volumeStdDev,
      buyVolumes,
      sellVolumes,
      buyPrices,
      sellPrices,
      buySellSpreads
    };
  };

  const calculateYAxisRange = (timeRange: [any, any] | undefined) => {
    if (!timeRange || !timeRange[0] || !timeRange[1]) return undefined;

    const startTime = new Date(timeRange[0]).getTime() / 1000;
    const endTime = new Date(timeRange[1]).getTime() / 1000;

    if (chartType === 'line') {
      if (historicalData.length === 0) return undefined;
      const visibleData = historicalData.filter(
        point => point.timestamp >= startTime && point.timestamp <= endTime
      );
      if (visibleData.length === 0) return undefined;
      const prices = visibleData.map(point => point.ltp).filter(p => p !== null && p !== undefined);
      if (prices.length === 0) return undefined;
      const minPrice = Math.min(...prices);
      const maxPrice = Math.max(...prices);
      const padding = (maxPrice - minPrice) * 0.05;
      return [minPrice - padding, maxPrice + padding];
    } else {
      if (!ohlcData || ohlcData.length === 0) return undefined;
      const visibleCandles = ohlcData.filter(
        candle => candle.timestamp >= startTime && candle.timestamp <= endTime
      );
      if (visibleCandles.length === 0) return undefined;
      const validCandles = visibleCandles.filter(candle => 
        candle.high !== null && candle.high !== undefined &&
        candle.low !== null && candle.low !== undefined
      );
      if (validCandles.length === 0) return undefined;
      const highPrices = validCandles.map(candle => Number(candle.high));
      const lowPrices = validCandles.map(candle => Number(candle.low));
      const minPrice = Math.min(...lowPrices);
      const maxPrice = Math.max(...highPrices);
      const padding = (maxPrice - minPrice) * 0.05;
      return [minPrice - padding, maxPrice + padding];
    }
  };

  const calculateBidAskRange = () => {
    const { bid, ask } = prepareLineChartData();
    const validBids = bid.filter(b => b !== null && b !== undefined) as number[];
    const validAsks = ask.filter(a => a !== null && a !== undefined) as number[];
    if (validBids.length === 0 || validAsks.length === 0) return undefined;
    const minBid = Math.min(...validBids);
    const maxAsk = Math.max(...validAsks);
    const padding = (maxAsk - minBid) * 0.05;
    return [minBid - padding, maxAsk + padding];
  };

  const calculateBuySellRange = () => {
    let buyPrices: number[] = [];
    let sellPrices: number[] = [];
    if (chartType === 'line') {
      const { buyPrices: bp, sellPrices: sp } = prepareLineChartData();
      buyPrices = bp.filter(p => p !== null && p !== undefined && !isNaN(p)) as number[];
      sellPrices = sp.filter(p => p !== null && p !== undefined && !isNaN(p)) as number[];
    } else {
      const { buyPrices: bp, sellPrices: sp } = prepareCandlestickData();
      buyPrices = bp.filter(p => p !== null && p !== undefined && !isNaN(p)) as number[];
      sellPrices = sp.filter(p => p !== null && p !== undefined && !isNaN(p)) as number[];
    }
    if (buyPrices.length === 0 || sellPrices.length === 0) return undefined;
    const minPrice = Math.min(...sellPrices);
    const maxPrice = Math.max(...buyPrices);
    const padding = (maxPrice - minPrice) * 0.05;
    return [minPrice - padding, maxPrice + padding];
  };

  const calculateSpreadRange = () => {
    const { spread } = prepareLineChartData();
    const validSpreads = spread.filter(s => s !== null && s !== undefined) as number[];
    if (validSpreads.length === 0) return [0, 1];
    const minSpread = Math.min(...validSpreads);
    const maxSpread = Math.max(...validSpreads);
    const padding = Math.max((maxSpread - minSpread) * 0.1, 0.01);
    return [Math.max(0, minSpread - padding), maxSpread + padding];
  };

  const calculateBuySellSpreadRange = () => {
    let buySellSpreads: number[] = [];
    if (chartType === 'line') {
      const { buySellSpreads: bss } = prepareLineChartData();
      buySellSpreads = bss.filter(s => s !== null && s !== undefined && !isNaN(s)) as number[];
    } else {
      const { buySellSpreads: bss } = prepareCandlestickData();
      buySellSpreads = bss.filter(s => s !== null && s !== undefined && !isNaN(s)) as number[];
    }
    if (buySellSpreads.length === 0) return [0, 1];
    const minSpread = Math.min(...buySellSpreads);
    const maxSpread = Math.max(...buySellSpreads);
    const padding = Math.max((maxSpread - minSpread) * 0.1, 0.01);
    return [Math.max(0, minSpread - padding), maxSpread + padding];
  };

  const calculateVolumeRange = () => {
    let volumes: number[] = [];
    if (chartType === 'line') {
      volumes = historicalData.map(point => point.volume || 0).filter(v => v > 0);
    } else {
      const { volume } = prepareCandlestickData();
      volumes = volume.filter(v => v > 0);
    }
    if (volumes.length === 0) return [0, 1000];
    const maxVolume = Math.max(...volumes);
    return [0, maxVolume * 1.1];
  };

  const calculateBuySellVolumeRange = () => {
    let buyVolumes: number[] = [];
    let sellVolumes: number[] = [];
    if (chartType === 'line') {
      const { buyVolumes: bv, sellVolumes: sv } = prepareLineChartData();
      buyVolumes = bv.filter(v => v !== null && v !== undefined) as number[];
      sellVolumes = sv.filter(v => v !== null && v !== undefined) as number[];
    } else {
      const { buyVolumes: bv, sellVolumes: sv } = prepareCandlestickData();
      buyVolumes = bv.filter(v => v !== null && v !== undefined) as number[];
      sellVolumes = sv.filter(v => v !== null && v !== undefined) as number[];
    }
    if (buyVolumes.length === 0 && sellVolumes.length === 0) return [0, 1000];
    const maxBuyVolume = buyVolumes.length > 0 ? Math.max(...buyVolumes) : 0;
    const maxSellVolume = sellVolumes.length > 0 ? Math.max(...sellVolumes) : 0;
    const maxVolume = Math.max(maxBuyVolume, maxSellVolume);
    return [0, maxVolume * 1.1];
  };

  const getTimeRange = () => {
    const dataToUse = chartType === 'line' ? historicalData : ohlcData;
    if (!dataToUse || dataToUse.length === 0) return undefined;

    const now = data?.timestamp 
      ? new Date(data.timestamp * 1000) 
      : new Date();

    let startTime = new Date(now);
    switch (selectedTimeframe) {
      case '1m':
        startTime.setMinutes(now.getMinutes() - 1);
        break;
      case '5m':
        startTime.setMinutes(now.getMinutes() - 5);
        break;
      case '10m':
        startTime.setMinutes(now.getMinutes() - 10);
        break;
      case '30m':
        startTime.setMinutes(now.getMinutes() - 30);
        break;
      case '1H':
        startTime.setHours(now.getHours() - 1);
        break;
      case '6H':
        startTime.setHours(now.getHours() - 6);
        break;
      case '12H':
        startTime.setHours(now.getHours() - 12);
        break;
      case '1D':
      default:
        try {
          const tradingStart = new Date(tradingHours.start);
          return [tradingStart, now > new Date(tradingHours.end) ? new Date(tradingHours.end) : now];
        } catch (e) {
          startTime.setHours(now.getHours() - 24);
        }
    }
    return [startTime, now];
  };

  const getColorTheme = () => {
    return {
      bg: '#18181b',
      paper: '#18181b',
      text: '#e4e4e7',
      grid: '#27272a',
      line: getLineColor(),
      upColor: '#22c55e',
      downColor: '#ef4444',
      button: {
        bg: '#27272a',
        bgActive: '#3b82f6',
        text: '#e4e4e7'
      },
      indicator: {
        sma20: '#f97316',
        ema9: '#8b5cf6',
        rsi: '#06b6d4',
        macd: '#3b82f6',
        bb: '#64748b',
        vwap: '#06b6d4',
        bid: '#22c55e',
        ask: '#ef4444',
        spread: '#3b82f6',
        buyVolume: '#22c55e',
        sellVolume: '#ef4444',
        buyPrice: '#10b981',
        sellPrice: '#f59e0b',
        buySellSpread: '#8b5cf6',
        volume: '#64748b',
        std: '#f97316'
      }
    };
  };

  const getLineColor = () => {
    const { y } = prepareLineChartData();
    if (y.length < 2) return '#22d3ee';
    const lastPrice = y[y.length - 1];
    const prevPrice = y[y.length - 2];
    return lastPrice >= prevPrice ? '#22c55e' : '#ef4444';
  };

  const toggleMainMode = (mode: 'bidAsk' | 'buySell') => {
    if (mainMode === mode) {
      setMainMode('none');
    } else {
      setMainMode(mode);
      setSecondaryView('line');
    }
  };

  const toggleSecondaryView = (view: 'line' | 'spread' | 'std') => {
    setSecondaryView(view);
  };

  const handleTimeframeChange = (timeframe: string) => {
    // ‚ú® ADD THIS - Prevent updates during timeframe changes
    setIsUpdating(true);

    setSelectedTimeframe(timeframe);
    setPreservedAxisRanges({});

    if (!chartRef.current) return;
    const plotDiv = document.getElementById('plotly-chart');
    if (!plotDiv) return;

    try {
      const newTimeRange = getTimeRange();
      const newYRange = calculateYAxisRange(newTimeRange);

      if (typeof Plotly !== 'undefined' && Plotly.relayout) {
        Plotly.relayout(plotDiv, {
          'xaxis.range': newTimeRange,
          'xaxis.autorange': false,
          'yaxis.range': newYRange,
          'yaxis.autorange': newYRange ? false : true
        });
      }

      const spreadDiv = document.getElementById('spread-chart');
      if (spreadDiv && mainMode === 'bidAsk' && secondaryView === 'spread' && typeof Plotly !== 'undefined') {
        Plotly.relayout(spreadDiv, {
          'xaxis.range': newTimeRange,
          'xaxis.autorange': false,
          'yaxis.range': calculateSpreadRange(),
          'yaxis.autorange': false
        });
      }

      const bidAskDiv = document.getElementById('bid-ask-chart');
      if (bidAskDiv && mainMode === 'bidAsk' && secondaryView === 'line' && typeof Plotly !== 'undefined') {
        Plotly.relayout(bidAskDiv, {
          'xaxis.range': newTimeRange,
          'xaxis.autorange': false,
          'yaxis.range': calculateBidAskRange(),
          'yaxis.autorange': false
        });
      }

      const volumeDiv = document.getElementById('volume-chart');
      if (volumeDiv && showIndicators.volume && typeof Plotly !== 'undefined') {
        Plotly.relayout(volumeDiv, {
          'xaxis.range': newTimeRange,
          'xaxis.autorange': false,
          'yaxis.range': calculateVolumeRange(),
          'yaxis.autorange': false
        });
      }

      const buySellVolumeDiv = document.getElementById('buy-sell-volume-chart');
      if (buySellVolumeDiv && mainMode !== 'none' && secondaryView === 'std' && typeof Plotly !== 'undefined') {
        Plotly.relayout(buySellVolumeDiv, {
          'xaxis.range': newTimeRange,
          'xaxis.autorange': false,
          'yaxis.range': calculateBuySellVolumeRange(),
          'yaxis.autorange': false
        });
      }

      const buySellLineDiv = document.getElementById('buy-sell-line-chart');
      if (buySellLineDiv && mainMode === 'buySell' && secondaryView === 'line' && typeof Plotly !== 'undefined') {
        Plotly.relayout(buySellLineDiv, {
          'xaxis.range': newTimeRange,
          'xaxis.autorange': false,
          'yaxis.range': calculateBuySellRange(),
          'yaxis.autorange': false
        });
      }

      const buySellSpreadDiv = document.getElementById('buy-sell-spread-chart');
      if (buySellSpreadDiv && mainMode === 'buySell' && secondaryView === 'spread' && typeof Plotly !== 'undefined') {
        Plotly.relayout(buySellSpreadDiv, {
          'xaxis.range': newTimeRange,
          'xaxis.autorange': false,
          'yaxis.range': calculateBuySellSpreadRange(),
          'yaxis.autorange': false
        });
      }
    } catch (err) {
      console.error('Error updating timeframe:', err);
      setTimeout(() => {
        try {
          if (chartRef.current) {
            const plotDiv = document.getElementById('plotly-chart');
            if (plotDiv && typeof Plotly !== 'undefined') {
              Plotly.react(plotDiv, createPlotData(), createLayout());
            }
          }
        } catch (fallbackErr) {
          console.error('Fallback chart update failed:', fallbackErr);
        }
      }, 100);
    }

    // ‚ú® ADD THIS AT THE END
    setTimeout(() => setIsUpdating(false), 200);
  };

  const toggleChartType = () => {
    const plotDiv = document.getElementById('plotly-chart');
    if (plotDiv && (plotDiv as any).layout) {
      const currentLayout = (plotDiv as any).layout;
      setPreservedAxisRanges({
        xaxis: currentLayout.xaxis?.range ? [
          currentLayout.xaxis.range[0],
          currentLayout.xaxis.range[1]
        ] : undefined,
        yaxis: currentLayout.yaxis?.range ? [
          currentLayout.yaxis.range[0],
          currentLayout.yaxis.range[1]
        ] : undefined,
      });
    }
    setChartType(prev => prev === 'line' ? 'candle' : 'line');
  };

  const toggleIndicator = (indicator: 'sma20' | 'ema9' | 'rsi' | 'macd' | 'bb' | 'vwap' | 'volume') => {
    setShowIndicators(prev => ({
      ...prev,
      [indicator]: !prev[indicator]
    }));
  };

  const handleRelayout = (eventData: any) => {
    if (eventData['xaxis.range[0]'] && eventData['xaxis.range[1]']) {
      const startDate = new Date(eventData['xaxis.range[0]']);
      const endDate = new Date(eventData['xaxis.range[1]']);
      const startTime = startDate.getTime() / 1000;
      const endTime = endDate.getTime() / 1000;

      let minValue, maxValue;
      if (chartType === 'line') {
        const visibleData = historicalData.filter(
          point => point.timestamp >= startTime && point.timestamp <= endTime
        );
        if (visibleData.length > 0) {
          const prices = visibleData.map(point => point.ltp).filter(p => p !== null && p !== undefined);
          if (prices.length > 0) {
            minValue = Math.min(...prices);
            maxValue = Math.max(...prices);
          }
        }
      } else {
        const visibleData = ohlcData.filter(
          candle => candle.timestamp >= startTime && candle.timestamp <= endTime
        );
        if (visibleData.length > 0) {
          const validCandles = visibleData.filter(candle => 
            candle.high !== null && candle.high !== undefined &&
            candle.low !== null && candle.low !== undefined
          );
          if (validCandles.length > 0) {
            const highPrices = validCandles.map(candle => Number(candle.high));
            const lowPrices = validCandles.map(candle => Number(candle.low));
            minValue = Math.min(...lowPrices);
            maxValue = Math.max(...highPrices);
          }
        }
      }

      if (minValue !== undefined && maxValue !== undefined) {
        const padding = (maxValue - minValue) * 0.05;
        const yRange = [minValue - padding, maxValue + padding];
        const plotDiv = document.getElementById('plotly-chart');
        if (plotDiv && typeof Plotly !== 'undefined') {
          Plotly.relayout(plotDiv, {
            'yaxis.range': yRange,
            'yaxis.autorange': false
          });
        }

        const bidAskDiv = document.getElementById('bid-ask-chart');
        if (bidAskDiv && typeof Plotly !== 'undefined') {
          Plotly.relayout(bidAskDiv, {
            'xaxis.range': [startDate, endDate],
            'xaxis.autorange': false
          });
        }

        const spreadDiv = document.getElementById('spread-chart');
        if (spreadDiv && typeof Plotly !== 'undefined') {
          Plotly.relayout(spreadDiv, {
            'xaxis.range': [startDate, endDate],
            'xaxis.autorange': false
          });
        }

        const volumeDiv = document.getElementById('volume-chart');
        if (volumeDiv && typeof Plotly !== 'undefined') {
          Plotly.relayout(volumeDiv, {
            'xaxis.range': [startDate, endDate],
            'xaxis.autorange': false
          });
        }

        const buySellVolumeDiv = document.getElementById('buy-sell-volume-chart');
        if (buySellVolumeDiv && typeof Plotly !== 'undefined') {
          Plotly.relayout(buySellVolumeDiv, {
            'xaxis.range': [startDate, endDate],
            'xaxis.autorange': false
          });
        }

        const buySellLineDiv = document.getElementById('buy-sell-line-chart');
        if (buySellLineDiv && typeof Plotly !== 'undefined') {
          Plotly.relayout(buySellLineDiv, {
            'xaxis.range': [startDate, endDate],
            'xaxis.autorange': false
          });
        }

        const buySellSpreadDiv = document.getElementById('buy-sell-spread-chart');
        if (buySellSpreadDiv && typeof Plotly !== 'undefined') {
          Plotly.relayout(buySellSpreadDiv, {
            'xaxis.range': [startDate, endDate],
            'xaxis.autorange': false
          });
        }
      }
    }
  };

  // ============ ENHANCED: Main chart rendering with chartUpdates dependency ============
  useEffect(() => {
    if (!chartRef.current) return;
    const plotDiv = document.getElementById('plotly-chart');
    if (!plotDiv) return;

    if (!initialized) {
      setInitialized(true);
      return;
    }

    try {
      if (chartType === 'line') {
        const { x, y } = prepareLineChartData();
        if (x.length === 0 || y.length === 0) return;
        if (typeof Plotly !== 'undefined' && Plotly.react) {
          Plotly.react(plotDiv, createPlotData(), createLayout());
        }
      } else {
        const { x, open, high, low, close } = prepareCandlestickData();
        if (x.length === 0) return;
        if (typeof Plotly !== 'undefined' && Plotly.react) {
          Plotly.react(plotDiv, createPlotData(), createLayout());
        }
      }

      if (mainMode === 'bidAsk' && secondaryView === 'line') {
        const bidAskDiv = document.getElementById('bid-ask-chart');
        if (bidAskDiv && typeof Plotly !== 'undefined') {
          const { x, bid, ask } = prepareLineChartData();
          Plotly.react(bidAskDiv, createBidAskData(), createBidAskLayout());
        }
      }

      if (mainMode === 'bidAsk' && secondaryView === 'spread') {
        const spreadDiv = document.getElementById('spread-chart');
        if (spreadDiv && typeof Plotly !== 'undefined') {
          const { x, spread } = prepareLineChartData();
          Plotly.react(spreadDiv, createSpreadData(), createSpreadLayout());
        }
      }

      if (showIndicators.volume) {
        const volumeDiv = document.getElementById('volume-chart');
        if (volumeDiv && typeof Plotly !== 'undefined') {
          Plotly.react(volumeDiv, createVolumeData(), createVolumeLayout());
        }
      }

      if (mainMode !== 'none' && secondaryView === 'std') {
        const buySellVolumeDiv = document.getElementById('buy-sell-volume-chart');
        if (buySellVolumeDiv && typeof Plotly !== 'undefined') {
          Plotly.react(buySellVolumeDiv, createStdData(), createStdLayout());
        }
      }

      if (mainMode === 'buySell' && secondaryView === 'line') {
        const buySellLineDiv = document.getElementById('buy-sell-line-chart');
        if (buySellLineDiv && typeof Plotly !== 'undefined') {
          Plotly.react(buySellLineDiv, createBuySellLineData(), createBuySellLineLayout());
        }
      }

      if (mainMode === 'buySell' && secondaryView === 'spread') {
        const buySellSpreadDiv = document.getElementById('buy-sell-spread-chart');
        if (buySellSpreadDiv && typeof Plotly !== 'undefined') {
          Plotly.react(buySellSpreadDiv, createBuySellSpreadData(), createBuySellSpreadLayout());
        }
      }
    } catch (err) {
      console.error('Error updating chart:', err);
    }
  }, [data, historicalData, ohlcData, chartUpdates, initialized, selectedTimeframe, chartType, showIndicators, mainMode, secondaryView]);

  const createPlotData = () => {
    const colors = getColorTheme();
    let plotData: any[] = [];

    if (chartType === 'line') {
      if (historicalData && historicalData.length > 0) {
        const validData = historicalData.filter(point => 
          point.ltp !== null && 
          point.ltp !== undefined && 
          point.ltp > 0 && 
          !isNaN(point.ltp) &&
          point.timestamp !== null &&
          point.timestamp !== undefined
        );

        if (validData.length === 0) return plotData;

        const sortedData = [...validData].sort((a, b) => a.timestamp - b.timestamp);
        const timeValues = sortedData.map(point => new Date(point.timestamp * 1000));
        const priceValues = sortedData.map(point => Number(point.ltp));

        plotData.push({
          x: timeValues,
          y: priceValues,
          type: 'scatter',
          mode: 'lines',
          name: 'LTP',
          line: {
            color: colors.line || '#3B82F6',
            width: 2,
            shape: 'linear'
          },
          connectgaps: false,
          hovertemplate: '<b>%{fullData.name}</b><br>' +
                        'Time: %{x|%H:%M:%S}<br>' +
                        'Price: ‚Çπ%{y:.2f}<br>' +
                        '<extra></extra>',
          showlegend: true
        });

        const volumeValues = sortedData.map(point => point.volume || 0);
        const volumeColors = [];
        for (let i = 0; i < sortedData.length; i++) {
          if (i === 0) {
            volumeColors.push(colors.upColor);
          } else {
            const currentPrice = priceValues[i];
            const prevPrice = priceValues[i - 1];
            volumeColors.push(currentPrice >= prevPrice ? colors.upColor : colors.downColor);
          }
        }

        if (volumeValues.some(v => v > 0)) {
          plotData.push({
            x: timeValues,
            y: volumeValues,
            type: 'histogram',
            histfunc: 'sum',
            name: 'Volume',
            marker: {
              color: volumeColors,
              opacity: 0.9,
              line: {
                width: 0.5,
                color: 'rgba(255,255,255,0.1)'
              }
            },
            xbins: {
              size: 60000
            },
            yaxis: 'y3',
            hovertemplate: '<b>%{fullData.name}</b><br>' +
                          'Time: %{x|%H:%M:%S}<br>' +
                          'Volume: %{y:,.0f}<br>' +
                          '<extra></extra>',
            showlegend: true
          });
        }

        if (showIndicators.sma20 && priceValues.length >= 20) {
          const sma20Values = calculateSMA(priceValues, 20);
          if (sma20Values && sma20Values.length > 0) {
            plotData.push({
              x: timeValues.slice(19),
              y: sma20Values,
              type: 'scatter',
              mode: 'lines',
              name: 'SMA 20',
              line: {
                color: colors.indicator?.sma20 || '#f59e0b',
                width: 1.5,
                dash: 'dot'
              },
              connectgaps: false,
              hovertemplate: '<b>%{fullData.name}</b><br>' +
                            'Time: %{x|%H:%M:%S}<br>' +
                            'SMA20: ‚Çπ%{y:.2f}<br>' +
                            '<extra></extra>',
              showlegend: true
            });
          }
        }

        if (showIndicators.ema9 && priceValues.length >= 9) {
          const ema9Values = calculateEMA(priceValues, 9);
          if (ema9Values && ema9Values.length > 0) {
            plotData.push({
              x: timeValues,
              y: ema9Values,
              type: 'scatter',
              mode: 'lines',
              name: 'EMA 9',
              line: {
                color: colors.indicator?.ema9 || '#8b5cf6',
                width: 1.5,
                dash: 'dash'
              },
              connectgaps: false,
              hovertemplate: '<b>%{fullData.name}</b><br>' +
                            'Time: %{x|%H:%M:%S}<br>' +
                            'EMA9: ‚Çπ%{y:.2f}<br>' +
                            '<extra></extra>',
              showlegend: true
            });
          }
        }

        if (showIndicators.bb && priceValues.length >= 20) {
          const bbData = calculateBollingerBands(priceValues, 20, 2);
          if (bbData && bbData.upper && bbData.middle && bbData.lower) {
            plotData.push({
              x: timeValues.slice(19),
              y: bbData.upper,
              type: 'scatter',
              mode: 'lines',
              name: 'BB Upper',
              line: {
                color: colors.indicator?.bb || '#64748b',
                width: 1,
                dash: 'dashdot'
              },
              connectgaps: false,
              hovertemplate: '<b>%{fullData.name}</b><br>' +
                            'Time: %{x|%H:%M:%S}<br>' +
                            'Upper: ‚Çπ%{y:.2f}<br>' +
                            '<extra></extra>',
              showlegend: true
            });

            plotData.push({
              x: timeValues.slice(19),
              y: bbData.middle,
              type: 'scatter',
              mode: 'lines',
              name: 'BB Middle',
              line: {
                color: colors.indicator?.bb || '#64748b',
                width: 1
              },
              connectgaps: false,
              hovertemplate: '<b>%{fullData.name}</b><br>' +
                            'Time: %{x|%H:%M:%S}<br>' +
                            'Middle: ‚Çπ%{y:.2f}<br>' +
                            '<extra></extra>',
              showlegend: true
            });

            plotData.push({
              x: timeValues.slice(19),
              y: bbData.lower,
              type: 'scatter',
              mode: 'lines',
              name: 'BB Lower',
              line: {
                color: colors.indicator?.bb || '#64748b',
                width: 1,
                dash: 'dashdot'
              },
              fill: 'tonexty',
              fillcolor: 'rgba(100, 116, 139, 0.1)',
              connectgaps: false,
              hovertemplate: '<b>%{fullData.name}</b><br>' +
                            'Time: %{x|%H:%M:%S}<br>' +
                            'Lower: ‚Çπ%{y:.2f}<br>' +
                            '<extra></extra>',
              showlegend: true
            });
          }
        }
      }
    } else {
      const { x, open, high, low, close, volume, volumeStdDev, buyVolumes, sellVolumes } = prepareCandlestickData();
      if (x.length === 0) return plotData;

      const hoverText = x.map((date, i) => 
        `${date.toLocaleDateString()} ${date.toLocaleTimeString()}<br>` +
        `Open: ${open[i]?.toFixed(2) || 'N/A'}<br>` +
        `High: ${high[i]?.toFixed(2) || 'N/A'}<br>` +
        `Low: ${low[i]?.toFixed(2) || 'N/A'}<br>` +
        `Close: ${close[i]?.toFixed(2) || 'N/A'}<br>` +
        `Volume: ${(volume[i] || 0).toLocaleString()}`
      );

      plotData.push({
        x: x,
        open: open,
        high: high,
        low: low,
        close: close,
        type: 'candlestick',
        name: 'OHLC',
        text: hoverText,
        hoverinfo: 'text',
        increasing: {
          line: { color: colors.upColor || '#10b981', width: 1 },
          fillcolor: colors.upColor || '#10b981'
        },
        decreasing: {
          line: { color: colors.downColor || '#ef4444', width: 1 },
          fillcolor: colors.downColor || '#ef4444'
        },
        showlegend: true
      });

      if (showIndicators.sma20 && close.length >= 20) {
        const sma20Values = calculateSMA(close, 20);
        if (sma20Values && sma20Values.length > 0) {
          plotData.push({
            x: x.slice(19),
            y: sma20Values,
            type: 'scatter',
            mode: 'lines',
            name: 'SMA 20',
            line: {
              color: colors.indicator?.sma20 || '#f59e0b',
              width: 2,
              dash: 'dot'
            },
            connectgaps: false,
            hovertemplate: '<b>%{fullData.name}</b><br>' +
                          'Time: %{x|%H:%M:%S}<br>' +
                          'SMA20: ‚Çπ%{y:.2f}<br>' +
                          '<extra></extra>',
            showlegend: true
          });
        }
      }

      if (showIndicators.ema9 && close.length >= 9) {
        const ema9Values = calculateEMA(close, 9);
        if (ema9Values && ema9Values.length > 0) {
          plotData.push({
            x: x,
            y: ema9Values,
            type: 'scatter',
            mode: 'lines',
            name: 'EMA 9',
            line: {
              color: colors.indicator?.ema9 || '#8b5cf6',
              width: 2,
              dash: 'dash'
            },
            connectgaps: false,
            hovertemplate: '<b>%{fullData.name}</b><br>' +
                          'Time: %{x|%H:%M:%S}<br>' +
                          'EMA9: ‚Çπ%{y:.2f}<br>' +
                          '<extra></extra>',
            showlegend: true
          });
        }
      }

      if (showIndicators.bb && close.length >= 20) {
        const bbData = calculateBollingerBands(close, 20, 2);
        if (bbData && bbData.upper && bbData.middle && bbData.lower) {
          plotData.push({
            x: x.slice(19),
            y: bbData.upper,
            type: 'scatter',
            mode: 'lines',
            name: 'BB Upper',
            line: {
              color: colors.indicator?.bb || '#64748b',
              width: 1,
              dash: 'dashdot'
            },
            connectgaps: false,
            hovertemplate: '<b>%{fullData.name}</b><br>' +
                          'Time: %{x|%H:%M:%S}<br>' +
                          'Upper: ‚Çπ%{y:.2f}<br>' +
                          '<extra></extra>',
            showlegend: true
          });

          plotData.push({
            x: x.slice(19),
            y: bbData.middle,
            type: 'scatter',
            mode: 'lines',
            name: 'BB Middle',
            line: {
              color: colors.indicator?.bb || '#64748b',
              width: 1
            },
            connectgaps: false,
            hovertemplate: '<b>%{fullData.name}</b><br>' +
                          'Time: %{x|%H:%M:%S}<br>' +
                          'Middle: ‚Çπ%{y:.2f}<br>' +
                          '<extra></extra>',
            showlegend: true
          });

          plotData.push({
            x: x.slice(19),
            y: bbData.lower,
            type: 'scatter',
            mode: 'lines',
            name: 'BB Lower',
            line: {
              color: colors.indicator?.bb || '#64748b',
              width: 1,
              dash: 'dashdot'
            },
            fill: 'tonexty',
            fillcolor: 'rgba(100, 116, 139, 0.1)',
            connectgaps: false,
            hovertemplate: '<b>%{fullData.name}</b><br>' +
                          'Time: %{x|%H:%M:%S}<br>' +
                          'Lower: ‚Çπ%{y:.2f}<br>' +
                          '<extra></extra>',
            showlegend: true
          });
        }
      }

      if (showIndicators.vwap && close.length > 0 && volume && volume.length > 0) {
        const vwapValues = calculateVWAP(close, high, low, volume);
        if (vwapValues && vwapValues.length > 0) {
          plotData.push({
            x: x,
            y: vwapValues,
            type: 'scatter',
            mode: 'lines',
            name: 'VWAP',
            line: {
              color: colors.indicator?.vwap || '#06b6d4',
              width: 2,
              dash: 'solid'
            },
            connectgaps: false,
            hovertemplate: '<b>%{fullData.name}</b><br>' +
                          'Time: %{x|%H:%M:%S}<br>' +
                          'VWAP: ‚Çπ%{y:.2f}<br>' +
                          '<extra></extra>',
            showlegend: true
          });
        }
      }
    }

    if (showIndicators.rsi) {
      let priceData: number[] = [];
      let timeData: Date[] = [];

      if (chartType === 'line') {
        const validData = historicalData?.filter(point => 
          point.ltp !== null && 
          point.ltp !== undefined && 
          point.ltp > 0 && 
          !isNaN(point.ltp)
        ) || [];
        priceData = validData.map(point => Number(point.ltp));
        timeData = validData.slice(14).map(point => new Date(point.timestamp * 1000));
      } else {
        const { close: candleClose, x: candleX } = prepareCandlestickData();
        if (Array.isArray(candleClose)) {
          priceData = candleClose.filter(price => 
            price !== null && price !== undefined && !isNaN(price)
          );
          timeData = Array.isArray(candleX) ? candleX.slice(14) : [];
        }
      }

      if (priceData.length >= 15) {
        const rsiValues = calculateRSI(priceData, 14);
        if (rsiValues && rsiValues.length > 0 && timeData.length === rsiValues.length) {
          plotData.push({
            x: timeData,
            y: rsiValues,
            type: 'scatter',
            mode: 'lines',
            name: 'RSI',
            line: {
              color: colors.indicator?.rsi || '#ec4899',
              width: 2
            },
            yaxis: 'y2',
            connectgaps: false,
            hovertemplate: '<b>%{fullData.name}</b><br>' +
                          'Time: %{x|%H:%M:%S}<br>' +
                          'RSI: %{y:.2f}<br>' +
                          '<extra></extra>',
            showlegend: true
          });

          plotData.push({
            x: timeData,
            y: Array(timeData.length).fill(70),
            type: 'scatter',
            mode: 'lines',
            name: 'Overbought (70)',
            line: {
              color: '#ef4444',
              width: 1,
              dash: 'dash'
            },
            yaxis: 'y2',
            showlegend: false,
            hoverinfo: 'skip'
          });

          plotData.push({
            x: timeData,
            y: Array(timeData.length).fill(30),
            type: 'scatter',
            mode: 'lines',
            name: 'Oversold (30)',
            line: {
              color: '#10b981',
              width: 1,
              dash: 'dash'
            },
            yaxis: 'y2',
            showlegend: false,
            hoverinfo: 'skip'
          });

          plotData.push({
            x: timeData,
            y: Array(timeData.length).fill(50),
            type: 'scatter',
            mode: 'lines',
            name: 'Midline (50)',
            line: {
              color: '#64748b',
              width: 1,
              dash: 'dot'
            },
            yaxis: 'y2',
            showlegend: false,
            hoverinfo: 'skip'
          });
        }
      }
    }

    if (showIndicators.macd) {
      let priceData: number[] = [];
      let timeDataMACD: Date[] = [];
      let timeDataSignal: Date[] = [];

      if (chartType === 'line') {
        const validData = historicalData?.filter(point => 
          point.ltp !== null && 
          point.ltp !== undefined && 
          point.ltp > 0 && 
          !isNaN(point.ltp)
        ) || [];
        priceData = validData.map(point => Number(point.ltp));
        timeDataMACD = validData.slice(25).map(point => new Date(point.timestamp * 1000));
        timeDataSignal = validData.slice(33).map(point => new Date(point.timestamp * 1000));
      } else {
        const { close: candleClose, x: candleX } = prepareCandlestickData();
        if (Array.isArray(candleClose)) {
          priceData = candleClose.filter(price => 
            price !== null && price !== undefined && !isNaN(price)
          );
          timeDataMACD = Array.isArray(candleX) ? candleX.slice(25) : [];
          timeDataSignal = Array.isArray(candleX) ? candleX.slice(33) : [];
        }
      }

      if (priceData.length >= 35) {
        const macdData = calculateMACD(priceData, 12, 26, 9);
        if (macdData && macdData.macdLine && macdData.signalLine && macdData.histogram && 
            timeDataMACD.length === macdData.macdLine.length && 
            timeDataSignal.length === macdData.signalLine.length) {
          plotData.push({
            x: timeDataMACD,
            y: macdData.macdLine,
            type: 'scatter',
            mode: 'lines',
            name: 'MACD',
            line: {
              color: colors.indicator?.macd || '#3b82f6',
              width: 2
            },
            yaxis: showIndicators.rsi ? 'y4' : 'y2',
            connectgaps: false,
            hovertemplate: '<b>%{fullData.name}</b><br>' +
                          'Time: %{x|%H:%M:%S}<br>' +
                          'MACD: %{y:.4f}<br>' +
                          '<extra></extra>',
            showlegend: true
          });

          plotData.push({
            x: timeDataSignal,
            y: macdData.signalLine,
            type: 'scatter',
            mode: 'lines',
            name: 'Signal',
            line: {
              color: '#f59e0b',
              width: 1,
              dash: 'dash'
            },
            yaxis: showIndicators.rsi ? 'y4' : 'y2',
            connectgaps: false,
            hovertemplate: '<b>%{fullData.name}</b><br>' +
                          'Time: %{x|%H:%M:%S}<br>' +
                          'Signal: %{y:.4f}<br>' +
                          '<extra></extra>',
            showlegend: true
          });

          plotData.push({
            x: timeDataSignal,
            y: macdData.histogram,
            type: 'bar',
            name: 'MACD Histogram',
            marker: {
              color: macdData.histogram.map(val => val >= 0 ? '#10b981' : '#ef4444'),
              opacity: 0.7
            },
            yaxis: showIndicators.rsi ? 'y4' : 'y2',
            hovertemplate: '<b>%{fullData.name}</b><br>' +
                          'Time: %{x|%H:%M:%S}<br>' +
                          'Histogram: %{y:.4f}<br>' +
                          '<extra></extra>',
            showlegend: true
          });
        }
      }
    }

    return plotData;
  };

  const createSpreadData = () => {
    const colors = getColorTheme();
    const { x, spread } = prepareLineChartData();

    return [{
      x,
      y: spread,
      type: 'scatter',
      mode: 'lines',
      fill: 'tozeroy',
      line: { color: colors.indicator.spread, width: 1.5 },
      name: 'Bid-Ask Spread',
      hoverinfo: 'y+name',
    }];
  };

  const createBidAskData = () => {
    const colors = getColorTheme();

    if (secondaryView === 'std') {
      const { x, bidStdDev, askStdDev } = calculateBidAskStandardDeviation();
      return [
        {
          x,
          y: bidStdDev,
          type: 'scatter',
          mode: 'lines',
          line: { color: colors.indicator.bid, width: 2 },
          name: 'Bid Std Dev',
          hovertemplate: '<b>%{fullData.name}</b><br>' +
                        'Time: %{x|%H:%M:%S}<br>' +
                        'Std Dev: %{y:.4f}<br>' +
                        '<extra></extra>',
        },
        {
          x,
          y: askStdDev,
          type: 'scatter',
          mode: 'lines',
          line: { color: colors.indicator.ask, width: 2 },
          name: 'Ask Std Dev',
          hovertemplate: '<b>%{fullData.name}</b><br>' +
                        'Time: %{x|%H:%M:%S}<br>' +
                        'Std Dev: %{y:.4f}<br>' +
                        '<extra></extra>',
        }
      ];
    } else {
      const { x, bid, ask } = prepareLineChartData();
      return [
        {
          x,
          y: bid,
          type: 'scatter',
          mode: 'lines',
          line: { color: colors.indicator.bid, width: 2 },
          name: 'Bid Price',
          hoverinfo: 'y+name',
        },
        {
          x,
          y: ask,
          type: 'scatter',
          mode: 'lines',
          line: { color: colors.indicator.ask, width: 2 },
          name: 'Ask Price',
          hoverinfo: 'y+name',
        }
      ];
    }
  };

  const createBuySellLineData = () => {
    const colors = getColorTheme();

    if (secondaryView === 'std') {
      const { x, buyStdDev, sellStdDev } = calculateBuySellStandardDeviation();
      return [
        {
          x,
          y: buyStdDev,
          type: 'scatter',
          mode: 'lines',
          line: { color: colors.indicator.buyPrice, width: 2 },
          name: 'Buy Price Std Dev',
          hovertemplate: '<b>%{fullData.name}</b><br>' +
                        'Time: %{x|%H:%M:%S}<br>' +
                        'Std Dev: %{y:.4f}<br>' +
                        '<extra></extra>',
        },
        {
          x,
          y: sellStdDev,
          type: 'scatter',
          mode: 'lines',
          line: { color: colors.indicator.sellPrice, width: 2 },
          name: 'Sell Price Std Dev',
          hovertemplate: '<b>%{fullData.name}</b><br>' +
                        'Time: %{x|%H:%M:%S}<br>' +
                        'Std Dev: %{y:.4f}<br>' +
                        '<extra></extra>',
        }
      ];
    } else {
      let x: Date[] = [];
      let buyPrices: number[] = [];
      let sellPrices: number[] = [];

      if (chartType === 'line') {
        const data = prepareLineChartData();
        x = data.x;
        buyPrices = data.buyPrices;
        sellPrices = data.sellPrices;
      } else {
        const data = prepareCandlestickData();
        x = data.x;
        buyPrices = data.buyPrices;
        sellPrices = data.sellPrices;
      }

      return [
        {
          x,
          y: buyPrices,
          type: 'scatter',
          mode: 'lines',
          line: { color: colors.indicator.buyPrice, width: 2 },
          name: 'Buy Price',
          hovertemplate: '<b>%{fullData.name}</b><br>' +
                        'Time: %{x|%H:%M:%S}<br>' +
                        'Price: ‚Çπ%{y:.2f}<br>' +
                        '<extra></extra>',
        },
        {
          x,
          y: sellPrices,
          type: 'scatter',
          mode: 'lines',
          line: { color: colors.indicator.sellPrice, width: 2 },
          name: 'Sell Price',
          hovertemplate: '<b>%{fullData.name}</b><br>' +
                        'Time: %{x|%H:%M:%S}<br>' +
                        'Price: ‚Çπ%{y:.2f}<br>' +
                        '<extra></extra>',
        }
      ];
    }
  };

  const createBuySellSpreadData = () => {
    const colors = getColorTheme();
    let x: Date[] = [];
    let buySellSpreads: number[] = [];

    if (chartType === 'line') {
      const data = prepareLineChartData();
      x = data.x;
      buySellSpreads = data.buySellSpreads;
    } else {
      const data = prepareCandlestickData();
      x = data.x;
      buySellSpreads = data.buySellSpreads;
    }

    return [{
      x,
      y: buySellSpreads,
      type: 'scatter',
      mode: 'lines',
      fill: 'tozeroy',
      line: { color: colors.indicator.buySellSpread, width: 1.5 },
      name: 'Buy-Sell Spread',
      hovertemplate: '<b>%{fullData.name}</b><br>' +
                    'Time: %{x|%H:%M:%S}<br>' +
                    'Spread: ‚Çπ%{y:.4f}<br>' +
                    '<extra></extra>',
    }];
  };

  const createVolumeData = () => {
    const colors = getColorTheme();
    let x: Date[] = [];
    let volumes: number[] = [];
    let volumeColors: string[] = [];

    if (chartType === 'line') {
      const data = prepareLineChartData();
      x = data.x;
      volumes = data.allData.map(point => point.volume || 0);

      for (let i = 0; i < data.allData.length; i++) {
        if (i === 0) {
          volumeColors.push(colors.upColor);
        } else {
          const currentPrice = data.allData[i].ltp;
          const prevPrice = data.allData[i - 1].ltp;
          volumeColors.push(currentPrice >= prevPrice ? colors.upColor : colors.downColor);
        }
      }
    } else {
      const data = prepareCandlestickData();
      x = data.x;
      volumes = data.volume;

      for (let i = 0; i < data.close.length; i++) {
        volumeColors.push(data.close[i] >= data.open[i] ? colors.upColor : colors.downColor);
      }
    }

    return [{
      x,
      y: volumes,
      type: 'bar',
      name: 'Volume',
      marker: { 
        color: volumeColors,
        opacity: 0.8 
      },
      hovertemplate: '<b>%{fullData.name}</b><br>' +
                    'Time: %{x|%H:%M:%S}<br>' +
                    'Volume: %{y:,.0f}<br>' +
                    '<extra></extra>',
    }];
  };

  const createStdData = () => {
    const colors = getColorTheme();

    if (mainMode === 'bidAsk') {
      const { x, bidStdDev, askStdDev } = calculateBidAskStandardDeviation();
      return [
        {
          x,
          y: bidStdDev,
          type: 'bar',
          name: 'Bid Volume Std Dev',
          marker: { 
            color: colors.indicator.bid,
            opacity: 0.8 
          },
          hovertemplate: '<b>%{fullData.name}</b><br>' +
                        'Time: %{x|%H:%M:%S}<br>' +
                        'Bid Std Dev: %{y:.4f}<br>' +
                        '<extra></extra>',
        },
        {
          x,
          y: askStdDev,
          type: 'bar',
          name: 'Ask Volume Std Dev',
          marker: { 
            color: colors.indicator.ask,
            opacity: 0.8 
          },
          hovertemplate: '<b>%{fullData.name}</b><br>' +
                        'Time: %{x|%H:%M:%S}<br>' +
                        'Ask Std Dev: %{y:.4f}<br>' +
                        '<extra></extra>',
        }
      ];
    } else if (mainMode === 'buySell') {
      const { x, buyStdDev, sellStdDev } = calculateBuySellStandardDeviation();
      return [
        {
          x,
          y: buyStdDev,
          type: 'bar',
          name: 'Buy Volume Std Dev',
          marker: { 
            color: colors.indicator.buyPrice,
            opacity: 0.8 
          },
          hovertemplate: '<b>%{fullData.name}</b><br>' +
                        'Time: %{x|%H:%M:%S}<br>' +
                        'Buy Std Dev: %{y:.4f}<br>' +
                        '<extra></extra>',
        },
        {
          x,
          y: sellStdDev,
          type: 'bar',
          name: 'Sell Volume Std Dev',
          marker: { 
            color: colors.indicator.sellPrice,
            opacity: 0.8 
          },
          hovertemplate: '<b>%{fullData.name}</b><br>' +
                        'Time: %{x|%H:%M:%S}<br>' +
                        'Sell Std Dev: %{y:.4f}<br>' +
                        '<extra></extra>',
        }
      ];
    } else {
      let x: Date[] = [];
      let volumeStdDev: number[] = [];

      if (chartType === 'line') {
        const data = prepareLineChartData();
        x = data.x;
        volumeStdDev = data.allData.map((point, index) => 
          calculateVolumeStandardDeviation(point, index)
        );
      } else {
        const data = prepareCandlestickData();
        x = data.x;
        volumeStdDev = data.volumeStdDev;
      }

      return [{
        x,
        y: volumeStdDev,
        type: 'bar',
        name: 'Volume Std Dev',
        marker: { 
          color: colors.indicator.std,
          opacity: 0.8 
        },
        hovertemplate: '<b>%{fullData.name}</b><br>' +
                      'Time: %{x|%H:%M:%S}<br>' +
                      'Std Dev: %{y:.4f}<br>' +
                      '<extra></extra>',
      }];
    }
  };

  const createLayout = () => {
    const colors = getColorTheme();
    const yRange = preservedAxisRanges.yaxis ? 
      [preservedAxisRanges.yaxis[0], preservedAxisRanges.yaxis[1]] : 
      undefined;

    const timeRange = preservedAxisRanges.xaxis ? 
      [preservedAxisRanges.xaxis[0], preservedAxisRanges.xaxis[1]] : 
      getTimeRange();

    let mainChartDomain = [0, 1];
    let volumeDomain = [0, 0.2];

    if (chartType === 'line') {
      if (showIndicators.rsi && showIndicators.macd) {
        mainChartDomain = [0.6, 1];
        volumeDomain = [0.25, 0.55];
      } else if (showIndicators.rsi || showIndicators.macd) {
        mainChartDomain = [0.45, 1];
        volumeDomain = [0.1, 0.4];
      } else {
        mainChartDomain = [0.35, 1];
        volumeDomain = [0, 0.3];
      }
    } else {
      if (showIndicators.rsi && showIndicators.macd) {
        mainChartDomain = [0.5, 1];
      } else if (showIndicators.rsi || showIndicators.macd) {
        mainChartDomain = [0.3, 1];
      }
    }

    const layout: any = {
      autosize: true,
      margin: { l: 50, r: 50, t: 40, b: 40 },
      title: {
        text: `${symbol} ${chartType === 'line' ? 'LTP' : 'OHLC'} Chart`,
        font: { size: 16, color: colors.text },
      },
      xaxis: {
        title: 'Time',
        type: 'date',
        range: timeRange,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text },
        titlefont: { color: colors.text },
        rangeslider: { visible: false },
        fixedrange: false,
      },
      yaxis: {
        title: 'Price (‚Çπ)',
        range: yRange,
        autorange: yRange ? false : true,
        fixedrange: false,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text },
        titlefont: { color: colors.text },
        side: 'left',
        domain: mainChartDomain,
      },
      hovermode: 'closest',
      showlegend: true,
      legend: {
        orientation: 'h',
        y: 1.1,
        font: { color: colors.text },
        bgcolor: 'rgba(0,0,0,0)',
      },
      plot_bgcolor: colors.bg,
      paper_bgcolor: colors.paper,
      font: { family: 'Arial, sans-serif', color: colors.text },
    };

    if (chartType === 'line') {
      layout.yaxis3 = {
        title: 'Volume',
        height: 180,
        titlefont: { color: colors.text },
        tickfont: { color: colors.text },
        domain: volumeDomain,
        showgrid: false,
        side: 'right'
      };
    }

    if (showIndicators.rsi) {
      layout.yaxis2 = {
        title: 'RSI',
        titlefont: { color: colors.text },
        tickfont: { color: colors.text },
        domain: showIndicators.macd ? [0.25, 0.45] : [0, 0.25],
        range: [0, 100],
        showgrid: false,
      };
    }

    if (showIndicators.macd) {
      layout.yaxis4 = {
        title: 'MACD',
        titlefont: { color: colors.text },
        tickfont: { color: colors.text },
        domain: [0, 0.2],
        showgrid: false,
      };
    }

    return layout;
  };

  const createSpreadLayout = () => {
    const colors = getColorTheme();
    const timeRange = getTimeRange();
    const spreadRange = calculateSpreadRange();

    return {
      autosize: true,
      height: 150,
      margin: { l: 50, r: 50, t: 30, b: 30 },
      title: {
        text: 'Bid-Ask Spread',
        font: { size: 14, color: colors.text },
      },
      xaxis: {
        title: '',
        type: 'date',
        range: timeRange,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text },
        titlefont: { color: colors.text },
        rangeslider: { visible: false },
        fixedrange: false,
      },
      yaxis: {
        title: 'Spread (‚Çπ)',
        range: spreadRange,
        autorange: false,
        fixedrange: false,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text },
        titlefont: { color: colors.text },
      },
      hovermode: 'closest',
      showlegend: false,
      plot_bgcolor: colors.bg,
      paper_bgcolor: colors.paper,
      font: { family: 'Arial, sans-serif', color: colors.text },
    };
  };

  const createBidAskLayout = () => {
    const colors = getColorTheme();
    const timeRange = getTimeRange();
    let yRange, title;

    if (secondaryView === 'std') {
      const { bidStdDev, askStdDev } = calculateBidAskStandardDeviation();
      const allStdDev = [...bidStdDev, ...askStdDev].filter(v => v !== null && v !== undefined && !isNaN(v));
      const maxStdDev = allStdDev.length > 0 ? Math.max(...allStdDev) : 1;
      yRange = [0, maxStdDev * 1.1];
      title = 'Bid-Ask Standard Deviation';
    } else {
      yRange = calculateBidAskRange();
      title = 'Bid-Ask Prices';
    }

    return {
      autosize: true,
      height: 200,
      margin: { l: 50, r: 50, t: 30, b: 30 },
      title: {
        text: title,
        font: { size: 14, color: colors.text },
      },
      xaxis: {
        title: '',
        type: 'date',
        range: timeRange,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text },
        titlefont: { color: colors.text },
        rangeslider: { visible: false },
        fixedrange: false,
      },
      yaxis: {
        title: secondaryView === 'std' ? 'Std Deviation' : 'Price (‚Çπ)',
        range: yRange,
        autorange: false,
        fixedrange: false,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text },
        titlefont: { color: colors.text },
      },
      hovermode: 'closest',
      showlegend: true,
      legend: {
        orientation: 'h',
        y: 1.1,
        font: { color: colors.text },
        bgcolor: 'rgba(0,0,0,0)',
      },
      plot_bgcolor: colors.bg,
      paper_bgcolor: colors.paper,
      font: { family: 'Arial, sans-serif', color: colors.text },
    };
  };

  const createBuySellLineLayout = () => {
    const colors = getColorTheme();
    const timeRange = getTimeRange();
    let yRange, title;

    if (secondaryView === 'std') {
      const { buyStdDev, sellStdDev } = calculateBuySellStandardDeviation();
      const allStdDev = [...buyStdDev, ...sellStdDev].filter(v => v !== null && v !== undefined && !isNaN(v));
      const maxStdDev = allStdDev.length > 0 ? Math.max(...allStdDev) : 1;
      yRange = [0, maxStdDev * 1.1];
      title = 'Buy-Sell Standard Deviation';
    } else {
      yRange = calculateBuySellRange();
      title = 'Buy-Sell Prices';
    }

    return {
      autosize: true,
      height: 200,
      margin: { l: 50, r: 50, t: 30, b: 30 },
      title: {
        text: title,
        font: { size: 14, color: colors.text },
      },
      xaxis: {
        title: '',
        type: 'date',
        range: timeRange,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text },
        titlefont: { color: colors.text },
        rangeslider: { visible: false },
        fixedrange: false,
      },
      yaxis: {
        title: secondaryView === 'std' ? 'Std Deviation' : 'Price (‚Çπ)',
        range: yRange,
        autorange: false,
        fixedrange: false,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text },
        titlefont: { color: colors.text },
      },
      hovermode: 'closest',
      showlegend: true,
      legend: {
        orientation: 'h',
        y: 1.1,
        font: { color: colors.text },
        bgcolor: 'rgba(0,0,0,0)',
      },
      plot_bgcolor: colors.bg,
      paper_bgcolor: colors.paper,
      font: { family: 'Arial, sans-serif', color: colors.text },
    };
  };

  const createBuySellSpreadLayout = () => {
    const colors = getColorTheme();
    const timeRange = getTimeRange();
    const buySellSpreadRange = calculateBuySellSpreadRange();

    return {
      autosize: true,
      height: 150,
      margin: { l: 50, r: 50, t: 30, b: 30 },
      title: {
        text: 'Buy-Sell Spread',
        font: { size: 14, color: colors.text },
      },
      xaxis: {
        title: '',
        type: 'date',
        range: timeRange,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text },
        titlefont: { color: colors.text },
        rangeslider: { visible: false },
        fixedrange: false,
      },
      yaxis: {
        title: 'Spread (‚Çπ)',
        range: buySellSpreadRange,
        autorange: false,
        fixedrange: false,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text },
        titlefont: { color: colors.text },
      },
      hovermode: 'closest',
      showlegend: false,
      plot_bgcolor: colors.bg,
      paper_bgcolor: colors.paper,
      font: { family: 'Arial, sans-serif', color: colors.text },
    };
  };

  const createVolumeLayout = () => {
    const colors = getColorTheme();
    const timeRange = getTimeRange();
    const volumeRange = calculateVolumeRange();

    return {
      autosize: true,
      height: 180,
      margin: { l: 50, r: 50, t: 30, b: 30 },
      title: {
        text: 'Volume',
        font: { size: 14, color: colors.text },
      },
      xaxis: {
        title: '',
        type: 'date',
        range: timeRange,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text },
        titlefont: { color: colors.text },
        rangeslider: { visible: false },
        fixedrange: false,
      },
      yaxis: {
        title: 'Volume',
        range: volumeRange,
        autorange: false,
        fixedrange: false,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text },
        titlefont: { color: colors.text },
      },
      hovermode: 'closest',
      showlegend: true,
      legend: {
        orientation: 'h',
        y: 1.1,
        font: { color: colors.text },
        bgcolor: 'rgba(0,0,0,0)',
      },
      plot_bgcolor: colors.bg,
      paper_bgcolor: colors.paper,
      font: { family: 'Arial, sans-serif', color: colors.text },
    };
  };

  const createStdLayout = () => {
    const colors = getColorTheme();
    const timeRange = getTimeRange();
    let yRange, title;

    if (mainMode === 'bidAsk') {
      const { bidStdDev, askStdDev } = calculateBidAskStandardDeviation();
      const allStdDev = [...bidStdDev, ...askStdDev].filter(v => v !== null && v !== undefined && !isNaN(v));
      const maxStdDev = allStdDev.length > 0 ? Math.max(...allStdDev) : 1;
      yRange = [0, maxStdDev * 1.1];
      title = 'Bid-Ask Volume Standard Deviation';
    } else if (mainMode === 'buySell') {
      const { buyStdDev, sellStdDev } = calculateBuySellStandardDeviation();
      const allStdDev = [...buyStdDev, ...sellStdDev].filter(v => v !== null && v !== undefined && !isNaN(v));
      const maxStdDev = allStdDev.length > 0 ? Math.max(...allStdDev) : 1;
      yRange = [0, maxStdDev * 1.1];
      title = 'Buy-Sell Volume Standard Deviation';
    } else {
      let volumeStdDev: number[] = [];
      if (chartType === 'line') {
        volumeStdDev = historicalData.map((point, index) => 
          calculateVolumeStandardDeviation(point, index)
        );
      } else {
        const { volumeStdDev: stdDev } = prepareCandlestickData();
        volumeStdDev = stdDev;
      }
      const validStdDev = volumeStdDev.filter(v => v !== null && v !== undefined && !isNaN(v));
      const maxStdDev = validStdDev.length > 0 ? Math.max(...validStdDev) : 1;
      yRange = [0, maxStdDev * 1.1];
      title = 'Volume Standard Deviation';
    }

    return {
      autosize: true,
      height: 180,
      margin: { l: 50, r: 50, t: 30, b: 30 },
      title: {
        text: title,
        font: { size: 14, color: colors.text },
      },
      xaxis: {
        title: '',
        type: 'date',
        range: timeRange,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text },
        titlefont: { color: colors.text },
        rangeslider: { visible: false },
        fixedrange: false,
      },
      yaxis: {
        title: 'Std Deviation',
        range: yRange,
        autorange: false,
        fixedrange: false,
        gridcolor: colors.grid,
        linecolor: colors.grid,
        tickfont: { color: colors.text },
        titlefont: { color: colors.text },
      },
      hovermode: 'closest',
      showlegend: true,
      legend: {
        orientation: 'h',
        y: 1.1,
        font: { color: colors.text },
        bgcolor: 'rgba(0,0,0,0)',
      },
      plot_bgcolor: colors.bg,
      paper_bgcolor: colors.paper,
      font: { family: 'Arial, sans-serif', color: colors.text },
    };
  };

  const timeframeButtons = [
    { label: '1m', value: '1m' },
    { label: '5m', value: '5m' },
    { label: '10m', value: '10m' },
    { label: '30m', value: '30m' },
    { label: '1H', value: '1H' },
    { label: '6H', value: '6H' },
    { label: '12H', value: '12H' },
    { label: '1D', value: '1D' },
  ];

  return (
    <div className="w-full h-full flex flex-col">
      {/* Controls */}
      <div className="flex justify-between mb-2 space-x-2">
        {/* Timeframe Buttons */}
        <div className="flex space-x-1 bg-zinc-900 p-1 rounded-md border border-zinc-700">
          {timeframeButtons.map((button) => (
            <button
              key={button.value}
              className={`px-2 py-1 text-xs rounded ${
                selectedTimeframe === button.value
                  ? `bg-blue-600 text-white`
                  : `bg-zinc-800 text-zinc-300 hover:bg-zinc-700`
              }`}
              onClick={() => handleTimeframeChange(button.value)}
            >
              {button.label}
            </button>
          ))}
        </div>

        <div className="flex space-x-4">
          {/* Chart Type Toggle */}
          <div className="flex space-x-1 bg-zinc-800 p-1 rounded-md border border-zinc-600">
            <button
              className={`p-1 rounded ${
                chartType === 'line' ? 'bg-blue-600 text-white' : 'bg-zinc-700 text-zinc-300 hover:bg-zinc-600'
              }`}
              onClick={() => setChartType('line')}
              title="Line Chart (LTP)"
            >
              <LineChart className="h-5 w-5" />
            </button>
            <button
              className={`p-1 rounded ${
                chartType === 'candle' ? 'bg-blue-600 text-white' : 'bg-zinc-700 text-zinc-300 hover:bg-zinc-600'
              }`}
              onClick={() => setChartType('candle')}
              title="Candlestick Chart (OHLC)"
            >
              <CandlestickChart className="h-5 w-5" />
            </button>
          </div>

          {/* Indicator Toggles */}
          <div className="flex space-x-1 bg-slate-800 p-1 rounded-md border border-slate-600">
            <button
              className={`p-1 rounded ${
                showIndicators.sma20 ? 'bg-orange-600 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
              }`}
              onClick={() => toggleIndicator('sma20')}
              title="SMA 20"
            >
              <span className="text-xs font-bold">SMA</span>
            </button>
            <button
              className={`p-1 rounded ${
                showIndicators.ema9 ? 'bg-purple-600 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
              }`}
              onClick={() => toggleIndicator('ema9')}
              title="EMA 9"
            >
              <span className="text-xs font-bold">EMA</span>
            </button>
            <button
              className={`p-1 rounded ${
                showIndicators.rsi ? 'bg-pink-600 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
              }`}
              onClick={() => toggleIndicator('rsi')}
              title="RSI"
            >
              <span className="text-xs font-bold">RSI</span>
            </button>
            <button
              className={`p-1 rounded ${
                showIndicators.macd ? 'bg-blue-600 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
              }`}
              onClick={() => toggleIndicator('macd')}
              title="MACD"
            >
              <span className="text-xs font-bold">MACD</span>
            </button>
            <button
              className={`p-1 rounded ${
                showIndicators.bb ? 'bg-slate-600 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
              }`}
              onClick={() => toggleIndicator('bb')}
              title="Bollinger Bands"
            >
              <span className="text-xs font-bold">BB</span>
            </button>
            {chartType === 'candle' && (
              <button
                className={`p-1 rounded ${
                  showIndicators.vwap ? 'bg-cyan-600 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
                }`}
                onClick={() => toggleIndicator('vwap')}
                title="VWAP"
              >
                <span className="text-xs font-bold">VWAP</span>
              </button>
            )}
          </div>

          {/* Advanced Analysis Modes */}
          <div className="flex space-x-1 bg-emerald-900 p-1 rounded-md border border-emerald-700">
            <button
              className={`p-1 rounded ${
                mainMode === 'bidAsk' ? 'bg-green-600 text-white' : 'bg-emerald-800 text-emerald-300 hover:bg-emerald-700'
              }`}
              onClick={() => toggleMainMode('bidAsk')}
              title="Bid/Ask Analysis"
            >
              <span className="text-xs font-bold">B/A</span>
            </button>
            <button
              className={`p-1 rounded ${
                mainMode === 'buySell' ? 'bg-emerald-600 text-white' : 'bg-emerald-800 text-emerald-300 hover:bg-emerald-700'
              }`}
              onClick={() => toggleMainMode('buySell')}
              title="Buy/Sell Analysis"
            >
              <span className="text-xs font-bold">B/S</span>
            </button>

            {/* Secondary View Options */}
            {mainMode !== 'none' && (
              <>
                <div className="w-px h-6 bg-emerald-600 mx-1"></div>
                <button
                  className={`p-1 rounded ${
                    secondaryView === 'line' ? 'bg-blue-500 text-white' : 'bg-emerald-700 text-emerald-400 hover:bg-emerald-600'
                  }`}
                  onClick={() => toggleSecondaryView('line')}
                  title="Line View"
                >
                  <span className="text-xs font-bold">Line</span>
                </button>
                <button
                  className={`p-1 rounded ${
                    secondaryView === 'spread' ? 'bg-purple-500 text-white' : 'bg-emerald-700 text-emerald-400 hover:bg-emerald-600'
                  }`}
                  onClick={() => toggleSecondaryView('spread')}
                  title="Spread View"
                >
                  <span className="text-xs font-bold">Spread</span>
                </button>
                <button
                  className={`p-1 rounded ${
                    secondaryView === 'std' ? 'bg-orange-500 text-white' : 'bg-emerald-700 text-emerald-400 hover:bg-emerald-600'
                  }`}
                  onClick={() => toggleSecondaryView('std')}
                  title="Standard Deviation View"
                >
                  <span className="text-xs font-bold">STD</span>
                </button>
              </>
            )}
          </div>

          {/* Volume Toggle */}
          <div className="flex space-x-1 bg-amber-900 p-1 rounded-md border border-amber-700">
            <button
              className={`p-1 rounded ${
                showIndicators.volume ? 'bg-amber-600 text-white' : 'bg-amber-800 text-amber-300 hover:bg-amber-700'
              }`}
              onClick={() => toggleIndicator('volume')}
              title="Volume Chart"
            >
              VOL
            </button>
          </div>
        </div>
      </div>

      {/* Main Chart */}
      <div className="flex-1">
        <Plot
          ref={chartRef}
          divId="plotly-chart"
          data={createPlotData()}
          layout={createLayout()}
          config={{
            responsive: true,
            displayModeBar: false,
            scrollZoom: true,
            doubleClick: 'reset',
          }}
          useResizeHandler={true}
          style={{ width: '100%', height: '100%' }}
          onRelayout={handleRelayout}
        />
      </div>

      {/* Secondary Charts */}
      {mainMode === 'bidAsk' && secondaryView === 'line' && (
        <div className="mt-2">
          <Plot
            ref={bidAskChartRef}
            divId="bid-ask-chart"
            data={createBidAskData()}
            layout={createBidAskLayout()}
            config={{
              responsive: true,
              displayModeBar: false,
              scrollZoom: true,
              doubleClick: 'reset',
            }}
            useResizeHandler={true}
            style={{ width: '100%', height: '200px' }}
          />
        </div>
      )}

      {mainMode === 'bidAsk' && secondaryView === 'spread' && (
        <div className="mt-2">
          <Plot
            ref={spreadChartRef}
            divId="spread-chart"
            data={createSpreadData()}
            layout={createSpreadLayout()}
            config={{
              responsive: true,
              displayModeBar: false,
              scrollZoom: true,
              doubleClick: 'reset',
            }}
            useResizeHandler={true}
            style={{ width: '100%', height: '150px' }}
          />
        </div>
      )}

      {mainMode === 'buySell' && secondaryView === 'line' && (
        <div className="mt-2">
          <Plot
            ref={buySellLineChartRef}
            divId="buy-sell-line-chart"
            data={createBuySellLineData()}
            layout={createBuySellLineLayout()}
            config={{
              responsive: true,
              displayModeBar: false,
              scrollZoom: true,
              doubleClick: 'reset',
            }}
            useResizeHandler={true}
            style={{ width: '100%', height: '200px' }}
          />
        </div>
      )}

      {mainMode === 'buySell' && secondaryView === 'spread' && (
        <div className="mt-2">
          <Plot
            ref={buySellSpreadChartRef}
            divId="buy-sell-spread-chart"
            data={createBuySellSpreadData()}
            layout={createBuySellSpreadLayout()}
            config={{
              responsive: true,
              displayModeBar: false,
              scrollZoom: true,
              doubleClick: 'reset',
            }}
            useResizeHandler={true}
            style={{ width: '100%', height: '150px' }}
          />
        </div>
      )}

      {mainMode !== 'none' && secondaryView === 'std' && (
        <div className="mt-2">
          <Plot
            ref={buySellVolumeChartRef}
            divId="buy-sell-volume-chart"
            data={createStdData()}
            layout={createStdLayout()}
            config={{
              responsive: true,
              displayModeBar: false,
              scrollZoom: true,
              doubleClick: 'reset',
            }}
            useResizeHandler={true}
            style={{ width: '100%', height: '180px' }}
          />
        </div>
      )}

      {showIndicators.volume && (
        <div className="mt-2">
          <Plot
            ref={volumeChartRef}
            divId="volume-chart"
            data={createVolumeData()}
            layout={createVolumeLayout()}
            config={{
              responsive: true,
              displayModeBar: false,
              scrollZoom: true,
              doubleClick: 'reset',
            }}
            useResizeHandler={true}
            style={{ width: '100%', height: '180px' }}
          />
        </div>
      )}

      {/* Status Display */}
      <div className="mt-2 flex items-center space-x-4 text-sm">
        <div className={`flex items-center space-x-2 ${tradingHours.isActive ? 'text-green-400' : 'text-red-400'}`}>
          <div className={`w-2 h-2 rounded-full ${tradingHours.isActive ? 'bg-green-400 animate-pulse' : 'bg-red-400'}`}></div>
          <span>{tradingHours.isActive ? 'Market Open' : 'Market Closed'}</span>
        </div>
      </div>
    </div>
  );
};

export default PlotlyChart;


================================================================================
FILE 18/37: apps/frontend/app/market-data/components/charts/ApexChart.tsx
CATEGORY: Charts - ApexCharts Integration
PURPOSE: ApexCharts component implementation
PRIORITY: ?? IMPORTANT
================================================================================


'use client';
import React, { useEffect, useState } from 'react';
import dynamic from 'next/dynamic';
// Import ApexCharts with dynamic loading (no SSR)
const ReactApexChart = dynamic(() => import('react-apexcharts'), { ssr: false });
interface MarketData {
  ltp: number;
  timestamp: number;
}
interface ApexChartProps {
  symbol: string;
  data: MarketData | null | undefined;
  height?: number;
  width?: string;
}
const ApexChart: React.FC<ApexChartProps> = ({ 
  symbol, 
  data, 
  height = 500, 
  width = '100%' 
}) => {
  const [isClient, setIsClient] = useState(false);
  const [chartData, setChartData] = useState<[number, number][]>([]);
  const [options, setOptions] = useState<any>({
    chart: {
      id: 'market-chart',
      type: 'line',
      height: height,
      toolbar: {
        show: true,
        tools: {
          download: true,
          selection: true,
          zoom: true,
          zoomin: true,
          zoomout: true,
          pan: true,
          reset: true
        },
        autoSelected: 'zoom'
      },
      animations: {
        enabled: true,
        easing: 'linear',
        dynamicAnimation: {
          speed: 1000
        }
      },
      background: 'transparent',
    },
    stroke: {
      curve: 'smooth',
      width: 2,
    },
    colors: ['#2962FF'],
    title: {
      text: `${symbol} Price Chart`,
      align: 'left',
      style: {
        fontSize: '16px',
        fontWeight: 'bold',
        color: '#333'
      }
    },
    grid: {
      borderColor: '#f1f1f1',
      row: {
        colors: ['transparent', 'transparent'],
        opacity: 0.5
      }
    },
    xaxis: {
      type: 'datetime',
      labels: {
        datetimeUTC: false,
        format: 'HH:mm:ss',
      },
      title: {
        text: 'Time',
        style: {
          fontSize: '12px',
          fontWeight: 'normal'
        }
      }
    },
    yaxis: {
      title: {
        text: 'Price (‚Çπ)',
        style: {
          fontSize: '12px',
          fontWeight: 'normal'
        }
      },
      labels: {
        formatter: (value: number) => `‚Çπ${value.toFixed(2)}`
      }
    },
    tooltip: {
      x: {
        format: 'dd MMM yyyy HH:mm:ss'
      },
      y: {
        formatter: (value: number) => `‚Çπ${value.toFixed(2)}`
      },
      theme: 'light'
    },
    markers: {
      size: 0,
      hover: {
        size: 5
      }
    },
    dataLabels: {
      enabled: false
    },
    legend: {
      show: true,
      position: 'top',
      horizontalAlign: 'right'
    }
  });
  useEffect(() => {
    setIsClient(true);
    const now = Date.now();
    const initialData: [number, number][] = [];
    for (let i = 10; i > 0; i--) {
      initialData.push([now - i * 60000, data?.ltp || 100 + Math.random() * 10]);
    }
    setChartData(initialData);
    setOptions(prevOptions => ({
      ...prevOptions,
      title: {
        ...prevOptions.title,
        text: `${symbol} Price Chart`
      }
    }));
  }, [symbol, data?.ltp]);
  useEffect(() => {
    if (!isClient || !data || typeof data.ltp !== 'number' || typeof data.timestamp !== 'number') {
      return;
    }
    try {
      const timestamp = data.timestamp * 1000;
      setChartData(prevData => {
        const existingIndex = prevData.findIndex(point => point[0] === timestamp);
        if (existingIndex >= 0) {
          const newData = [...prevData];
          newData[existingIndex] = [timestamp, data.ltp];
          return newData;
        } else {
          const newData = [...prevData, [timestamp, data.ltp]];
          if (newData.length > 300) {
            return newData.slice(-300);
          }
          return newData;
        }
      });
    } catch (error) {
      console.error('Error updating ApexChart:', error);
    }
  }, [data, isClient]);
  if (!isClient) {
    return (
      <div className="w-full h-[500px] bg-gray-100 flex items-center justify-center">
        <div className="text-gray-500">Loading chart...</div>
      </div>
    );
  }
  const series = [{
    name: symbol,
    data: chartData
  }];
  return (
    <div className="relative w-full h-full border border-gray-200 rounded shadow-sm bg-white overflow-hidden">
      {chartData.length > 0 ? (
        <ReactApexChart 
          options={options} 
          series={series} 
          type="line" 
          height={height} 
          width={width}
        />
      ) : (
        <div className="absolute inset-0 flex items-center justify-center">
          <div className="text-gray-500">Waiting for market data...</div>
        </div>
      )}
    </div>
  );
};
export default ApexChart;



================================================================================
FILE 19/37: apps/frontend/app/market-data/components/charts/SyncfusionChart.tsx
CATEGORY: Charts - Syncfusion Integration
PURPOSE: Syncfusion chart component implementation
PRIORITY: ?? IMPORTANT
================================================================================


'use client';
import React, { useEffect, useState } from 'react';
import dynamic from 'next/dynamic';
const ChartComponents = dynamic(
  () => import('./SyncfusionChartComponents'),
  { ssr: false, loading: () => (
    <div className="w-full h-[500px] bg-gray-100 flex items-center justify-center">
      <div className="text-gray-500">Loading chart components...</div>
    </div>
  )}
);
interface MarketData {
  ltp: number;
  timestamp: number;
}
interface SyncfusionChartProps {
  symbol: string;
  data: MarketData | null | undefined;
  height?: number;
}
const SyncfusionChart: React.FC<SyncfusionChartProps> = ({ 
  symbol, 
  data, 
  height = 500 
}) => {
  const [isClient, setIsClient] = useState(false);
  const [chartData, setChartData] = useState<any[]>([]);
  useEffect(() => {
    setIsClient(true);
    const now = new Date();
    const initialData = Array.from({ length: 10 }, (_, i) => ({
      x: new Date(now.getTime() - (10 - i) * 60000),
      open: data?.ltp || 100 + Math.random() * 10,
      high: (data?.ltp || 100) + Math.random() * 15,
      low: (data?.ltp || 100) - Math.random() * 5,
      close: data?.ltp || 100 + Math.random() * 10,
      volume: Math.floor(Math.random() * 1000)
    }));
    setChartData(initialData);
  }, [data?.ltp]);
  useEffect(() => {
    if (!isClient || !data || typeof data.ltp !== 'number' || typeof data.timestamp !== 'number') {
      return;
    }
    try {
      const date = new Date(data.timestamp * 1000);
      setChartData(prevData => {
        const existingIndex = prevData.findIndex(
          point => point.x.getTime() === date.getTime()
        );
        if (existingIndex >= 0) {
          const newData = [...prevData];
          const prevPoint = newData[existingIndex];
          newData[existingIndex] = {
            ...prevPoint,
            close: data.ltp,
            high: Math.max(prevPoint.high, data.ltp),
            low: Math.min(prevPoint.low, data.ltp)
          };
          return newData;
        } else {
          const prevClose = prevData.length > 0 ? prevData[prevData.length - 1].close : data.ltp;
          const newPoint = {
            x: date,
            close: data.ltp,
            open: prevClose,
            high: Math.max(prevClose, data.ltp),
            low: Math.min(prevClose, data.ltp),
            volume: 0
          };
          const newData = [...prevData, newPoint];
          if (newData.length > 300) {
            return newData.slice(-300);
          }
          return newData;
        }
      });
    } catch (error) {
      console.error('Error updating SyncfusionChart:', error);
    }
  }, [data, isClient]);
  if (!isClient) {
    return (
      <div className="w-full h-[500px] bg-gray-100 flex items-center justify-center">
        <div className="text-gray-500">Loading chart...</div>
      </div>
    );
  }
  return (
    <div className="relative w-full border border-gray-200 rounded shadow-sm bg-white overflow-hidden" style={{ height }}>
      {chartData.length > 0 ? (
        <ChartComponents 
          data={chartData}
          height={height}
          symbol={symbol}
        />
      ) : (
        <div className="absolute inset-0 flex items-center justify-center">
          <div className="text-gray-500">Waiting for market data...</div>
        </div>
      )}
    </div>
  );
};
export default SyncfusionChart;



================================================================================
FILE 20/37: apps/frontend/app/market-data/components/charts/FinancialChart.tsx
CATEGORY: Charts - Financial Chart
PURPOSE: Financial chart component for market data
PRIORITY: ?? IMPORTANT
================================================================================

//
// // Dynamic import to avoid SSR issues
//
//
//     const initialData = Array.from({ length: 10 }, (_, i) => ({
//
//
//
//
//
//
//



################################################################################
?? SECTION 5: IMPORTANT FILES - DATA MANAGEMENT
################################################################################

================================================================================
FILE 21/37: apps/frontend/hooks/useStockData.ts
CATEGORY: Data Management - Stock Data Hook
PURPOSE: Stock data fetching and state management
PRIORITY: ?? IMPORTANT
================================================================================


import { useState, useCallback, useRef, useEffect } from 'react';
interface StockDataPoint {
  interval_start: string;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
}
interface DataCache {
  [key: string]: StockDataPoint[];
}
interface UseStockDataParams {
  companyCode: string | null;
  exchange?: string;
  interval?: string;
  indicators?: string[];
  enableIncrementalLoading?: boolean;
}
export function useStockData({ 
  companyCode,
  exchange = 'NSE',
  interval = '1m',
  indicators = [],
  enableIncrementalLoading = true
}: UseStockDataParams) {
  const [data, setData] = useState<StockDataPoint[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [dataRange, setDataRange] = useState<{ start: Date | null; end: Date | null }>({ start: null, end: null });
  const abortControllerRef = useRef<AbortController | null>(null);
  const cacheRef = useRef<DataCache>({});
  const loadingQueueRef = useRef<Set<string>>(new Set());
  const getCacheKey = useCallback((company: string, start: Date, end: Date, interval: string) => {
    return `${company}_${interval}_${start.getTime()}_${end.getTime()}`;
  }, []);
  const getCachedData = useCallback((start: Date, end: Date) => {
    const key = getCacheKey(companyCode || '', start, end, interval);
    return cacheRef.current[key] || null;
  }, [getCacheKey, companyCode, interval]);
  const setCachedData = useCallback((start: Date, end: Date, data: StockDataPoint[]) => {
    const key = getCacheKey(companyCode || '', start, end, interval);
    cacheRef.current[key] = data;
  }, [getCacheKey, companyCode, interval]);
  const fetchData = useCallback(async (
    startDate?: Date, 
    endDate?: Date, 
    options: { 
      fetchAllData?: boolean;
      merge?: boolean;
      priority?: 'high' | 'normal';
    } = {}
  ) => {
    if (!companyCode) {
      setError('No company selected');
      return [];
    }
    const { fetchAllData = false, merge = false, priority = 'normal' } = options;
    if (!startDate && !fetchAllData) {
      setError('Either provide a start date or set fetchAllData to true');
      return [];
    }
    const requestKey = `${companyCode}_${startDate?.getTime()}_${endDate?.getTime()}`;
    if (loadingQueueRef.current.has(requestKey)) {
      console.log('Request already in progress, skipping duplicate:', requestKey);
      return [];
    }
    if (startDate && endDate && enableIncrementalLoading) {
      const cachedData = getCachedData(startDate, endDate);
      if (cachedData) {
        console.log('Returning cached data for range:', startDate, endDate);
        if (merge) {
          setData(prevData => mergeData(prevData, cachedData));
        } else {
          setData(cachedData);
        }
        return cachedData;
      }
    }
    if (abortControllerRef.current && priority !== 'high') {
      abortControllerRef.current.abort();
    }
    loadingQueueRef.current.add(requestKey);
    setLoading(true);
    setError(null);
    try {
      abortControllerRef.current = new AbortController();
      const queryParams = new URLSearchParams({
        exchange,
        interval,
        ...indicators.length > 0 && { indicators: indicators.join(',') }
      });
      if (startDate) {
        queryParams.append('startDate', startDate.toISOString());
        queryParams.append('endDate', endDate?.toISOString() || new Date(startDate.getTime() + 6.25 * 60 * 60 * 1000).toISOString());
      } else {
        queryParams.append('fetchAllData', 'true');
      }
      const url = `/api/companies/${companyCode}/ohlcv?${queryParams.toString()}`;
      console.log(`Fetching stock data: ${url}`);
      const response = await fetch(url, { 
        signal: abortControllerRef.current.signal,
        headers: {
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache'
        }
      });
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      const jsonData = await response.json() as StockDataPoint[];
      console.log(`Successfully fetched ${jsonData.length} data points`);
      if (startDate && endDate && enableIncrementalLoading) {
        setCachedData(startDate, endDate, jsonData);
      }
      if (jsonData.length > 0) {
        const newStart = new Date(jsonData[0].interval_start);
        const newEnd = new Date(jsonData[jsonData.length - 1].interval_start);
        setDataRange(prev => ({
          start: prev.start ? (newStart < prev.start ? newStart : prev.start) : newStart,
          end: prev.end ? (newEnd > prev.end ? newEnd : prev.end) : newEnd
        }));
      }
      if (merge) {
        setData(prevData => mergeData(prevData, jsonData));
      } else {
        setData(jsonData);
      }
      return jsonData;
    } catch (err: any) {
      if (err.name === 'AbortError') {
        console.log('Request was aborted');
        return [];
      }
      console.error('Error fetching stock data:', err);
      setError(`Failed to fetch stock data: ${err.message}`);
      return [];
    } finally {
      loadingQueueRef.current.delete(requestKey);
      setLoading(false);
    }
  }, [companyCode, exchange, interval, indicators, enableIncrementalLoading, getCachedData, setCachedData]);
  const mergeData = useCallback((existing: StockDataPoint[], newData: StockDataPoint[]): StockDataPoint[] => {
    const combined = [...existing, ...newData];
    const uniqueMap = new Map<string, StockDataPoint>();
    combined.forEach(item => {
      uniqueMap.set(item.interval_start, item);
    });
    return Array.from(uniqueMap.values()).sort((a, b) => 
      new Date(a.interval_start).getTime() - new Date(b.interval_start).getTime()
    );
  }, []);
  const fetchIncrementalData = useCallback(async (start: Date, end: Date) => {
    return fetchData(start, end, { merge: true, priority: 'high' });
  }, [fetchData]);
  const fetchAllData = useCallback(async () => {
    return fetchData(undefined, undefined, { fetchAllData: true });
  }, [fetchData]);
  const clearData = useCallback(() => {
    setData([]);
    setError(null);
    setDataRange({ start: null, end: null });
    cacheRef.current = {};
    loadingQueueRef.current.clear();
  }, []);
  const loadDataForRange = useCallback(async (visibleStart: Date, visibleEnd: Date) => {
    if (!enableIncrementalLoading) return;
    const buffer = 30 * 60 * 1000;
    const expandedStart = new Date(visibleStart.getTime() - buffer);
    const expandedEnd = new Date(visibleEnd.getTime() + buffer);
    const gaps = [];
    if (!dataRange.start || expandedStart < dataRange.start) {
      gaps.push({
        start: expandedStart,
        end: dataRange.start || visibleStart
      });
    }
    if (!dataRange.end || expandedEnd > dataRange.end) {
      gaps.push({
        start: dataRange.end || visibleEnd,
        end: expandedEnd
      });
    }
    for (const gap of gaps) {
      await fetchIncrementalData(gap.start, gap.end);
    }
  }, [enableIncrementalLoading, dataRange, fetchIncrementalData]);
  useEffect(() => {
    clearData();
  }, [companyCode, clearData]);
  return { 
    data, 
    loading, 
    error, 
    dataRange,
    fetchData, 
    fetchAllData, 
    fetchIncrementalData,
    loadDataForRange,
    clearData 
  };
}



================================================================================
FILE 22/37: apps/frontend/app/market-data/components/MarketDataTable.tsx
CATEGORY: Data Management - Data Table
PURPOSE: Market data table display component
PRIORITY: ?? IMPORTANT
================================================================================

import React from 'react';
interface MarketData {
  ltp: number;
  change: number;
  changePercent: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
  timestamp: number;
}
interface MarketDataTableProps {
  data: Record<string, MarketData>;
  onSymbolSelect: (symbol: string) => void;
  onRemoveSymbol: (symbol: string) => void;
  selectedSymbol: string;
}
const MarketDataTable: React.FC<MarketDataTableProps> = ({
  data,
  onSymbolSelect,
  onRemoveSymbol,
  selectedSymbol,
}) => {
  return (
    <div className="overflow-x-auto">
      <table className="w-full">
        <thead>
          <tr className="border-b">
            <th className="text-left py-2">Symbol</th>
            <th className="text-right py-2">LTP</th>
            <th className="text-right py-2">Change</th>
            <th className="text-right py-2">%Change</th>
            <th className="text-right py-2">Volume</th>
            <th className="text-center py-2">Actions</th>
          </tr>
        </thead>
        <tbody>
          {Object.entries(data).map(([symbol, marketData]) => (
            <tr 
              key={symbol}
              className={`border-b hover:bg-muted/50 cursor-pointer ${
                selectedSymbol === symbol ? 'bg-muted' : ''
              }`}
              onClick={() => onSymbolSelect(symbol)}
            >
              <td className="py-3 font-medium">{symbol}</td>
              <td className="text-right py-3">{marketData.ltp.toFixed(2)}</td>
              <td 
                className={`text-right py-3 ${
                  marketData.change >= 0 ? 'text-green-500' : 'text-red-500'
                }`}
              >
                {marketData.change >= 0 ? '+' : ''}
                {marketData.change.toFixed(2)}
              </td>
              <td 
                className={`text-right py-3 ${
                  marketData.changePercent >= 0 ? 'text-green-500' : 'text-red-500'
                }`}
              >
                {marketData.changePercent >= 0 ? '+' : ''}
                {marketData.changePercent.toFixed(2)}%
              </td>
              <td className="text-right py-3">{marketData.volume.toLocaleString()}</td>
              <td className="text-center py-3">
                <button
                  className="text-red-500 hover:text-red-700"
                  onClick={(e) => {
                    e.stopPropagation();
                    onRemoveSymbol(symbol);
                  }}
                >
                  Remove
                </button>
              </td>
            </tr>
          ))}
          {Object.keys(data).length === 0 && (
            <tr>
              <td colSpan={6} className="py-4 text-center text-muted-foreground">
                No symbols in watchlist. Add symbols to get started.
              </td>
            </tr>
          )}
        </tbody>
      </table>
    </div>
  );
};
export default MarketDataTable;



================================================================================
FILE 23/37: apps/backend/src/stock/stocks.service.ts
CATEGORY: Data Management - Stock Service
PURPOSE: Stock data business logic and processing
PRIORITY: ?? IMPORTANT
================================================================================

import { Injectable, InternalServerErrorException, RequestTimeoutException, Logger, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { StockData } from './entities/stock.entity';
import { StockDataDto, StockDataRequestDto } from './dto/stock-data.dto';
import { exec } from 'child_process';
import * as path from 'path';

interface CacheEntry {
  data: StockDataDto[];
  timestamp: number;
  startDate: Date;
  endDate: Date;
  interval: string;
  companyCode: string;
}

interface DataGap {
  start: Date;
  end: Date;
  type: 'before' | 'after' | 'within';
}

@Injectable()
export class StockService {
  private readonly logger = new Logger(StockService.name);
  private readonly dataCache = new Map<string, CacheEntry>();
  private readonly cacheTTL = 5 * 60 * 1000; // 5 minutes cache TTL
  private readonly maxCacheSize = 100; // Maximum cache entries
  private readonly pendingRequests = new Map<string, Promise<StockDataDto[]>>();

  constructor(
    @InjectRepository(StockData)
    private stockRepository: Repository<StockData>,
  ) {
    setInterval(() => this.cleanupCache(), 60 * 1000); // Every minute
  }

 
  async getTop5Companies() {
    return this.stockRepository
      .createQueryBuilder('stock')
      .select('stock.company_code', 'companyCode')
      .addSelect('stock.exchange', 'exchange')
      .addSelect('AVG(stock.close)', 'averageClose')
      .where('stock.exchange IN (:...exchanges)', { exchanges: ['NSE', 'BSE'] })
      .groupBy('stock.company_code, stock.exchange')
      .orderBy('"averageClose"', 'DESC')
      .limit(5)
      .getRawMany();
  }

  async getCompanyHistory(companyCode: string, exchange?: string) {
    const queryBuilder = this.stockRepository
      .createQueryBuilder('stock')
      .where('stock.company_code = :companyCode', { companyCode });
    
    if (exchange) {
      queryBuilder.andWhere('stock.exchange = :exchange', { exchange });
    } else {
      queryBuilder.andWhere('stock.exchange IN (:...exchanges)', { exchanges: ['NSE', 'BSE'] });
    }
    
    return queryBuilder
      .orderBy('stock.date', 'ASC')
      .getMany();
  }


  async getStockDataFromPython(params: StockDataRequestDto): Promise<StockDataDto[]> {
    try {
      this.validateRequest(params);
      
      const startTime = Date.now();
      this.logger.log(`Fetching stock data for ${params.companyCode} from ${params.startDate} to ${params.endDate}`);

      const cachedData = this.getCachedData(params);
      if (cachedData) {
        this.logger.log(`Serving data from cache for ${params.companyCode}`);
        return cachedData;
      }

      const requestKey = this.generateRequestKey(params);
      const pendingRequest = this.pendingRequests.get(requestKey);
      if (pendingRequest) {
        this.logger.log(`Request already pending for ${requestKey}, waiting...`);
        return await pendingRequest;
      }

      const dataPromise = this.executeStockDataFetch(params);
      this.pendingRequests.set(requestKey, dataPromise);

      try {
        const data = await dataPromise;
        
        this.setCachedData(params, data);
        
        this.logger.log(`Successfully fetched ${data.length} data points for ${params.companyCode} in ${Date.now() - startTime}ms`);
        return data;
        
      } finally {
        this.pendingRequests.delete(requestKey);
      }

    } catch (error) {
      this.logger.error(`Error fetching stock data for ${params.companyCode}:`, error);
      throw error;
    }
  }


  private async executeStockDataFetch(params: StockDataRequestDto): Promise<StockDataDto[]> {
    return new Promise((resolve, reject) => {
      const scriptPath = path.resolve(__dirname, '../../data/data_fetch.py');

      let command = `python ${scriptPath} --company_code=${params.companyCode} --interval=${params.interval}`;

      if (params.exchange) {
        command += ` --exchange=${params.exchange}`;
      } else {
        command += ` --exchange=NSE,BSE`;
      }

      /**
       * CRITICAL: Date handling for IST timezone
       * The Python script expects naive datetime strings in IST timezone.
       * Format: "YYYY-MM-DD HH:MM:SS"
       * 
       * The dates coming from params are JavaScript Date objects which could be:
       * 1. Already in IST (if frontend sends IST dates)
       * 2. In UTC (if frontend sends ISO strings)
       * 3. In local timezone (if frontend sends local dates)
       * 
       * We need to ensure the dates are correctly interpreted as IST dates.
       */
      const formatDateForPython = (date: Date, hour: number, minute: number): string => {
        // Create a date string treating the input date as IST
        // We extract year, month, day from the Date object and construct an IST datetime
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hourStr = String(hour).padStart(2, '0');
        const minuteStr = String(minute).padStart(2, '0');
        
        return `${year}-${month}-${day} ${hourStr}:${minuteStr}:00`;
      };

      if (params.startDate && params.endDate) {
        // Market hours in IST: 9:15 AM to 3:45 PM
        const startStr = formatDateForPython(params.startDate, 9, 15);
        const endStr = formatDateForPython(params.endDate, 15, 45);

        this.logger.log(`Date range requested: ${params.startDate.toDateString()} to ${params.endDate.toDateString()}`);
        this.logger.log(`Sending to Python: start="${startStr}", end="${endStr}"`);

        command += ` --start_date="${startStr}" --end_date="${endStr}"`;
        command += ' --optimize_for_range=true';

        const bufferMinutes = this.getBufferMinutes(params.interval);
        command += ` --buffer_minutes=${bufferMinutes}`;

        if (params.firstFifteenMinutes) {
          command += ' --first_fifteen_minutes=true';
        }
      } else {
        command += ' --fetch_all_data=true';
        command += ' --limit=2500';
      }

      command += ' --enable_cache=true';
      command += ' --compression=true';
      command += ' --validate_data=true';

      if (params.indicators && params.indicators.length > 0) {
        command += ` --indicators="${params.indicators.join(',')}"`;
      }

      this.logger.debug(`Executing optimized command: ${command}`);

      const timeout = this.getTimeoutForRange(params);

      const timeoutId = setTimeout(() => {
        this.logger.error(`Python script execution timed out after ${timeout}ms`);
        reject(new RequestTimeoutException('Data fetch request timed out. Please try a smaller date range.'));
      }, timeout);

      const childProcess = exec(command, {
        maxBuffer: 1024 * 1024 * 100,
        timeout: timeout,
        cwd: path.resolve(__dirname, '../../data')
      }, (error, stdout, stderr) => {
        clearTimeout(timeoutId);

        if (error) {
          this.logger.error(`Python script execution failed: ${error.message}`);

          if (typeof error.code === 'string' && error.code === 'ENOENT') {
            return reject(new InternalServerErrorException('Python environment not configured properly'));
          }

          if (error.signal === 'SIGTERM') {
            return reject(new RequestTimeoutException('Request was cancelled due to timeout'));
          }

          return reject(new InternalServerErrorException(`Failed to fetch stock data: ${error.message}`));
        }

        if (stderr) {
          const lines = stderr.split('\n').filter(line => line.trim());

          const actualErrors: string[] = [];
          const warnings: string[] = [];
          const infoMessages: string[] = [];

          for (const line of lines) {
            const lowerLine = line.toLowerCase();

            if (
              lowerLine.includes('error:') ||
              lowerLine.includes('traceback') ||
              lowerLine.includes('exception:') ||
              lowerLine.includes('failed:') ||
              lowerLine.includes('critical:') ||
              lowerLine.includes('database connection failed') ||
              lowerLine.includes('no company found') ||
              lowerLine.startsWith('error ')
            ) {
              actualErrors.push(line);
            } else if (
              lowerLine.includes('warning') ||
              lowerLine.includes('userwarning') ||
              lowerLine.includes('deprecation') ||
              (lowerLine.includes('skipped') && lowerLine.includes('invalid'))
            ) {
              warnings.push(line);
            } else if (
              lowerLine.includes('fetching') ||
              lowerLine.includes('data range:') ||
              lowerLine.includes('successfully') ||
              lowerLine.includes('query executed') ||
              (lowerLine.includes('found') && lowerLine.includes('company')) ||
              lowerLine.includes('looking up') ||
              (lowerLine.includes('applied') && lowerLine.includes('buffer')) ||
              lowerLine.includes('processing') ||
              lowerLine.includes('completed') ||
              lowerLine.includes('data points') ||
              lowerLine.includes('querying') ||
              lowerLine.includes('filtered to') ||
              lowerLine.includes('adjusted for') ||
              lowerLine.includes('records for company') ||
              (lowerLine.includes('in ') && lowerLine.includes('s'))
            ) {
              infoMessages.push(line);
            } else if (line.trim()) {
              warnings.push(line);
            }
          }

          if (infoMessages.length > 0) {
            this.logger.log(`Python script info: ${infoMessages.join('; ')}`);
          }

          if (warnings.length > 0) {
            this.logger.warn(`Python script warnings: ${warnings.join('; ')}`);
          }

          if (actualErrors.length > 0) {
            this.logger.error(`Python script errors: ${actualErrors.join('; ')}`);
            return reject(new InternalServerErrorException('Data processing failed with errors'));
          }
        }

        try {
          const results = this.parseOptimizedOutput(stdout, params);

          if (results.length === 0) {
            this.logger.warn(`No data found for ${params.companyCode} in the specified range`);
            return resolve([]);
          }

          const processedResults = this.processAndValidateData(results, params);

          this.logger.log(`Successfully processed ${processedResults.length} data points for ${params.companyCode}`);
          resolve(processedResults);

        } catch (parseError) {
          this.logger.error(`Error parsing Python script output:`, parseError);
          this.logger.debug(`Raw stdout: ${stdout.substring(0, 1000)}...`);
          reject(new InternalServerErrorException('Failed to parse stock data. Data format may be invalid.'));
        }
      });

      childProcess.on('error', (error) => {
        clearTimeout(timeoutId);
        this.logger.error(`Child process error: ${error.message}`);
        reject(new InternalServerErrorException(`Data fetch process failed: ${error.message}`));
      });

      childProcess.on('exit', (code, signal) => {
        if (code !== 0 && code !== null) {
          this.logger.error(`Python script exited with code ${code}`);
        }
        if (signal) {
          this.logger.warn(`Python script terminated by signal ${signal}`);
        }
      });
    });
  }

  
  private parseOptimizedOutput(stdout: string, params: StockDataRequestDto): StockDataDto[] {
    const lines = stdout.trim().split('\n');
    const results: StockDataDto[] = [];
    let errorCount = 0;
    const maxErrors = 10; 
    
    for (const line of lines) {
      if (line.startsWith('Interval:')) {
        try {
          const parts = line.split(',');
          
          if (parts.length < 6) {
            throw new Error(`Insufficient data fields: expected 6, got ${parts.length}`);
          }
          
          const intervalPart = parts[0].replace('Interval:', '').trim();
          const openPart = parseFloat(parts[1].replace('Open:', '').trim());
          const highPart = parseFloat(parts[2].replace('High:', '').trim());
          const lowPart = parseFloat(parts[3].replace('Low:', '').trim());
          const closePart = parseFloat(parts[4].replace('Close:', '').trim());
          const volumePart = parts[5] ? parseFloat(parts[5].replace('Volume:', '').trim()) : 0;
          
          if (isNaN(openPart) || isNaN(highPart) || isNaN(lowPart) || isNaN(closePart)) {
            throw new Error('Invalid numeric values detected');
          }
          
          if (highPart < Math.max(openPart, closePart) || lowPart > Math.min(openPart, closePart)) {
            throw new Error('Invalid OHLC relationship');
          }
          
          const timestamp = new Date(intervalPart);
          if (isNaN(timestamp.getTime())) {
            throw new Error('Invalid timestamp format');
          }
          
          // Note: Date filtering is already done in Python, but we keep this as safety
          if (params.startDate && params.endDate) {
            // Create date-only comparison to avoid time-of-day issues
            const timestampDateOnly = new Date(timestamp.getFullYear(), timestamp.getMonth(), timestamp.getDate());
            const startDateOnly = new Date(params.startDate.getFullYear(), params.startDate.getMonth(), params.startDate.getDate());
            const endDateOnly = new Date(params.endDate.getFullYear(), params.endDate.getMonth(), params.endDate.getDate());
            
            if (timestampDateOnly < startDateOnly || timestampDateOnly > endDateOnly) {
              continue; 
            }
          }
          
          results.push({
            interval_start: timestamp,
            open: this.roundToDecimalPlaces(openPart, 2),
            high: this.roundToDecimalPlaces(highPart, 2),
            low: this.roundToDecimalPlaces(lowPart, 2),
            close: this.roundToDecimalPlaces(closePart, 2),
            volume: Math.max(0, Math.round(volumePart)), 
          });
          
        } catch (err) {
          errorCount++;
          this.logger.warn(`Skipping invalid data line (${errorCount}/${maxErrors}): ${line.substring(0, 100)} - Error: ${(err as Error).message}`);
          
          if (errorCount >= maxErrors) {
            throw new Error(`Too many parsing errors (${errorCount}). Data quality may be poor.`);
          }
        }
      } else if (line.startsWith('ERROR:') || line.startsWith('FATAL:')) {
        throw new Error(`Python script error: ${line}`);
      }
    }
    
    if (errorCount > 0) {
      this.logger.warn(`Parsed data with ${errorCount} errors for ${params.companyCode}`);
    }
    
    return results;
  }

 
  private processAndValidateData(data: StockDataDto[], params: StockDataRequestDto): StockDataDto[] {
    if (data.length === 0) return data;
    
    data.sort((a, b) => a.interval_start.getTime() - b.interval_start.getTime());
    
    const uniqueData = data.filter((item, index, array) => 
      index === 0 || item.interval_start.getTime() !== array[index - 1].interval_start.getTime()
    );
    
    if (params.firstFifteenMinutes && uniqueData.length > 0) {
      const startTime = new Date(uniqueData[0].interval_start);
      const endTime = new Date(startTime.getTime() + 15 * 60 * 1000); 
      
      const filteredResults = uniqueData.filter(item => {
        const itemTime = new Date(item.interval_start);
        return itemTime >= startTime && itemTime <= endTime;
      });
      
      this.logger.log(`Filtered to first 15 minutes: ${filteredResults.length} data points`);
      return filteredResults;
    }
    
    const gaps = this.detectDataGaps(uniqueData, params.interval);
    if (gaps.length > 0) {
      this.logger.warn(`Detected ${gaps.length} data gaps for ${params.companyCode}`);
    }
    
    return uniqueData;
  }

 
  private generateRequestKey(params: StockDataRequestDto): string {
    const dateKey = params.startDate && params.endDate 
      ? `${params.startDate.getTime()}-${params.endDate.getTime()}`
      : 'all';
    
    const firstFifteenKey = params.firstFifteenMinutes ? '_first15' : '';
    const indicatorsKey = params.indicators?.length > 0 ? `_${params.indicators.join(',')}` : '';
    
    return `${params.companyCode}_${params.interval}_${params.exchange || 'NSE-BSE'}_${dateKey}${firstFifteenKey}${indicatorsKey}`;
  }

  private getCachedData(params: StockDataRequestDto): StockDataDto[] | null {
    const key = this.generateRequestKey(params);
    const cached = this.dataCache.get(key);
    
    if (!cached) return null;
    
    if (Date.now() - cached.timestamp > this.cacheTTL) {
      this.dataCache.delete(key);
      return null;
    }
    
    if (params.startDate && params.endDate) {
      if (cached.startDate > params.startDate || cached.endDate < params.endDate) {
        return null; 
      }
    }
    
    return cached.data;
  }

  private setCachedData(params: StockDataRequestDto, data: StockDataDto[]): void {
    if (data.length === 0) return;
    
    const key = this.generateRequestKey(params);
    
    if (this.dataCache.size >= this.maxCacheSize) {
      const oldestKey = this.dataCache.keys().next().value;
      this.dataCache.delete(oldestKey);
    }
    
    const cacheEntry: CacheEntry = {
      data,
      timestamp: Date.now(),
      startDate: params.startDate || data[0].interval_start,
      endDate: params.endDate || data[data.length - 1].interval_start,
      interval: params.interval,
      companyCode: params.companyCode
    };
    
    this.dataCache.set(key, cacheEntry);
  }

  private cleanupCache(): void {
    const now = Date.now();
    const keysToDelete: string[] = [];
    
    for (const [key, entry] of this.dataCache.entries()) {
      if (now - entry.timestamp > this.cacheTTL) {
        keysToDelete.push(key);
      }
    }
    
    keysToDelete.forEach(key => this.dataCache.delete(key));
    
    if (keysToDelete.length > 0) {
      this.logger.debug(`Cleaned up ${keysToDelete.length} expired cache entries`);
    }
  }

  private detectDataGaps(data: StockDataDto[], interval: string): DataGap[] {
    if (data.length < 2) return [];
    
    const gaps: DataGap[] = [];
    const expectedInterval = this.getIntervalInMs(interval);
    
    for (let i = 1; i < data.length; i++) {
      const timeDiff = data[i].interval_start.getTime() - data[i-1].interval_start.getTime();
      
      if (timeDiff > expectedInterval * 1.5) { 
        gaps.push({
          start: data[i-1].interval_start,
          end: data[i].interval_start,
          type: 'within'
        });
      }
    }
    
    return gaps;
  }

  private validateRequest(params: StockDataRequestDto): void {
    if (!params.companyCode) {
      throw new BadRequestException('Company code is required');
    }
    
    if (!params.interval) {
      throw new BadRequestException('Interval is required');
    }
    
    if (params.startDate && params.endDate) {
      // Compare only the date parts, not the time
      const startDateOnly = new Date(params.startDate.getFullYear(), params.startDate.getMonth(), params.startDate.getDate());
      const endDateOnly = new Date(params.endDate.getFullYear(), params.endDate.getMonth(), params.endDate.getDate());
      
      if (startDateOnly > endDateOnly) {
        throw new BadRequestException('Start date must be before or equal to end date');
      }
    }
    
    if (params.startDate && params.endDate) {
      const daysDiff = (params.endDate.getTime() - params.startDate.getTime()) / (1000 * 60 * 60 * 24);
      const maxDays = this.getMaxDaysForInterval(params.interval);
      
      if (daysDiff > maxDays) {
        throw new BadRequestException(`Date range too large for interval ${params.interval}. Maximum ${maxDays} days allowed.`);
      }
    }
  }

  private getBufferMinutes(interval: string): number {
    const bufferMap: { [key: string]: number } = {
      '1m': 15,
      '5m': 60,
      '15m': 180,
      '1h': 720,
      '1d': 1440
    };
    return bufferMap[interval] || 30;
  }

  private getTimeoutForRange(params: StockDataRequestDto): number {
    const baseTimeout = 60000; 
    
    if (!params.startDate || !params.endDate) {
      return 300000; 
    }
    
    const daysDiff = (params.endDate.getTime() - params.startDate.getTime()) / (1000 * 60 * 60 * 24);
    return Math.round(Math.min(baseTimeout + (daysDiff * 2000), 300000));
  }

  private getMaxDaysForInterval(interval: string): number {
    const maxDaysMap: { [key: string]: number } = {
      '1m': 365,
      '5m': 365,
      '15m': 365,
      '1h': 365,
      '1d': 1825 // 5 years
    };
    return maxDaysMap[interval] || 30;
  }

  private getIntervalInMs(interval: string): number {
    const intervalMap: { [key: string]: number } = {
      '1m': 60 * 1000,
      '5m': 5 * 60 * 1000,
      '15m': 15 * 60 * 1000,
      '1h': 60 * 60 * 1000,
      '1d': 24 * 60 * 60 * 1000
    };
    return intervalMap[interval] || 60 * 1000;
  }

  private roundToDecimalPlaces(value: number, places: number): number {
    return Math.round(value * Math.pow(10, places)) / Math.pow(10, places);
  }

  public clearCache(): void {
    this.dataCache.clear();
    this.pendingRequests.clear();
    this.logger.log('Stock data cache and pending requests cleared');
  }

  public getCacheStats(): any {
    return {
      size: this.dataCache.size,
      maxSize: this.maxCacheSize,
      ttl: this.cacheTTL,
      pendingRequests: this.pendingRequests.size,
      entries: Array.from(this.dataCache.entries()).map(([key, entry]) => ({
        key,
        companyCode: entry.companyCode,
        interval: entry.interval,
        dataPoints: entry.data.length,
        age: Date.now() - entry.timestamp,
        dateRange: `${entry.startDate.toISOString()} - ${entry.endDate.toISOString()}`
      }))
    };
  }

  async getIncrementalData(
    companyCode: string,
    startDate: Date,
    endDate: Date,
    interval: string,
    exchange?: string,
    indicators: string[] = []
  ): Promise<StockDataDto[]> {
    const params: StockDataRequestDto = {
      companyCode,
      startDate,
      endDate,
      interval,
      exchange,
      firstFifteenMinutes: false,
      indicators
    };

    return this.getStockDataFromPython(params);
  }
}

################################################################################
?? SECTION 6: IMPORTANT FILES - LAYOUT AND UI
################################################################################

================================================================================
FILE 24/37: apps/frontend/app/layout.tsx
CATEGORY: Layout - Root Layout
PURPOSE: Root application layout component
PRIORITY: ?? IMPORTANT
================================================================================

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { ThemeProvider } from "./components/theme-provider";
const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});
const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});
export const metadata: Metadata = {
 title: "DAKSphere",
  description: "Dashboard for your stock goals",
};
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <ThemeProvider
            attribute="class"
            defaultTheme="system"
            enableSystem
            disableTransitionOnChange
          >
            {children}
          </ThemeProvider>
      </body>
    </html>
  );
}



================================================================================
FILE 25/37: apps/frontend/app/components/shared-layout.tsx
CATEGORY: Layout - Shared Layout
PURPOSE: Shared layout wrapper component
PRIORITY: ?? IMPORTANT
================================================================================



================================================================================
FILE 26/37: apps/frontend/components/ui/button.tsx
CATEGORY: UI Component - Button
PURPOSE: Reusable button component
PRIORITY: ?? IMPORTANT
================================================================================

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }


================================================================================
FILE 27/37: apps/frontend/components/ui/card.tsx
CATEGORY: UI Component - Card
PURPOSE: Reusable card component
PRIORITY: ?? IMPORTANT
================================================================================

import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }


################################################################################
?? SECTION 7: OPTIONAL FILES - REFERENCE FILES
################################################################################

================================================================================
FILE 28/37: apps/backend/src/live-market/live-market.service.ts
CATEGORY: Reference - Live Market Service
PURPOSE: Live market service for reference implementation
PRIORITY: ?? OPTIONAL
================================================================================

import { Injectable, Logger } from '@nestjs/common';
import { WatchlistService } from '../watchlist/watchlist.service';
import { SubscribeCompaniesDto, UnsubscribeDto } from './dto/live-market.dto';

@Injectable()
export class LiveMarketService {
  private readonly logger = new Logger(LiveMarketService.name);
  private readonly MAX_COMPANIES = 6;

  constructor(private readonly watchlistService: WatchlistService) {}

  async getAvailableCompanies(watchlist: string = 'A') {
    try {
      const companies = await this.watchlistService.getWatchlistData(watchlist);
      
      const availableCompanies = companies.map(company => ({
        company_code: company.company_code,
        name: company.name,
        exchange: company.exchange,
        marker: company.marker,
        symbol: `${company.exchange}:${company.company_code}-${company.marker}`,
        metadata: {
          total_valid_days: company.total_valid_days,
          avg_daily_high_low_range: company.avg_daily_high_low_range,
          median_daily_volume: company.median_daily_volume,
          pe_ratio: company.pe_ratio
        }
      }));

      return {
        success: true,
        companies: availableCompanies,
        total: availableCompanies.length,
        maxSelection: this.MAX_COMPANIES,
        watchlist
      };
    } catch (error) {
      this.logger.error(`Error fetching available companies: ${error.message}`);
      return {
        success: false,
        error: error.message,
        companies: [],
        total: 0,
        maxSelection: this.MAX_COMPANIES,
        watchlist
      };
    }
  }

  getMarketStatus() {
    const now = new Date();
    const istNow = new Date(now.getTime() + (5.5 * 60 * 60 * 1000)); // Convert to IST
    
    const marketOpen = new Date(istNow);
    marketOpen.setHours(9, 15, 0, 0);
    
    const marketClose = new Date(istNow);
    marketClose.setHours(15, 30, 0, 0);
    
    const isWeekend = istNow.getDay() === 0 || istNow.getDay() === 6;
    const isMarketHours = !isWeekend && istNow >= marketOpen && istNow <= marketClose;

    return {
      current_time: istNow.toISOString(),
      market_open: marketOpen.toISOString(),
      market_close: marketClose.toISOString(),
      is_trading_hours: isMarketHours,
      is_weekend: isWeekend,
      timezone: 'Asia/Kolkata'
    };
  }

  async subscribeToCompanies(subscribeDto: SubscribeCompaniesDto) {
    try {
      const { companyCodes, clientId } = subscribeDto;

      if (!Array.isArray(companyCodes)) {
        throw new Error('companyCodes must be an array');
      }

      if (companyCodes.length === 0) {
        throw new Error('At least 1 company must be selected');
      }

      if (companyCodes.length > this.MAX_COMPANIES) {
        throw new Error(`Maximum ${this.MAX_COMPANIES} companies allowed`);
      }

      // Validate company codes exist in watchlist
      const availableCompanies = await this.getAvailableCompanies();

      // Solution 1: Check the 'success' property before accessing 'companies'
      if (!availableCompanies.success) {
        throw new Error(`Failed to get available companies: ${availableCompanies.error}`);
      }

      const validCompanyCodes = availableCompanies.companies.map(c => c.company_code);

      const invalidCodes = companyCodes.filter(code => !validCompanyCodes.includes(code));
      if (invalidCodes.length > 0) {
        throw new Error(`Invalid company codes: ${invalidCodes.join(', ')}`);
      }

      // Build symbols
      const symbols = companyCodes.map(code => {
        const company = (availableCompanies.companies as any[]).find(c => c.company_code === code);

        return company?.symbol;
      }).filter(Boolean);

      return {
        success: true,
        message: `Subscribed to ${symbols.length} companies`,
        symbols,
        companyCodes,
        clientId
      };
    } catch (error) {
      this.logger.error(`Error subscribing to companies: ${error.message}`);
      return {
        success: false,
        error: error.message
      };
    }
  }

  async unsubscribeFromCompanies(unsubscribeDto: UnsubscribeDto) {
    try {
      const { clientId } = unsubscribeDto;

      return {
        success: true,
        message: 'Unsubscribed from all companies',
        clientId
      };
    } catch (error) {
      this.logger.error(`Error unsubscribing: ${error.message}`);
      return {
        success: false,
        error: error.message
      };
    }
  }

  async getHistoricalData(symbol: string, date?: string) {
    try {
      // This would typically fetch from your data source
      // For now, return a placeholder response
      return {
        success: true,
        symbol,
        date: date || new Date().toISOString().split('T')[0],
        data: [],
        message: 'Historical data endpoint - connect to your data source'
      };
    } catch (error) {
      this.logger.error(`Error fetching historical data: ${error.message}`);
      return {
        success: false,
        error: error.message
      };
    }
  }
}


================================================================================
FILE 29/37: apps/frontend/app/live-market/page.tsx
CATEGORY: Reference - Live Market Page
PURPOSE: Live market page for reference implementation
PRIORITY: ?? OPTIONAL
================================================================================

'use client';
import React, { useState, useEffect, useCallback } from 'react';
import { AppSidebar } from "../components/app-sidebar";
import {
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
  BreadcrumbSeparator,
} from "@/components/ui/breadcrumb";
import { Separator } from "@/components/ui/separator";
import {
  SidebarInset,
  SidebarProvider,
  SidebarTrigger,
} from "@/components/ui/sidebar";
import { ModeToggle } from "../components/toggleButton";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import LiveMarketGrid from './components/LiveMarketGrid';
import { MultiSelectWatchlistSelector } from '../components/controllers/WatchlistSelector/MultiSelectWatchlistSelector';
import { FyersAuthStatus } from '../components/FyersAuthStatus';
import { useLiveMarket } from '../../hooks/useLiveMarket';
import { 
  Info, 
  Activity, 
  Users, 
  TrendingUp, 
  Shield, 
  AlertCircle,
  CheckCircle,
  XCircle 
} from 'lucide-react';

interface Company {
  company_id?: number;
  company_code: string;
  name: string;
  exchange: string;
  marker?: string;
  symbol?: string;
}

interface AuthStatus {
  authenticated: boolean;
  token_valid: boolean;
  expires_at: string | null;
  services_notified: string[];
}

const LiveMarketPage: React.FC = () => {
  const {
    availableCompanies,
    selectedCompanies: liveMarketSelectedCompanies,
    marketData,
    marketStatus,
    connectionStatus,
    error,
    loading,
    subscribeToCompanies,
    unsubscribeAll,
    isConnected
  } = useLiveMarket();

  const [selectedCompanies, setSelectedCompanies] = useState<Company[]>([]);
  const [selectedDate, setSelectedDate] = useState<string | null>(null);
  const [authStatus, setAuthStatus] = useState<AuthStatus | null>(null);
  const [authLoading, setAuthLoading] = useState(true);

  const fetchAuthStatus = useCallback(async () => {
    try {
      setAuthLoading(true);
      const response = await fetch('/api/auth/fyers/status');
      const data = await response.json();
      setAuthStatus(data);
    } catch (error) {
      console.error('Failed to fetch auth status:', error);
      setAuthStatus(null);
    } finally {
      setAuthLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchAuthStatus();
    const interval = setInterval(fetchAuthStatus, 30000);
    return () => clearInterval(interval);
  }, [fetchAuthStatus]);

  const handleCompaniesSelect = useCallback((companies: Company[]) => {
    console.log('üîç Companies selected in LiveMarketPage:', companies);
    setSelectedCompanies(companies);

    if (!authStatus?.authenticated || !authStatus?.token_valid) {
      console.warn('‚ö†Ô∏è Cannot subscribe: Fyers authentication required');
      return;
    }

    if (companies.length > 0) {
      console.log('üì° Subscribing to companies:', companies);
      subscribeToCompanies(companies);
    } else {
      console.log('üì° No companies selected, unsubscribing from all');
      unsubscribeAll();
    }
  }, [subscribeToCompanies, unsubscribeAll, authStatus]);

  const handleDateChange = useCallback((date: string) => {
    console.log('Date changed to:', date);
    setSelectedDate(date);
    setSelectedCompanies([]);
    unsubscribeAll();
  }, [unsubscribeAll]);

  const handleClearSelection = useCallback(() => {
    console.log('üì° Clearing all selections');
    setSelectedCompanies([]);
    unsubscribeAll();
  }, [unsubscribeAll]);

  const gridSelectedCompanies = React.useMemo(() => {
    return selectedCompanies.map(company => ({
      ...company,
      symbol: company.symbol || `${company.exchange}:${company.company_code}-${company.marker || 'EQ'}`
    }));
  }, [selectedCompanies]);

  useEffect(() => {
    console.log('üîç LiveMarketPage State Update:', {
      selectedCompanies: selectedCompanies.length,
      liveMarketSelectedCompanies: liveMarketSelectedCompanies.length,
      marketDataKeys: Object.keys(marketData),
      isConnected,
      loading,
      error,
      authStatus: authStatus?.authenticated,
      selectedDate
    });
  }, [selectedCompanies, liveMarketSelectedCompanies, marketData, isConnected, loading, error, authStatus, selectedDate]);

  const getAuthStatusDisplay = () => {
    if (authLoading) {
      return { icon: Activity, color: 'text-blue-500', text: 'Checking...' };
    }
    if (!authStatus) {
      return { icon: XCircle, color: 'text-red-500', text: 'Unknown' };
    }
    if (authStatus.authenticated && authStatus.token_valid) {
      return { icon: CheckCircle, color: 'text-green-500', text: 'Active' };
    } else if (authStatus.authenticated) {
      return { icon: AlertCircle, color: 'text-yellow-500', text: 'Expired' };
    } else {
      return { icon: XCircle, color: 'text-red-500', text: 'Required' };
    }
  };

  const authDisplay = getAuthStatusDisplay();
  const AuthIcon = authDisplay.icon;

  return (
    <SidebarProvider>
      <AppSidebar />
      <SidebarInset>
        <header className="flex h-16 shrink-0 items-center gap-2 w-full">
          <div className="flex items-center gap-2 px-4">
            <SidebarTrigger className="-ml-1" />
            <Separator orientation="vertical" className="mr-2 h-4" />
            <Breadcrumb className="flex items-center justify-end gap-2">
              <BreadcrumbList>
                <BreadcrumbItem className="hidden md:block">
                  <BreadcrumbLink href="#">
                    Real-Time Market Data
                  </BreadcrumbLink>
                </BreadcrumbItem>
                <BreadcrumbSeparator className="hidden md:block" />
                <BreadcrumbItem>
                  <BreadcrumbPage>Live Market Grid</BreadcrumbPage>
                </BreadcrumbItem>
              </BreadcrumbList>
              <ModeToggle />
            </Breadcrumb>
          </div>
        </header>

        <div className="flex flex-1 flex-col gap-4 p-4 pt-0">
          <Card className="w-full">
            <CardHeader>
              <div className="flex items-center justify-between">
                <div>
                  <CardTitle className="flex items-center gap-2">
                    <TrendingUp className="h-5 w-5" />
                    Live Market Data Grid
                  </CardTitle>
                  {selectedDate && (
                    <p className="text-sm text-muted-foreground mt-1">
                      Showing data for {new Date(selectedDate).toLocaleDateString('en-IN', { 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric' 
                      })}
                    </p>
                  )}
                </div>
                <div className="flex items-center gap-6">
                  {/* Auth Status */}
                  <div className="flex items-center gap-2 px-3 py-1 rounded-full bg-muted/50">
                    <Shield className="w-4 h-4 text-muted-foreground" />
                    <AuthIcon className={`w-4 h-4 ${authDisplay.color}`} />
                    <span className="text-sm font-medium">
                      Auth: {authDisplay.text}
                    </span>
                  </div>

                  {/* Connection Status */}
                  <div className="flex items-center gap-2">
                    <div className={`w-2 h-2 rounded-full ${
                      isConnected ? 'bg-green-500' : 'bg-red-500'
                    }`} />
                    <span className="text-sm font-medium">
                      {connectionStatus}
                    </span>
                  </div>

                  {/* Market Status */}
                  {marketStatus?.trading_active && (
                    <Badge variant="default" className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-100">
                      <Activity className="w-3 h-3 mr-1" />
                      Market Open
                    </Badge>
                  )}
                  {!marketStatus?.trading_active && !marketStatus?.is_market_day && (
                    <Badge variant="secondary">
                      Market Closed
                    </Badge>
                  )}
                </div>
              </div>
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
                {/* Main Content Area */}
                <div className="lg:col-span-3 space-y-4">
                  <div className="flex justify-between items-center">
                    {/* Selection Stats */}
                    {selectedCompanies.length > 0 && (
                      <div className="flex items-center gap-4">
                        <div className="flex flex-col items-end gap-1 text-sm text-muted-foreground">
                          <div className="flex items-center gap-1">
                            <Users className="w-4 h-4" />
                            <span>{selectedCompanies.length} companies selected</span>
                          </div>
                          <div className="flex items-center gap-1">
                            <Activity className="w-4 h-4" />
                            <span>{Object.keys(marketData).length} receiving data</span>
                          </div>
                        </div>
                        <Button 
                          variant="outline" 
                          size="sm" 
                          onClick={handleClearSelection}
                          disabled={loading}
                        >
                          {loading ? 'Clearing...' : 'Clear Selection'}
                        </Button>
                      </div>
                    )}
                  </div>

                  <MultiSelectWatchlistSelector
                    onCompaniesSelect={handleCompaniesSelect}
                    onDateChange={handleDateChange}
                    maxSelection={6}
                    selectedCompanies={selectedCompanies}
                    showExchangeFilter={true}
                    showMarkerFilter={true}
                    showDateSelector={true}
                    disabled={!authStatus?.authenticated || !authStatus?.token_valid}
                  />

                  {/* Auth Warning */}
                  {(!authStatus?.authenticated || !authStatus?.token_valid) && (
                    <div className="bg-yellow-50 dark:bg-yellow-950/20 border border-yellow-200 dark:border-yellow-800 text-yellow-700 dark:text-yellow-400 px-3 py-2 rounded-md text-sm">
                      ‚ö†Ô∏è Authentication required to select companies and view live data
                    </div>
                  )}

                  {/* Loading Indicator */}
                  {loading && (
                    <div className="flex items-center gap-2 text-sm text-muted-foreground">
                      <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-primary"></div>
                      <span>Subscribing to market data...</span>
                    </div>
                  )}

                  {/* Error Display */}
                  {error && (
                    <div className="bg-red-50 dark:bg-red-950/20 border border-red-200 dark:border-red-800 text-red-700 dark:text-red-400 px-3 py-2 rounded-md text-sm">
                      ‚ùå {error}
                    </div>
                  )}
                </div>

                {/* Sidebar - Auth Status */}
                <div className="lg:col-span-1">
                  <FyersAuthStatus />
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Live Market Grid - When Companies Selected and Authenticated */}
          {selectedCompanies.length > 0 && authStatus?.authenticated && authStatus?.token_valid && (
            <LiveMarketGrid
              selectedCompanies={gridSelectedCompanies}
              marketData={marketData}
              connectionStatus={connectionStatus}
              loading={loading}
            />
          )}

          {/* Auth Required Message */}
          {selectedCompanies.length > 0 && (!authStatus?.authenticated || !authStatus?.token_valid) && (
            <Card className="w-full">
              <CardContent className="flex flex-col items-center justify-center py-12">
                <Shield className="h-12 w-12 text-yellow-500 mb-4" />
                <h3 className="text-lg font-medium mb-2">Authentication Required</h3>
                <p className="text-sm text-muted-foreground text-center max-w-md mb-6">
                  You have selected {selectedCompanies.length} companies, but Fyers authentication is required to view live market data.
                </p>
                <div className="flex gap-3">
                  <FyersAuthStatus />
                </div>
              </CardContent>
            </Card>
          )}

          {/* Empty State */}
          {selectedCompanies.length === 0 && (
            <Card className="w-full">
              <CardContent className="flex flex-col items-center justify-center py-12">
                <TrendingUp className="h-12 w-12 text-muted-foreground mb-4" />
                <h3 className="text-lg font-medium mb-2">No Companies Selected</h3>
                <p className="text-sm text-muted-foreground text-center max-w-md">
                  Select a date and choose 1-6 companies from your watchlist above to start monitoring their real-time market data in an interactive grid layout.
                  {!authStatus?.authenticated && " Note: Fyers authentication is required for live data."}
                </p>
              </CardContent>
            </Card>
          )}
        </div>
      </SidebarInset>
    </SidebarProvider>
  );
};

export default LiveMarketPage;


================================================================================
FILE 30/37: apps/backend/data/fyers_data.py
CATEGORY: Reference - Python Data Fetcher
PURPOSE: Main Python data fetching script
PRIORITY: ?? OPTIONAL
================================================================================

import eventlet
eventlet.monkey_patch()

import socketio
import json
import sys
import time
import datetime
import pytz
import threading
import logging
import requests
import numpy as np
import os
from collections import deque, defaultdict
from fyers_apiv3 import fyersModel
from fyers_apiv3.FyersWebsocket import data_ws

logging.basicConfig(
    level=logging.WARNING,
    format='%(asctime)s - %(levelname)s - %(message)s',
)
logger = logging.getLogger("FyersServer")

sio = socketio.Server(cors_allowed_origins='*', async_mode='eventlet')
app = socketio.WSGIApp(sio)

client_id = "150HUKJSWG-100"
secret_key = "18YYNXCAS7"
redirect_uri = "https://raghavjaiswal709.github.io/DAKSphere_redirect/"
response_type = "code"
grant_type = "authorization_code"

clients = {}
symbol_to_clients = {}
running = True

# ============ ENHANCED: Multi-symbol persistent data storage ============
historical_data = {}           # All historical data for all symbols
ohlc_data = {}                # All OHLC data for all symbols
chart_updates = {}            # Real-time updates for all symbols
active_symbols = set()        # All symbols currently being tracked
symbol_subscriptions = defaultdict(int)  # Count of clients per symbol

MAX_HISTORY_POINTS = 50000    # Increased from 10000 for longer retention
MAX_CHART_UPDATES = 5000      # Keep more chart updates
DATA_RETENTION_HOURS = 24     # Keep data for 24 hours

INDIA_TZ = pytz.timezone('Asia/Kolkata')

fyers = None
fyers_client = None

# ============ ENHANCED: Real-time Configuration ============
REAL_TIME_INTERVAL = 0.2
CHART_UPDATE_INTERVAL = 0.1
last_emit_time = defaultdict(float)
pending_data = {}

# ============ ENHANCED: Persistent data management ============
cached_indicators = {}
data_cleanup_interval = 3600  # Cleanup every hour
last_cleanup_time = time.time()

def cleanup_old_data():
    """Remove data older than DATA_RETENTION_HOURS"""
    global last_cleanup_time
    current_time = time.time()
    cutoff_time = current_time - (DATA_RETENTION_HOURS * 3600)

    if current_time - last_cleanup_time < data_cleanup_interval:
        return

    logger.info("Starting data cleanup...")
    cleaned_symbols = []

    for symbol in list(historical_data.keys()):
        if symbol in historical_data:
            # Keep only recent data
            recent_data = deque(maxlen=MAX_HISTORY_POINTS)
            for point in historical_data[symbol]:
                if point['timestamp'] > cutoff_time:
                    recent_data.append(point)

            if len(recent_data) > 0:
                historical_data[symbol] = recent_data
            else:
                # Remove completely old symbols that have no subscribers
                if symbol_subscriptions[symbol] == 0:
                    del historical_data[symbol]
                    cleaned_symbols.append(symbol)

        if symbol in ohlc_data:
            # Keep only recent OHLC data
            recent_ohlc = deque(maxlen=MAX_HISTORY_POINTS)
            for candle in ohlc_data[symbol]:
                if candle['timestamp'] > cutoff_time:
                    recent_ohlc.append(candle)

            if len(recent_ohlc) > 0:
                ohlc_data[symbol] = recent_ohlc
            elif symbol_subscriptions[symbol] == 0:
                if symbol in ohlc_data:
                    del ohlc_data[symbol]

        if symbol in chart_updates:
            # Keep only recent chart updates
            recent_updates = deque(maxlen=MAX_CHART_UPDATES)
            for update in chart_updates[symbol]:
                if update['timestamp'] > cutoff_time:
                    recent_updates.append(update)

            if len(recent_updates) > 0:
                chart_updates[symbol] = recent_updates
            elif symbol_subscriptions[symbol] == 0:
                if symbol in chart_updates:
                    del chart_updates[symbol]

    # Clean up cached indicators for removed symbols
    for symbol in cleaned_symbols:
        if symbol in cached_indicators:
            del cached_indicators[symbol]
        active_symbols.discard(symbol)

    last_cleanup_time = current_time
    logger.info(f"Data cleanup completed. Cleaned {len(cleaned_symbols)} old symbols.")

def get_trading_hours():
    now = datetime.datetime.now(INDIA_TZ)
    start_time = now.replace(hour=9, minute=15, second=0, microsecond=0)
    end_time = now.replace(hour=15, minute=30, second=0, microsecond=0)
    return start_time, end_time

def is_trading_hours():
    now = datetime.datetime.now(INDIA_TZ)
    start_time, end_time = get_trading_hours()

    if now.weekday() >= 5:
        return False

    return start_time <= now <= end_time

@sio.event
def connect(sid, environ):
    logger.info(f"Client connected: {sid}")
    clients[sid] = {'subscriptions': set(), 'last_ping': time.time()}

@sio.event
def disconnect(sid):
    logger.info(f"Client disconnected: {sid}")
    if sid in clients:
        # Decrease subscription count for each symbol
        for symbol in clients[sid]['subscriptions']:
            if symbol in symbol_to_clients:
                symbol_to_clients[symbol].discard(sid)
            symbol_subscriptions[symbol] = max(0, symbol_subscriptions[symbol] - 1)

            # If no more clients, but keep collecting data in background for a while
            if symbol_subscriptions[symbol] == 0:
                logger.info(f"No more active clients for {symbol}, but keeping background collection")

        del clients[sid]

def fetch_historical_intraday_data(symbol, date=None):
    """Enhanced to always fetch and store data regardless of current subscriptions"""
    if not date:
        date = datetime.datetime.now(INDIA_TZ).strftime('%Y-%m-%d')

    try:
        date_obj = datetime.datetime.strptime(date, '%Y-%m-%d')
        date_obj = INDIA_TZ.localize(date_obj)

        market_open = date_obj.replace(hour=9, minute=15, second=0, microsecond=0)
        market_close = date_obj.replace(hour=15, minute=30, second=0, microsecond=0)

        now = datetime.datetime.now(INDIA_TZ)
        if date == now.strftime('%Y-%m-%d') and now < market_open:
            logger.info(f"Market not yet open for {date}")
            return []

        if date == now.strftime('%Y-%m-%d') and now < market_close:
            end_time = now
        else:
            end_time = market_close

        from_date = market_open.strftime('%Y-%m-%d %H:%M:%S')
        to_date = end_time.strftime('%Y-%m-%d %H:%M:%S')

        logger.info(f"Fetching historical data for {symbol} from {from_date} to {to_date}")

        if fyers_client:
            data_args = {
                "symbol": symbol,
                "resolution": "1",
                "date_format": "1",
                "range_from": from_date,
                "range_to": to_date,
                "cont_flag": "1"
            }

            response = fyers_client.history(data_args)

            if response and response.get('s') == 'ok' and 'candles' in response:
                candles = response['candles']
                logger.info(f"Received {len(candles)} candles for {symbol}")

                result = []

                for candle in candles:
                    timestamp, open_price, high_price, low_price, close_price, volume = candle

                    if timestamp > 10000000000:
                        timestamp = timestamp // 1000

                    data_point = {
                        'symbol': symbol,
                        'ltp': close_price,
                        'open': open_price,
                        'high': high_price,
                        'low': low_price,
                        'close': close_price,
                        'volume': volume,
                        'timestamp': timestamp,
                        'change': 0,
                        'changePercent': 0
                    }

                    result.append(data_point)

                    # ============ ENHANCED: Always store regardless of active subscriptions ============
                    if symbol not in ohlc_data:
                        ohlc_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)

                    minute_timestamp = (timestamp // 60) * 60

                    ohlc_candle = {
                        'timestamp': minute_timestamp,
                        'open': open_price,
                        'high': high_price,
                        'low': low_price,
                        'close': close_price,
                        'volume': volume
                    }

                    if not ohlc_data[symbol] or ohlc_data[symbol][-1]['timestamp'] != minute_timestamp:
                        ohlc_data[symbol].append(ohlc_candle)

                if result:
                    prev_close = result[0]['open']
                    for point in result:
                        point['change'] = point['ltp'] - prev_close
                        point['changePercent'] = (point['change'] / prev_close) * 100 if prev_close else 0

                if result:
                    calculate_indicators_optimized(symbol, init=True)
                    # Mark symbol as active for background collection
                    active_symbols.add(symbol)

                return result
            else:
                logger.error(f"Failed to fetch historical data: {response}")

        logger.warning(f"Fyers client not initialized or API call failed for {symbol}")
        return []

    except Exception as e:
        logger.error(f"Error fetching historical data: {e}")
        import traceback
        traceback.print_exc()
        return []

@sio.event
def subscribe(sid, data):
    symbol = data.get('symbol')
    if not symbol:
        return {'success': False, 'error': 'No symbol provided'}

    logger.info(f"Client {sid} subscribing to {symbol}")

    clients[sid]['subscriptions'].add(symbol)
    if symbol not in symbol_to_clients:
        symbol_to_clients[symbol] = set()
    symbol_to_clients[symbol].add(sid)

    # Increase subscription count
    symbol_subscriptions[symbol] += 1
    active_symbols.add(symbol)

    # ============ ENHANCED: Check if we already have cached data ============
    if symbol not in historical_data or not historical_data[symbol]:
        logger.info(f"Fetching fresh historical data for {symbol}")
        hist_data = fetch_historical_intraday_data(symbol)

        if symbol not in historical_data:
            historical_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)

        for data_point in hist_data:
            historical_data[symbol].append(data_point)
    else:
        logger.info(f"Using cached historical data for {symbol} ({len(historical_data[symbol])} points)")

    # Subscribe to real-time updates if not already subscribed
    if hasattr(fyers, 'subscribe') and callable(fyers.subscribe):
        logger.info(f"Subscribing to real-time updates for: {symbol}")
        fyers.subscribe(symbols=[symbol], data_type="SymbolUpdate")

    # Send all available data to client
    if symbol in historical_data and historical_data[symbol]:
        logger.info(f"Sending {len(historical_data[symbol])} historical data points for {symbol}")
        hist_data_list = list(historical_data[symbol])
        sio.emit('historicalData', {
            'symbol': symbol,
            'data': hist_data_list
        }, room=sid)

    if symbol in ohlc_data and ohlc_data[symbol]:
        logger.info(f"Sending {len(ohlc_data[symbol])} OHLC data points for {symbol}")
        sio.emit('ohlcData', {
            'symbol': symbol,
            'data': list(ohlc_data[symbol])
        }, room=sid)

    # Send cached chart updates if available
    if symbol in chart_updates and chart_updates[symbol]:
        logger.info(f"Sending {len(chart_updates[symbol])} cached chart updates for {symbol}")
        sio.emit('chartUpdatesHistory', {
            'symbol': symbol,
            'data': list(chart_updates[symbol])
        }, room=sid)

    return {'success': True, 'symbol': symbol, 'cached_points': len(historical_data.get(symbol, []))}

@sio.event
def unsubscribe(sid, data):
    symbol = data.get('symbol')
    if not symbol:
        return {'success': False, 'error': 'No symbol provided'}

    logger.info(f"Client {sid} unsubscribing from {symbol}")

    if sid in clients:
        clients[sid]['subscriptions'].discard(symbol)

    if symbol in symbol_to_clients:
        symbol_to_clients[symbol].discard(sid)

        # Decrease subscription count but don't unsubscribe from Fyers immediately
        symbol_subscriptions[symbol] = max(0, symbol_subscriptions[symbol] - 1)

        # Keep collecting data for a while even if no active clients
        if symbol_subscriptions[symbol] == 0:
            logger.info(f"No more clients for {symbol}, but keeping background data collection")
            # Note: We intentionally don't unsubscribe from Fyers to keep background collection

    return {'success': True, 'symbol': symbol}

@sio.event
def get_trading_status(sid, data):
    start_time, end_time = get_trading_hours()
    return {
        'trading_active': is_trading_hours(),
        'trading_start': start_time.isoformat(),
        'trading_end': end_time.isoformat(),
        'current_time': datetime.datetime.now(INDIA_TZ).isoformat(),
        'is_market_day': datetime.datetime.now(INDIA_TZ).weekday() < 5,
        'active_symbols': list(active_symbols),
        'total_data_points': sum(len(data) for data in historical_data.values())
    }

def store_historical_data(symbol, data_point):
    """Enhanced to store data for ALL active symbols"""
    if symbol not in historical_data:
        historical_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)

    if 'timestamp' not in data_point:
        data_point['timestamp'] = int(time.time())

    historical_data[symbol].append(data_point)
    update_ohlc_data(symbol, data_point)

    # Also store in chart updates for smooth transitions
    if symbol not in chart_updates:
        chart_updates[symbol] = deque(maxlen=MAX_CHART_UPDATES)

    chart_update = {
        'symbol': symbol,
        'price': data_point['ltp'],
        'timestamp': data_point['timestamp'],
        'volume': data_point.get('volume', 0),
        'change': data_point.get('change', 0),
        'changePercent': data_point.get('changePercent', 0)
    }
    chart_updates[symbol].append(chart_update)

def update_ohlc_data(symbol, data_point):
    if symbol not in ohlc_data:
        ohlc_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)

    timestamp = data_point['timestamp']
    price = data_point['ltp']

    minute_timestamp = (timestamp // 60) * 60

    if not ohlc_data[symbol] or ohlc_data[symbol][-1]['timestamp'] < minute_timestamp:
        ohlc_data[symbol].append({
            'timestamp': minute_timestamp,
            'open': price,
            'high': price,
            'low': price,
            'close': price,
            'volume': data_point.get('volume', 0)
        })
    else:
        current_candle = ohlc_data[symbol][-1]
        current_candle['high'] = max(current_candle['high'], price)
        current_candle['low'] = min(current_candle['low'], price)
        current_candle['close'] = price
        current_candle['volume'] = data_point.get('volume', current_candle['volume'])

def calculate_indicators_optimized(symbol, init=False):
    if symbol not in ohlc_data or len(ohlc_data[symbol]) < 20:
        return {}

    latest_close = ohlc_data[symbol][-1]['close']

    if symbol not in cached_indicators or init:
        closes = np.array([candle['close'] for candle in ohlc_data[symbol]])

        sma_20 = np.mean(closes[-20:]) if len(closes) >= 20 else latest_close

        if len(closes) >= 9:
            ema_9 = closes[0]
            alpha = 2 / (9 + 1)
            for price in closes[1:]:
                ema_9 = alpha * price + (1 - alpha) * ema_9
        else:
            ema_9 = latest_close

        if len(closes) >= 15:
            changes = np.diff(closes)
            gains = np.where(changes > 0, changes, 0)
            losses = np.where(changes < 0, -changes, 0)

            avg_gain = np.mean(gains[-14:])
            avg_loss = np.mean(losses[-14:])

            if avg_loss == 0:
                rsi = 100
            else:
                rs = avg_gain / avg_loss
                rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50

        cached_indicators[symbol] = {
            'sma_20': float(sma_20),
            'ema_9': float(ema_9),
            'rsi_14': float(rsi),
            'avg_gain': avg_gain if len(closes) >= 15 else 0,
            'avg_loss': avg_loss if len(closes) >= 15 else 0,
            'prev_close': latest_close
        }
    else:
        cache = cached_indicators[symbol]
        prev_close = cache['prev_close']

        if len(ohlc_data[symbol]) >= 20:
            old_sma = cache['sma_20']
            cache['sma_20'] = old_sma + (latest_close - old_sma) / 20

        alpha = 2 / (9 + 1)
        cache['ema_9'] = alpha * latest_close + (1 - alpha) * cache['ema_9']

        change = latest_close - prev_close
        gain = max(0, change)
        loss = max(0, -change)

        cache['avg_gain'] = (cache['avg_gain'] * 13 + gain) / 14
        cache['avg_loss'] = (cache['avg_loss'] * 13 + loss) / 14

        if cache['avg_loss'] == 0:
            cache['rsi_14'] = 100
        else:
            rs = cache['avg_gain'] / cache['avg_loss']
            cache['rsi_14'] = 100 - (100 / (1 + rs))

        cache['prev_close'] = latest_close

    return {
        'sma_20': cached_indicators[symbol]['sma_20'],
        'ema_9': cached_indicators[symbol]['ema_9'],
        'rsi_14': cached_indicators[symbol]['rsi_14']
    }

# ============ ENHANCED: Background data collection for all symbols ============
def emit_real_time_data():
    """Enhanced to emit data for all symbols and manage background collection"""
    global running
    while running:
        try:
            current_time = time.time()

            # Cleanup old data periodically
            cleanup_old_data()

            # Emit data for all symbols that have pending updates
            for symbol in list(pending_data.keys()):
                # Always store data regardless of active clients
                if symbol in pending_data:
                    data = pending_data[symbol].copy()

                    # Emit to subscribed clients if any
                    if symbol in symbol_to_clients and symbol_to_clients[symbol]:
                        if current_time - last_emit_time[symbol] >= REAL_TIME_INTERVAL:
                            for sid in list(symbol_to_clients[symbol]):
                                try:
                                    sio.emit('marketDataUpdate', data, room=sid)

                                    # Send chart-specific update
                                    chart_update = {
                                        'symbol': symbol,
                                        'price': data['ltp'],
                                        'timestamp': data['timestamp'],
                                        'volume': data.get('volume', 0),
                                        'change': data.get('change', 0),
                                        'changePercent': data.get('changePercent', 0)
                                    }
                                    sio.emit('chartUpdate', chart_update, room=sid)

                                except Exception as e:
                                    logger.error(f"Error sending data to client {sid}: {e}")

                            last_emit_time[symbol] = current_time

                    # Always store data even if no active clients (background collection)
                    store_historical_data(symbol, data)

            eventlet.sleep(CHART_UPDATE_INTERVAL)

        except Exception as e:
            logger.error(f"Error in real-time emission: {e}")
            eventlet.sleep(0.1)

def onmessage(message):
    """Enhanced to handle ALL symbols, not just subscribed ones"""
    if not isinstance(message, dict) or 'symbol' not in message:
        return

    symbol = message['symbol']

    if message.get('type') == 'sub':
        logger.info(f"Subscription confirmation: {symbol}")
        return

    # Always add symbol to active symbols when we receive data
    active_symbols.add(symbol)

    # Create optimized data structure
    simplified_data = {
        'symbol': symbol,
        'ltp': message.get('ltp'),
        'change': message.get('ch'),
        'changePercent': message.get('chp'),
        'volume': message.get('vol_traded_today'),
        'open': message.get('open_price'),
        'high': message.get('high_price'),
        'low': message.get('low_price'),
        'close': message.get('prev_close_price'),
        'bid': message.get('bid_price'),
        'ask': message.get('ask_price'),
        'timestamp': message.get('last_traded_time') or int(time.time())
    }

    # Calculate indicators with caching
    indicators = calculate_indicators_optimized(symbol)
    if indicators:
        simplified_data.update(indicators)

    # Store for ALL symbols (background + active)
    pending_data[symbol] = simplified_data

    eventlet.sleep(0)

def onerror(error):
    logger.error(f"Error: {error}")
    sio.emit('error', {'message': str(error)})

def onclose(message):
    logger.info(f"Connection closed: {message}")
    sio.emit('fyersDisconnected', {'message': str(message)})

def onopen():
    logger.info("Fyers WebSocket connected")
    sio.emit('fyersConnected', {'status': 'connected'})

    # Subscribe to all active symbols (including background ones)
    symbols_to_subscribe = list(active_symbols) if active_symbols else []
    if symbols_to_subscribe:
        fyers.subscribe(symbols=symbols_to_subscribe, data_type="SymbolUpdate")
        logger.info(f"Subscribed to {len(symbols_to_subscribe)} symbols for background collection")

def heartbeat_task():
    global running
    while running:
        try:
            sio.emit('heartbeat', {
                'timestamp': int(time.time()),
                'trading_active': is_trading_hours(),
                'server_time': datetime.datetime.now(INDIA_TZ).isoformat(),
                'active_symbols': list(active_symbols),
                'total_cached_points': sum(len(data) for data in historical_data.values()),
                'background_collection': True
            })
            eventlet.sleep(10)
        except Exception as e:
            logger.error(f"Error in heartbeat: {e}")

def main_process():
    global fyers, fyers_client, running

    try:
        session = fyersModel.SessionModel(
            client_id=client_id,
            secret_key=secret_key,
            redirect_uri=redirect_uri,
            response_type=response_type,
            grant_type=grant_type
        )

        auth_url = session.generate_authcode()
        logger.info("\n==== Fyers Authentication ====")
        logger.info("Open this URL in your browser and log in:")
        logger.info(auth_url)

        auth_code = input("\nEnter Auth Code: ")
        session.set_token(auth_code)
        token_response = session.generate_token()

        if token_response.get('s') != 'ok':
            logger.error(f"Authentication failed: {token_response}")
            return

        logger.info("Authentication successful!")
        access_token = f"{client_id}:{token_response['access_token']}"

        fyers_client = fyersModel.FyersModel(
            client_id=client_id,
            token=token_response['access_token'],
            log_path=None
        )

        fyers = data_ws.FyersDataSocket(
            access_token=access_token,
            log_path="",
            litemode=False,
            write_to_file=False,
            reconnect=True,
            on_connect=onopen,
            on_close=onclose,
            on_error=onerror,
            on_message=onmessage
        )

        heartbeat_thread = threading.Thread(target=heartbeat_task, daemon=True)
        heartbeat_thread.start()

        emission_thread = threading.Thread(target=emit_real_time_data, daemon=True)
        emission_thread.start()

        fyers.connect()
        logger.info("Connected to Fyers WebSocket with enhanced background collection")

        logger.info("Starting enhanced Socket.IO server with persistent multi-symbol data...")
        eventlet.wsgi.server(eventlet.listen(('0.0.0.0', 5001)), app)

    except Exception as e:
        logger.error(f"Error: {e}")
        import traceback
        traceback.print_exc()

def main():
    global running

    try:
        eventlet.spawn(main_process)

        while running:
            eventlet.sleep(0.1)
    except KeyboardInterrupt:
        logger.info("Shutting down enhanced server...")
        running = False

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logger.info("Shutting down enhanced server...")
        running = False



================================================================================
FILE 31/37: apps/backend/package.json
CATEGORY: Reference - Backend Dependencies
PURPOSE: Backend npm dependencies and scripts
PRIORITY: ?? OPTIONAL
================================================================================

{
    "name": "my-app",
    "version": "0.0.1",
    "description": "",
    "author": "",
    "private": true,
    "license": "UNLICENSED",
    "scripts": {
        "build": "nest build",
        "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
        "start": "nest start",
        "start:dev": "cross-env NODE_ENV=development nest start --watch",
        "start:debug": "nest start --debug --watch",
        "start:prod": "node dist/main",
        "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
        "test": "jest",
        "test:watch": "jest --watch",
        "test:cov": "jest --coverage",
        "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
        "test:e2e": "jest --config ./test/jest-e2e.json"
    },
    "dependencies": {
        "@nestjs/axios": "^4.0.1",
        "@nestjs/common": "^11.0.10",
        "@nestjs/core": "^11.0.10",
        "@nestjs/platform-express": "^11.0.10",
        "@nestjs/platform-socket.io": "^11.1.0",
        "@nestjs/schedule": "^6.0.0",
        "@nestjs/typeorm": "^11.0.0",
        "@nestjs/websockets": "^11.1.0",
        "axios": "^1.12.2",
        "child_process": "^1.0.2",
        "csv-parse": "^5.6.0",
        "dotenv": "^16.5.0",
        "fyers-api-v3": "^1.4.1",
        "moment": "^2.30.1",
        "mssql": "^10.0.4",
        "pg": "^8.13.3",
        "readline": "^1.3.0",
        "reflect-metadata": "^0.2.2",
        "rxjs": "^7.8.1",
        "socket.io": "^4.8.1",
        "socket.io-client": "^4.8.1",
        "typeorm": "^0.3.20",
        "ws": "^8.18.2"
    },
    "devDependencies": {
        "@eslint/eslintrc": "^3.2.0",
        "@eslint/js": "^9.18.0",
        "@nestjs/cli": "^11.0.0",
        "@nestjs/schematics": "^11.0.0",
        "@nestjs/testing": "^11.0.1",
        "@swc/cli": "^0.6.0",
        "@swc/core": "^1.10.7",
        "@types/express": "^5.0.0",
        "@types/jest": "^29.5.14",
        "@types/node": "^22.13.10",
        "@types/supertest": "^6.0.2",
        "cross-env": "^7.0.3",
        "eslint": "^9.18.0",
        "eslint-config-prettier": "^10.0.1",
        "eslint-plugin-prettier": "^5.2.2",
        "globals": "^15.14.0",
        "jest": "^29.7.0",
        "prettier": "^3.4.2",
        "source-map-support": "^0.5.21",
        "supertest": "^7.0.0",
        "ts-jest": "^29.2.5",
        "ts-loader": "^9.5.2",
        "ts-node": "^10.9.2",
        "tsconfig-paths": "^4.2.0",
        "typescript": "^5.7.3",
        "typescript-eslint": "^8.20.0"
    },
    "jest": {
        "moduleFileExtensions": [
            "js",
            "json",
            "ts"
        ],
        "rootDir": "src",
        "testRegex": ".*\\.spec\\.ts$",
        "transform": {
            "^.+\\.(t|j)s$": "ts-jest"
        },
        "collectCoverageFrom": [
            "**/*.(t|j)s"
        ],
        "coverageDirectory": "../coverage",
        "testEnvironment": "node"
    }
}


================================================================================
FILE 32/37: apps/frontend/package.json
CATEGORY: Reference - Frontend Dependencies
PURPOSE: Frontend npm dependencies and scripts
PRIORITY: ?? OPTIONAL
================================================================================

{
  "name": "frontned",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "generate-manifest": "node scripts/generate-manifest.js",
    "dev": "npm run generate-manifest && next dev",
    "build": "npm run generate-manifest && next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@heroicons/react": "^2.2.0",
    "@hookform/resolvers": "^5.2.1",
    "@radix-ui/react-checkbox": "^1.3.3",
    "@radix-ui/react-dialog": "^1.1.14",
    "@radix-ui/react-scroll-area": "^1.2.6",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-toast": "^1.2.11",
    "@syncfusion/ej2-react-charts": "^29.1.41",
    "@types/react-plotly.js": "^2.6.3",
    "apexcharts": "^4.7.0",
    "autoprefixer": "^10.4.21",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "d3-format": "^3.1.0",
    "d3-time-format": "^4.1.0",
    "date-fns": "^4.1.0",
    "lightweight-charts": "^5.0.6",
    "lucide-react": "^0.479.0",
    "next": "^15.1.8",
    "next-themes": "^0.4.6",
    "plotly.js": "^3.0.1",
    "plotly.js-dist": "^3.0.1",
    "radix-ui": "^1.1.3",
    "react": "^19.1.0",
    "react-apexcharts": "^1.7.0",
    "react-day-picker": "^8.10.1",
    "react-dom": "^19.1.0",
    "react-financial-charts": "^2.0.1",
    "react-hook-form": "^7.62.0",
    "react-plotly.js": "^2.6.0",
    "socket.io-client": "^4.8.1",
    "swr": "^2.3.2",
    "tailwind-merge": "^3.3.1",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@types/node": "^20.19.13",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.1.7",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.17",
    "typescript": "^5"
  }
}


================================================================================
FILE 33/37: PROJECT_DOCUMENTATION.md
CATEGORY: Reference - Project Documentation
PURPOSE: Complete project documentation
PRIORITY: ?? OPTIONAL
================================================================================

# APM-TOP-K-STOCKS: Project Documentation

## Overview

**APM-TOP-K-STOCKS** is a full-stack, monorepo-based stock analytics and dashboard platform. It is designed to provide real-time and historical market data, stock recommendations, and advanced charting for Indian equities. The project is modular, scalable, and leverages modern web technologies, microservices, and data pipelines.

---

## Table of Contents
1. [Project Structure](#project-structure)
2. [Key Features](#key-features)
3. [Technology Stack](#technology-stack)
4. [How It Works](#how-it-works)
5. [Setup & Deployment](#setup--deployment)
6. [Main Modules](#main-modules)
7. [Data Flow](#data-flow)
8. [Extending the Project](#extending-the-project)

---

## Project Structure

```
APM-TOP-K-STOCKS/
‚îú‚îÄ‚îÄ apps/
‚îÇ   ‚îú‚îÄ‚îÄ backend/         # NestJS API, WebSocket, Data Services, Python integration
‚îÇ   ‚îî‚îÄ‚îÄ frontend/        # Next.js React UI, Dashboard, Charts, Components
‚îú‚îÄ‚îÄ docker-compose.yml   # Multi-service orchestration
‚îú‚îÄ‚îÄ Dockerfile.*         # Dockerfiles for backend, frontend, python
‚îú‚îÄ‚îÄ setup.sh             # Setup script
‚îî‚îÄ‚îÄ ...                  # Other configs and scripts
```

---

## Key Features
- Real-time and historical stock market data (NSE/BSE)
- Interactive dashboards and charts (Plotly, ApexCharts, Syncfusion)
- Watchlists, recommendations, and company-specific analytics
- WebSocket-based live data streaming
- Modular, extensible UI with Next.js and Tailwind CSS
- Python integration for data fetching and analytics
- Dockerized for easy deployment

---

## Technology Stack
- **Frontend:** Next.js (React), Tailwind CSS, Plotly.js, ApexCharts, Syncfusion, SWR
- **Backend:** NestJS (TypeScript), WebSocket, REST API, TypeORM, PostgreSQL
- **Python Services:** Data fetching, analytics, integration with Fyers API
- **Database:** PostgreSQL (Dockerized)
- **DevOps:** Docker, Docker Compose

---

## How It Works

1. **Data Ingestion:**
   - Python scripts/services fetch live and historical data from Fyers API and other sources.
   - Data is stored in PostgreSQL and/or as JSON files.

2. **Backend API:**
   - NestJS backend exposes REST and WebSocket APIs for market data, watchlists, recommendations, and more.
   - Handles authentication, data aggregation, and business logic.

3. **Frontend UI:**
   - Next.js frontend provides dashboards, charts, and interactive components for users.
   - Real-time updates via WebSocket, advanced charting, and user customization.

4. **Orchestration:**
   - Docker Compose manages all services (frontend, backend, python, database) for local or cloud deployment.

---

## Setup & Deployment

### Prerequisites
- Docker & Docker Compose
- Node.js (for local dev)

### Quick Start (Docker)
```sh
git clone <repo-url>
cd APM-TOP-K-STOCKS
docker-compose up --build
```
- Frontend: http://localhost:3000
- Backend API: http://localhost:5000
- Database: localhost:5432

### Local Development
- `apps/frontend`: `npm run dev`
- `apps/backend`: `npm run start:dev`
- Python scripts: Run as needed for data fetching

---

## Main Modules

### Backend (NestJS)
- `src/market-data/`: Market data API, WebSocket, DTOs, entities
- `src/live-market/`: Live market streaming
- `src/stock/`: Stock info, filters, entities
- `src/watchlist/`: Watchlist CRUD and management
- `src/database/`: TypeORM/PostgreSQL integration
- `src/services/`: Fyers API, Python bridge

### Frontend (Next.js)
- `app/`: Main app, routing, layout
- `app/components/`: UI components, charts, sidebar, theme
- `app/market-data/`, `app/live-market/`, `app/recommendations/`: Feature pages
- `hooks/`: Custom React hooks for data, WebSocket, etc.
- `lib/`: Utilities, socket, indicators

### Python
- `apps/backend/data/`: Data fetch scripts, company master, watchlists
- `apps/backend/recorded_data/`: Historical data storage

---

## Data Flow
1. **Python** fetches data ‚Üí stores in DB/files
2. **Backend** serves data via API/WebSocket
3. **Frontend** consumes API/WebSocket ‚Üí renders dashboards

---

## Extending the Project
- Add new data sources by extending Python scripts and backend services
- Add new charts or UI features in the frontend
- Integrate more analytics or ML models in Python/backend

---

## Authors & License
- Author: raghavjaiswal709
- License: ISC/UNLICENSED (see package.json)

---

## Contact & Support
For issues, open a GitHub issue or contact the maintainer.


################################################################################
?? SECTION 8: PYTHON SERVICE FILES - BACKEND INTEGRATION
################################################################################

================================================================================
FILE 34/37: apps/backend/data/data_fetch.py
CATEGORY: Python Services - Data Fetching
PURPOSE: Main data fetching and processing script
PRIORITY: ?? PYTHON SERVICE
================================================================================

import psycopg2
from psycopg2.extras import RealDictCursor
from datetime import datetime, timedelta
import argparse
import sys
import json
import time
import logging

# Configure logging with proper levels
logging.basicConfig(
    level=logging.INFO,
    format='INFO: %(message)s',
    stream=sys.stderr
)

logger = logging.getLogger(__name__)

def main():
    parser = argparse.ArgumentParser(description='Fetch and aggregate stock data.')
    parser.add_argument('--company_code', type=str, required=True, help='Company code to fetch data for')
    parser.add_argument('--exchange', type=str, default='NSE,BSE', help='Exchange filter (NSE, BSE, or NSE,BSE)')
    parser.add_argument('--start_date', type=str, default='2024-02-22 00:00:00', help='Start date and time (ISO format or YYYY-MM-DD HH:MM:SS)')
    parser.add_argument('--end_date', type=str, default='2024-04-16 00:00:00', help='End date and time (ISO format or YYYY-MM-DD HH:MM:SS)')
    parser.add_argument('--interval', type=str, default='10m', help='Interval for aggregation (e.g., 1m, 5m, 10m, 15m, 30m, 1h)')
    parser.add_argument('--first_fifteen_minutes', type=str, default='false', 
                       choices=['true', 'false'],
                       help='Filter to first 15 minutes of trading day')
    parser.add_argument('--fetch_all_data', type=str, default='false',
                       choices=['true', 'false'],
                       help='Fetch all available data for the company (ignores date range)')
    
    # Enhanced arguments for the new StockService
    parser.add_argument('--limit', type=int, default=2500, help='Maximum number of records to return')
    parser.add_argument('--enable_cache', type=str, default='false', 
                       choices=['true', 'false'],
                       help='Enable caching (future feature)')
    parser.add_argument('--compression', type=str, default='false',
                       choices=['true', 'false'], 
                       help='Enable compression (future feature)')
    parser.add_argument('--validate_data', type=str, default='true',
                       choices=['true', 'false'],
                       help='Enable data validation')
    parser.add_argument('--optimize_for_range', type=str, default='false',
                       choices=['true', 'false'],
                       help='Optimize query for date range requests')
    parser.add_argument('--buffer_minutes', type=int, default=30,
                       help='Buffer minutes to add around date range')
    parser.add_argument('--indicators', type=str, default='',
                       help='Comma-separated list of indicators (future feature)')
    parser.add_argument('--parallel_processing', type=str, default='false',
                       choices=['true', 'false'],
                       help='Enable parallel processing (future feature)')
    
    args = parser.parse_args()
    
    # Parse boolean arguments
    first_fifteen_minutes = args.first_fifteen_minutes.lower() == 'true'
    fetch_all_data = args.fetch_all_data.lower() == 'true'
    enable_cache = args.enable_cache.lower() == 'true'
    compression = args.compression.lower() == 'true'
    validate_data = args.validate_data.lower() == 'true'
    optimize_for_range = args.optimize_for_range.lower() == 'true'
    parallel_processing = args.parallel_processing.lower() == 'true'
    
    # Parse indicators
    indicators = [ind.strip() for ind in args.indicators.split(',') if ind.strip()] if args.indicators else []
    
    if fetch_all_data:
        start_date = None
        end_date = None
        logger.info(f"Fetching all available data for company_code={args.company_code} on exchanges={args.exchange} (limit={args.limit})")
    else:
        try:
            start_date = parse_date_string(args.start_date)
            end_date = parse_date_string(args.end_date)
            
            # Apply buffer for range optimization
            if optimize_for_range and args.buffer_minutes > 0:
                buffer_delta = timedelta(minutes=args.buffer_minutes)
                start_date = start_date - buffer_delta
                end_date = end_date + buffer_delta
                logger.info(f"Applied {args.buffer_minutes}min buffer: {start_date} to {end_date}")
            
            if first_fifteen_minutes:
                start_date, end_date = adjust_for_first_fifteen_minutes(start_date, end_date)
                
        except ValueError as e:
            logger.error(f"Date parsing error: {e}")
            sys.exit(1)
    
    # Interval mapping with enhanced support
    interval_map = {
        '1m': 1,
        '5m': 5,
        '10m': 10,
        '15m': 15,
        '30m': 30,
        '1h': 60,
        '2h': 120,
        '4h': 240,
        '1d': 1440
    }
    
    interval_minutes = interval_map.get(args.interval, 10)
    
    # Database connection parameters
    db_params = {
        'dbname': 'nse_hist_db',
        'user': 'readonly_user',
        'password': 'db_read_5432',
        'host': '100.93.172.21',
        'port': '5432',
    }
    



    start_time = time.time()
    
    try:
        # Connect to database with improved error handling
        try:
            conn = psycopg2.connect(**db_params)
            cur = conn.cursor(cursor_factory=RealDictCursor)
        except psycopg2.Error as e:
            logger.error(f"Database connection failed: {e}")
            sys.exit(1)

        # Set timezone
        cur.execute("SET TIME ZONE 'Asia/Kolkata';")

        # Parse exchanges
        exchanges = [ex.strip() for ex in args.exchange.split(',') if ex.strip()]
        exchange_placeholders = ','.join(['%s'] * len(exchanges))

        # Company lookup with enhanced error handling
        company_lookup_query = f"""
        SELECT company_id, company_code, name, exchange
        FROM companies
        WHERE company_code = %s
        AND exchange IN ({exchange_placeholders})
        """
        
        company_params = [args.company_code] + exchanges
        logger.info(f"Looking up company: {args.company_code} on exchanges: {args.exchange}")
        
        cur.execute(company_lookup_query, company_params)
        company_records = cur.fetchall()
        
        if not company_records:
            logger.error(f"No company found with code '{args.company_code}' on exchanges {args.exchange}")
            sys.exit(1)
        
        company_ids = [record['company_id'] for record in company_records]
        company_id_placeholders = ','.join(['%s'] * len(company_ids))
        
        logger.info(f"Found {len(company_records)} company records")
        for record in company_records:
            logger.info(f"  - {record['company_code']} ({record['name']}) on {record['exchange']} [ID: {record['company_id']}]")

        # Build optimized query based on request type
        if fetch_all_data:
            if optimize_for_range:
                # Optimized query for large datasets
                stock_data_query = f"""
                SELECT timestamp, open, high, low, close, volume, company_id
                FROM company_data
                WHERE company_id IN ({company_id_placeholders})
                ORDER BY timestamp DESC
                LIMIT %s
                """
                query_params = company_ids + [args.limit]
                logger.info(f"Querying RECENT {args.limit} records for company_ids: {company_ids}")
            else:
                stock_data_query = f"""
                SELECT timestamp, open, high, low, close, volume, company_id
                FROM company_data
                WHERE company_id IN ({company_id_placeholders})
                ORDER BY timestamp
                """
                query_params = company_ids
                logger.info(f"Querying ALL stock data for company_ids: {company_ids}")
        else:
            if optimize_for_range:
                # Optimized range query with indexes
                stock_data_query = f"""
                SELECT timestamp, open, high, low, close, volume, company_id
                FROM company_data
                WHERE company_id IN ({company_id_placeholders})
                AND timestamp >= %s
                AND timestamp < %s
                ORDER BY timestamp
                LIMIT %s
                """
                query_params = company_ids + [start_date, end_date, args.limit]
            else:
                stock_data_query = f"""
                SELECT timestamp, open, high, low, close, volume, company_id
                FROM company_data
                WHERE company_id IN ({company_id_placeholders})
                AND timestamp >= %s
                AND timestamp < %s
                ORDER BY timestamp
                """
                query_params = company_ids + [start_date, end_date]
            
            logger.info(f"Querying stock data for company_ids: {company_ids}, date range: {start_date} to {end_date}")
        
        # Execute query with timing
        query_start = time.time()
        cur.execute(stock_data_query, query_params)
        rows = cur.fetchall()
        query_time = time.time() - query_start
        
        logger.info(f"Query executed in {query_time:.2f}s, fetched {len(rows)} raw records")
        
        if not rows:
            if fetch_all_data:
                logger.info(f"No stock data found for company_code='{args.company_code}' on exchanges={args.exchange}")
            else:
                logger.info(f"No stock data found for company_code='{args.company_code}' on exchanges={args.exchange} in date range {start_date} to {end_date}")
            sys.exit(0)

        # Apply limit for all data requests (if not already limited in query)
        if fetch_all_data and not optimize_for_range and len(rows) > args.limit:
            logger.info(f"Large dataset detected ({len(rows)} records). Limiting to most recent {args.limit} records.")
            rows = rows[-args.limit:]

        # Data aggregation with enhanced error handling
        def get_interval_start(dt):
            minute = dt.minute
            interval_minute = (minute // interval_minutes) * interval_minutes
            return dt.replace(minute=interval_minute, second=0, microsecond=0)

        # Process data into intervals
        processing_start = time.time()
        interval_data = {}
        invalid_records = 0
        
        for row in rows:
            # Data validation if enabled
            if validate_data:
                if not validate_ohlcv_data(row):
                    invalid_records += 1
                    continue
            
            interval_start = get_interval_start(row['timestamp'])
            if interval_start not in interval_data:
                interval_data[interval_start] = []
            interval_data[interval_start].append(row)

        if invalid_records > 0:
            logging.warning(f"Skipped {invalid_records} invalid records during validation")

        # Aggregate intervals
        results = []
        for interval_start in sorted(interval_data.keys()):
            interval_rows = interval_data[interval_start]
            if interval_rows:
                interval_rows.sort(key=lambda x: x['timestamp'])
                
                try:
                    open_price = float(interval_rows[0]['open'])
                    high_price = max(float(row['high']) for row in interval_rows)
                    low_price = min(float(row['low']) for row in interval_rows)
                    close_price = float(interval_rows[-1]['close'])
                    volume_sum = sum(int(row['volume']) for row in interval_rows)
                    
                    # Additional validation for aggregated data
                    if validate_data and not validate_aggregated_ohlc(open_price, high_price, low_price, close_price):
                        logging.warning(f"Invalid OHLC relationship at {interval_start}, skipping")
                        continue
                    
                    results.append({
                        'interval_start': interval_start,
                        'open': round(open_price, 2),
                        'high': round(high_price, 2),
                        'low': round(low_price, 2),
                        'close': round(close_price, 2),
                        'volume': volume_sum
                    })
                except (ValueError, TypeError) as e:
                    logging.warning(f"Error processing interval {interval_start}: {e}")
                    continue

        processing_time = time.time() - processing_start
        logger.info(f"Data processing completed in {processing_time:.2f}s")

        # Apply first fifteen minutes filter for all data requests
        if first_fifteen_minutes and fetch_all_data:
            filtered_results = []
            for result in results:
                timestamp = result['interval_start']
                if timestamp.hour == 9 and 15 <= timestamp.minute <= 30:
                    filtered_results.append(result)
            results = filtered_results
            logger.info(f"Filtered to first 15 minutes: {len(results)} data points")

        # Sort results by timestamp (important for chart rendering)
        results.sort(key=lambda x: x['interval_start'])

        # Output results in the expected format
        for result in results:
            print(f"Interval:{result['interval_start'].isoformat()},Open:{result['open']},High:{result['high']},Low:{result['low']},Close:{result['close']},Volume:{result['volume']}")
        
        total_time = time.time() - start_time
        
        if fetch_all_data:
            logger.info(f"Successfully fetched ALL available data: {len(results)} data points in {total_time:.2f}s")
        else:
            logger.info(f"Successfully fetched {len(results)} data points for date range in {total_time:.2f}s")

        # Performance statistics
        if len(results) > 0:
            logger.info(f"Data range: {results[0]['interval_start']} to {results[-1]['interval_start']}")
            
        # Future: Indicator calculations
        if indicators:
            logger.info(f"Note: Indicators requested but not yet implemented: {indicators}")

    except psycopg2.Error as e:
        logger.error(f"Database error: {e}")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        import traceback
        traceback.print_exc(file=sys.stderr)
        sys.exit(1)
    finally:
        if 'cur' in locals():
            cur.close()
        if 'conn' in locals():
            conn.close()

def parse_date_string(date_str):
    """Parse date string in various formats with enhanced support"""
    try:
        # Handle ISO format with timezone
        if 'T' in date_str:
            if date_str.endswith('Z'):
                date_str = date_str[:-1] + '+00:00'
            # Try to parse with timezone info
            try:
                dt = datetime.fromisoformat(date_str)
                # Convert to naive datetime in IST
                if dt.tzinfo is not None:
                    import pytz
                    ist = pytz.timezone('Asia/Kolkata')
                    dt = dt.astimezone(ist).replace(tzinfo=None)
                return dt
            except:
                # Fallback to naive parsing
                return datetime.fromisoformat(date_str.replace('+00:00', '').replace('Z', ''))
        else:
            return datetime.strptime(date_str, '%Y-%m-%d %H:%M:%S')
    except ValueError:
        # Try multiple formats
        formats = [
            '%Y-%m-%d',
            '%Y-%m-%dT%H:%M:%S',
            '%Y-%m-%dT%H:%M:%S.%f',
            '%Y-%m-%d %H:%M',
            '%d/%m/%Y %H:%M:%S',
            '%d-%m-%Y %H:%M:%S'
        ]
        
        for fmt in formats:
            try:
                return datetime.strptime(date_str, fmt)
            except ValueError:
                continue
        
        raise ValueError(f"Unable to parse date string: {date_str}")

def adjust_for_first_fifteen_minutes(start_date, end_date):
    """Adjust dates for first 15 minutes of trading day with enhanced logic"""
    # Handle timezone conversion
    if start_date.tzinfo is not None:
        ist_offset = timedelta(hours=5, minutes=30)
        start_date = start_date.replace(tzinfo=None) + ist_offset
    
    # Market opens at 9:15 AM, so first 15 minutes is 9:15 to 9:30
    market_start = start_date.replace(hour=9, minute=15, second=0, microsecond=0)
    market_end = market_start + timedelta(minutes=15)  # Corrected: 15 minutes, not 375
    
    logger.info(f"Adjusted for first 15 minutes: {market_start} to {market_end}")
    
    return market_start, market_end

def validate_ohlcv_data(row):
    """Validate individual OHLCV data record"""
    try:
        open_price = float(row['open'])
        high_price = float(row['high'])
        low_price = float(row['low'])
        close_price = float(row['close'])
        volume = int(row['volume'])
        
        # Basic validation rules
        if any(x <= 0 for x in [open_price, high_price, low_price, close_price]):
            return False
        
        if volume < 0:
            return False
            
        if high_price < max(open_price, close_price) or low_price > min(open_price, close_price):
            return False
            
        # Check for extreme values (possible data errors)
        if high_price / low_price > 2.0:  # More than 100% intraday move
            return False
            
        return True
    except (ValueError, TypeError, KeyError):
        return False

def validate_aggregated_ohlc(open_price, high_price, low_price, close_price):
    """Validate aggregated OHLC data"""
    try:
        # High must be >= max(open, close)
        if high_price < max(open_price, close_price):
            return False
            
        # Low must be <= min(open, close)
        if low_price > min(open_price, close_price):
            return False
            
        # All prices must be positive
        if any(x <= 0 for x in [open_price, high_price, low_price, close_price]):
            return False
            
        return True
    except (ValueError, TypeError):
        return False

if __name__ == "__main__":
    main()


================================================================================
FILE 35/37: apps/backend/data/fyers_service_5001.py
CATEGORY: Python Services - Fyers Service
PURPOSE: Fyers API service on port 5001
PRIORITY: ?? PYTHON SERVICE
================================================================================

import eventlet
eventlet.monkey_patch()

import socketio
import json
import sys
import time
import datetime
import pytz
import threading
import logging
import requests
import numpy as np
import os
from collections import deque, defaultdict
from fyers_apiv3 import fyersModel
from fyers_apiv3.FyersWebsocket import data_ws

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger("FyersServer")

sio = socketio.Server(cors_allowed_origins='*', async_mode='eventlet')
app = socketio.WSGIApp(sio)

client_id = "150HUKJSWG-100"
secret_key = "18YYNXCAS7"
redirect_uri = "https://raghavjaiswal709.github.io/DAKSphere_redirect/"
response_type = "code"
grant_type = "authorization_code"

clients = {}
symbol_to_clients = {}
running = True
auth_initialized = False

# ============ ENHANCED: Multi-symbol persistent data storage ============
historical_data = {}           # All historical data for all symbols
ohlc_data = {}                # All OHLC data for all symbols
chart_updates = {}            # Real-time updates for all symbols
active_symbols = set()        # All symbols currently being tracked
symbol_subscriptions = defaultdict(int)  # Count of clients per symbol

MAX_HISTORY_POINTS = 50000    # Increased from 10000 for longer retention
MAX_CHART_UPDATES = 5000      # Keep more chart updates
DATA_RETENTION_HOURS = 24     # Keep data for 24 hours

INDIA_TZ = pytz.timezone('Asia/Kolkata')

fyers = None
fyers_client = None

# ============ ENHANCED: Real-time Configuration ============
REAL_TIME_INTERVAL = 0.2
CHART_UPDATE_INTERVAL = 0.1
last_emit_time = defaultdict(float)
pending_data = {}

# ============ ENHANCED: Persistent data management ============
cached_indicators = {}
data_cleanup_interval = 3600  # Cleanup every hour
last_cleanup_time = time.time()


def extract_jwt_token(full_token):
    """Extract JWT token from full token string."""
    if ':' in full_token:
        return full_token.split(':', 1)[1]
    else:
        return full_token


def initialize_fyers():
    """Initialize Fyers client and WebSocket with auto authentication."""
    global fyers_client, fyers, auth_initialized
    
    auth_file_path = os.path.join('data', 'fyers_data_auth.json')
    
    try:
        if not os.path.exists(auth_file_path):
            logger.info("‚ÑπÔ∏è No auth file found")
            return False
        
        with open(auth_file_path, 'r') as f:
            auth_data = json.load(f)
        
        full_access_token = auth_data.get('access_token')
        if not full_access_token:
            logger.error("‚ùå No access token found")
            return False
        
        jwt_token = extract_jwt_token(full_access_token)
        logger.info(f"üîç JWT token: {jwt_token[:30]}...")
        logger.info(f"üîç Full token: {full_access_token[:30]}...")
        
        # Initialize REST API client
        try:
            fyers_client = fyersModel.FyersModel(
                client_id=client_id,
                token=jwt_token,
                log_path=None
            )
            
            # Test connection
            response = fyers_client.get_profile()
            if response and response.get('s') == 'ok':
                user_data = response.get('data', {})
                user_name = user_data.get('name', 'Unknown')
                logger.info(f"‚úÖ REST API client initialized - User: {user_name}")
            else:
                logger.error(f"‚ùå REST API test failed: {response}")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå REST client error: {e}")
            return False
        
        # Initialize WebSocket client
        try:
            ws_token = full_access_token if ':' in full_access_token else f"{client_id}:{jwt_token}"
            
            fyers = data_ws.FyersDataSocket(
                access_token=ws_token,
                log_path="",
                litemode=False,
                write_to_file=False,
                reconnect=True,
                on_connect=onopen,
                on_close=onclose,
                on_error=onerror,
                on_message=onmessage
            )
            logger.info("‚úÖ WebSocket client initialized")
            
        except Exception as e:
            logger.error(f"‚ùå WebSocket initialization error: {e}")
            fyers = None
        
        auth_initialized = True
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Error loading auth: {e}")
        return False


def auth_watcher():
    """Watch auth file for updates and reinitialize when needed."""
    global running, auth_initialized, fyers
    auth_file_path = os.path.join('data', 'fyers_data_auth.json')
    last_modified = 0
    
    while running:
        try:
            if os.path.exists(auth_file_path):
                current_modified = os.path.getmtime(auth_file_path)
                if current_modified > last_modified or not auth_initialized:
                    if not auth_initialized or current_modified > last_modified:
                        logger.info("üîÑ Auth file updated, reinitializing...")
                        if initialize_fyers() and fyers:
                            try:
                                ws_thread = threading.Thread(target=lambda: fyers.connect(), daemon=True)
                                ws_thread.start()
                                logger.info("‚úÖ WebSocket connection started")
                                
                                # Resubscribe to all active symbols
                                if active_symbols and hasattr(fyers, 'subscribe'):
                                    symbols_list = list(active_symbols)
                                    fyers.subscribe(symbols=symbols_list, data_type="SymbolUpdate")
                                    logger.info(f"‚úÖ Resubscribed to {len(symbols_list)} symbols")
                            except Exception as e:
                                logger.error(f"‚ùå WebSocket start error: {e}")
                    last_modified = current_modified
            time.sleep(5)
        except Exception as e:
            logger.error(f"‚ùå Auth watcher error: {e}")
            time.sleep(10)


def cleanup_old_data():
    """Remove data older than DATA_RETENTION_HOURS"""
    global last_cleanup_time
    current_time = time.time()
    cutoff_time = current_time - (DATA_RETENTION_HOURS * 3600)

    if current_time - last_cleanup_time < data_cleanup_interval:
        return

    logger.info("Starting data cleanup...")
    cleaned_symbols = []

    for symbol in list(historical_data.keys()):
        if symbol in historical_data:
            # Keep only recent data
            recent_data = deque(maxlen=MAX_HISTORY_POINTS)
            for point in historical_data[symbol]:
                if point['timestamp'] > cutoff_time:
                    recent_data.append(point)

            if len(recent_data) > 0:
                historical_data[symbol] = recent_data
            else:
                # Remove completely old symbols that have no subscribers
                if symbol_subscriptions[symbol] == 0:
                    del historical_data[symbol]
                    cleaned_symbols.append(symbol)

        if symbol in ohlc_data:
            # Keep only recent OHLC data
            recent_ohlc = deque(maxlen=MAX_HISTORY_POINTS)
            for candle in ohlc_data[symbol]:
                if candle['timestamp'] > cutoff_time:
                    recent_ohlc.append(candle)

            if len(recent_ohlc) > 0:
                ohlc_data[symbol] = recent_ohlc
            elif symbol_subscriptions[symbol] == 0:
                if symbol in ohlc_data:
                    del ohlc_data[symbol]

        if symbol in chart_updates:
            # Keep only recent chart updates
            recent_updates = deque(maxlen=MAX_CHART_UPDATES)
            for update in chart_updates[symbol]:
                if update['timestamp'] > cutoff_time:
                    recent_updates.append(update)

            if len(recent_updates) > 0:
                chart_updates[symbol] = recent_updates
            elif symbol_subscriptions[symbol] == 0:
                if symbol in chart_updates:
                    del chart_updates[symbol]

    # Clean up cached indicators for removed symbols
    for symbol in cleaned_symbols:
        if symbol in cached_indicators:
            del cached_indicators[symbol]
        active_symbols.discard(symbol)

    last_cleanup_time = current_time
    logger.info(f"Data cleanup completed. Cleaned {len(cleaned_symbols)} old symbols.")


def get_trading_hours():
    now = datetime.datetime.now(INDIA_TZ)
    start_time = now.replace(hour=9, minute=15, second=0, microsecond=0)
    end_time = now.replace(hour=15, minute=30, second=0, microsecond=0)
    return start_time, end_time


def is_trading_hours():
    now = datetime.datetime.now(INDIA_TZ)
    start_time, end_time = get_trading_hours()

    if now.weekday() >= 5:
        return False

    return start_time <= now <= end_time


@sio.event
def connect(sid, environ):
    logger.info(f"Client connected: {sid}")
    clients[sid] = {'subscriptions': set(), 'last_ping': time.time()}
    
    # Send auth status to new client
    sio.emit('authStatus', {
        'authenticated': auth_initialized,
        'timestamp': int(time.time())
    }, room=sid)


@sio.event
def disconnect(sid):
    logger.info(f"Client disconnected: {sid}")
    if sid in clients:
        # Decrease subscription count for each symbol
        for symbol in clients[sid]['subscriptions']:
            if symbol in symbol_to_clients:
                symbol_to_clients[symbol].discard(sid)
            symbol_subscriptions[symbol] = max(0, symbol_subscriptions[symbol] - 1)

            # If no more clients, but keep collecting data in background for a while
            if symbol_subscriptions[symbol] == 0:
                logger.info(f"No more active clients for {symbol}, but keeping background collection")

        del clients[sid]


def fetch_historical_intraday_data(symbol, date=None):
    """Enhanced to always fetch and store data regardless of current subscriptions"""
    if not date:
        date = datetime.datetime.now(INDIA_TZ).strftime('%Y-%m-%d')

    try:
        if not fyers_client or not auth_initialized:
            logger.warning(f"Fyers client not initialized for {symbol}")
            return []
            
        date_obj = datetime.datetime.strptime(date, '%Y-%m-%d')
        date_obj = INDIA_TZ.localize(date_obj)

        market_open = date_obj.replace(hour=9, minute=15, second=0, microsecond=0)
        market_close = date_obj.replace(hour=15, minute=30, second=0, microsecond=0)

        now = datetime.datetime.now(INDIA_TZ)
        if date == now.strftime('%Y-%m-%d') and now < market_open:
            logger.info(f"Market not yet open for {date}")
            return []

        if date == now.strftime('%Y-%m-%d') and now < market_close:
            end_time = now
        else:
            end_time = market_close

        from_date = market_open.strftime('%Y-%m-%d %H:%M:%S')
        to_date = end_time.strftime('%Y-%m-%d %H:%M:%S')

        logger.info(f"Fetching historical data for {symbol} from {from_date} to {to_date}")

        data_args = {
            "symbol": symbol,
            "resolution": "1",
            "date_format": "1",
            "range_from": from_date,
            "range_to": to_date,
            "cont_flag": "1"
        }

        response = fyers_client.history(data_args)

        if response and response.get('s') == 'ok' and 'candles' in response:
            candles = response['candles']
            logger.info(f"Received {len(candles)} candles for {symbol}")

            result = []

            for candle in candles:
                timestamp, open_price, high_price, low_price, close_price, volume = candle

                if timestamp > 10000000000:
                    timestamp = timestamp // 1000

                data_point = {
                    'symbol': symbol,
                    'ltp': close_price,
                    'open': open_price,
                    'high': high_price,
                    'low': low_price,
                    'close': close_price,
                    'volume': volume,
                    'timestamp': timestamp,
                    'change': 0,
                    'changePercent': 0
                }

                result.append(data_point)

                # ============ ENHANCED: Always store regardless of active subscriptions ============
                if symbol not in ohlc_data:
                    ohlc_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)

                minute_timestamp = (timestamp // 60) * 60

                ohlc_candle = {
                    'timestamp': minute_timestamp,
                    'open': open_price,
                    'high': high_price,
                    'low': low_price,
                    'close': close_price,
                    'volume': volume
                }

                if not ohlc_data[symbol] or ohlc_data[symbol][-1]['timestamp'] != minute_timestamp:
                    ohlc_data[symbol].append(ohlc_candle)

            if result:
                prev_close = result[0]['open']
                for point in result:
                    point['change'] = point['ltp'] - prev_close
                    point['changePercent'] = (point['change'] / prev_close) * 100 if prev_close else 0

            if result:
                calculate_indicators_optimized(symbol, init=True)
                # Mark symbol as active for background collection
                active_symbols.add(symbol)

            return result
        else:
            logger.error(f"Failed to fetch historical data: {response}")

        return []

    except Exception as e:
        logger.error(f"Error fetching historical data: {e}")
        import traceback
        traceback.print_exc()
        return []


def fetch_daily_historical_data(symbol, days=30):
    try:
        if not fyers_client or not auth_initialized:
            logger.error("Fyers client not initialized")
            return []
        
        end_date = datetime.datetime.now(INDIA_TZ)
        start_date = end_date - datetime.timedelta(days=days)
        
        data_args = {
            "symbol": symbol,
            "resolution": "D",
            "date_format": "1",
            "range_from": start_date.strftime('%Y-%m-%d'),
            "range_to": end_date.strftime('%Y-%m-%d'),
            "cont_flag": "1"
        }
        
        response = fyers_client.history(data_args)
        
        if response and response.get('s') == 'ok' and 'candles' in response:
            return response['candles']
        else:
            logger.error(f"Failed to fetch daily historical data: {response}")
            return []
            
    except Exception as e:
        logger.error(f"Error fetching daily historical data: {e}")
        return []


@sio.event
def subscribe(sid, data):
    symbol = data.get('symbol')
    if not symbol:
        return {'success': False, 'error': 'No symbol provided'}
    
    if not auth_initialized:
        return {'success': False, 'error': 'Authentication not initialized'}

    logger.info(f"Client {sid} subscribing to {symbol}")

    clients[sid]['subscriptions'].add(symbol)
    if symbol not in symbol_to_clients:
        symbol_to_clients[symbol] = set()
    symbol_to_clients[symbol].add(sid)

    # Increase subscription count
    symbol_subscriptions[symbol] += 1
    active_symbols.add(symbol)

    # ============ ENHANCED: Check if we already have cached data ============
    if symbol not in historical_data or not historical_data[symbol]:
        logger.info(f"Fetching fresh historical data for {symbol}")
        hist_data = fetch_historical_intraday_data(symbol)

        if symbol not in historical_data:
            historical_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)

        for data_point in hist_data:
            historical_data[symbol].append(data_point)
    else:
        logger.info(f"Using cached historical data for {symbol} ({len(historical_data[symbol])} points)")

    # Subscribe to real-time updates if not already subscribed
    if fyers and hasattr(fyers, 'subscribe') and callable(fyers.subscribe):
        logger.info(f"Subscribing to real-time updates for: {symbol}")
        try:
            fyers.subscribe(symbols=[symbol], data_type="SymbolUpdate")
        except Exception as e:
            logger.error(f"Error subscribing to {symbol}: {e}")

    # Send all available data to client
    if symbol in historical_data and historical_data[symbol]:
        logger.info(f"Sending {len(historical_data[symbol])} historical data points for {symbol}")
        hist_data_list = list(historical_data[symbol])
        sio.emit('historicalData', {
            'symbol': symbol,
            'data': hist_data_list
        }, room=sid)

    if symbol in ohlc_data and ohlc_data[symbol]:
        logger.info(f"Sending {len(ohlc_data[symbol])} OHLC data points for {symbol}")
        sio.emit('ohlcData', {
            'symbol': symbol,
            'data': list(ohlc_data[symbol])
        }, room=sid)

    # Send cached chart updates if available
    if symbol in chart_updates and chart_updates[symbol]:
        logger.info(f"Sending {len(chart_updates[symbol])} cached chart updates for {symbol}")
        sio.emit('chartUpdatesHistory', {
            'symbol': symbol,
            'data': list(chart_updates[symbol])
        }, room=sid)

    return {'success': True, 'symbol': symbol, 'cached_points': len(historical_data.get(symbol, []))}


@sio.event
def unsubscribe(sid, data):
    symbol = data.get('symbol')
    if not symbol:
        return {'success': False, 'error': 'No symbol provided'}

    logger.info(f"Client {sid} unsubscribing from {symbol}")

    if sid in clients:
        clients[sid]['subscriptions'].discard(symbol)

    if symbol in symbol_to_clients:
        symbol_to_clients[symbol].discard(sid)

        # Decrease subscription count but don't unsubscribe from Fyers immediately
        symbol_subscriptions[symbol] = max(0, symbol_subscriptions[symbol] - 1)

        # Keep collecting data for a while even if no active clients
        if symbol_subscriptions[symbol] == 0:
            logger.info(f"No more clients for {symbol}, but keeping background data collection")
            # Note: We intentionally don't unsubscribe from Fyers to keep background collection

    return {'success': True, 'symbol': symbol}


@sio.event
def get_trading_status(sid, data):
    start_time, end_time = get_trading_hours()
    return {
        'trading_active': is_trading_hours(),
        'trading_start': start_time.isoformat(),
        'trading_end': end_time.isoformat(),
        'current_time': datetime.datetime.now(INDIA_TZ).isoformat(),
        'is_market_day': datetime.datetime.now(INDIA_TZ).weekday() < 5,
        'active_symbols': list(active_symbols),
        'total_data_points': sum(len(data) for data in historical_data.values()),
        'auth_status': auth_initialized
    }


@sio.event
def get_historical_data_for_date(sid, data):
    symbol = data.get('symbol')
    date = data.get('date')
    
    if not symbol:
        return {'success': False, 'error': 'No symbol provided'}
    
    if not auth_initialized:
        return {'success': False, 'error': 'Authentication not initialized'}
    
    if not date:
        date = datetime.datetime.now(INDIA_TZ).strftime('%Y-%m-%d')
    
    try:
        hist_data = fetch_historical_intraday_data(symbol, date)
        
        return {
            'success': True,
            'symbol': symbol,
            'date': date,
            'data': hist_data
        }
    except Exception as e:
        logger.error(f"Error fetching historical data for date: {e}")
        return {'success': False, 'error': str(e)}


@sio.event
def get_daily_data(sid, data):
    symbol = data.get('symbol')
    days = data.get('days', 30)
    
    if not symbol:
        return {'success': False, 'error': 'No symbol provided'}
    
    if not auth_initialized:
        return {'success': False, 'error': 'Authentication not initialized'}
    
    try:
        daily_data = fetch_daily_historical_data(symbol, days)
        
        if daily_data:
            formatted_data = []
            for candle in daily_data:
                timestamp, open_price, high_price, low_price, close_price, volume = candle
                formatted_data.append({
                    'timestamp': timestamp,
                    'open': open_price,
                    'high': high_price,
                    'low': low_price,
                    'close': close_price,
                    'volume': volume
                })
            
            return {
                'success': True,
                'symbol': symbol,
                'days': days,
                'data': formatted_data
            }
        else:
            return {'success': False, 'error': 'No data available'}
    except Exception as e:
        logger.error(f"Error fetching daily data: {e}")
        return {'success': False, 'error': str(e)}


def store_historical_data(symbol, data_point):
    """Enhanced to store data for ALL active symbols"""
    if symbol not in historical_data:
        historical_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)

    if 'timestamp' not in data_point:
        data_point['timestamp'] = int(time.time())

    historical_data[symbol].append(data_point)
    update_ohlc_data(symbol, data_point)

    # Also store in chart updates for smooth transitions
    if symbol not in chart_updates:
        chart_updates[symbol] = deque(maxlen=MAX_CHART_UPDATES)

    chart_update = {
        'symbol': symbol,
        'price': data_point['ltp'],
        'timestamp': data_point['timestamp'],
        'volume': data_point.get('volume', 0),
        'change': data_point.get('change', 0),
        'changePercent': data_point.get('changePercent', 0)
    }
    chart_updates[symbol].append(chart_update)


def update_ohlc_data(symbol, data_point):
    if symbol not in ohlc_data:
        ohlc_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)

    timestamp = data_point['timestamp']
    price = data_point['ltp']

    minute_timestamp = (timestamp // 60) * 60

    if not ohlc_data[symbol] or ohlc_data[symbol][-1]['timestamp'] < minute_timestamp:
        ohlc_data[symbol].append({
            'timestamp': minute_timestamp,
            'open': price,
            'high': price,
            'low': price,
            'close': price,
            'volume': data_point.get('volume', 0)
        })
    else:
        current_candle = ohlc_data[symbol][-1]
        current_candle['high'] = max(current_candle['high'], price)
        current_candle['low'] = min(current_candle['low'], price)
        current_candle['close'] = price
        current_candle['volume'] = data_point.get('volume', current_candle['volume'])


def calculate_indicators_optimized(symbol, init=False):
    if symbol not in ohlc_data or len(ohlc_data[symbol]) < 20:
        return {}

    latest_close = ohlc_data[symbol][-1]['close']

    if symbol not in cached_indicators or init:
        closes = np.array([candle['close'] for candle in ohlc_data[symbol]])

        sma_20 = np.mean(closes[-20:]) if len(closes) >= 20 else latest_close

        if len(closes) >= 9:
            ema_9 = closes[0]
            alpha = 2 / (9 + 1)
            for price in closes[1:]:
                ema_9 = alpha * price + (1 - alpha) * ema_9
        else:
            ema_9 = latest_close

        if len(closes) >= 15:
            changes = np.diff(closes)
            gains = np.where(changes > 0, changes, 0)
            losses = np.where(changes < 0, -changes, 0)

            avg_gain = np.mean(gains[-14:])
            avg_loss = np.mean(losses[-14:])

            if avg_loss == 0:
                rsi = 100
            else:
                rs = avg_gain / avg_loss
                rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50

        cached_indicators[symbol] = {
            'sma_20': float(sma_20),
            'ema_9': float(ema_9),
            'rsi_14': float(rsi),
            'avg_gain': avg_gain if len(closes) >= 15 else 0,
            'avg_loss': avg_loss if len(closes) >= 15 else 0,
            'prev_close': latest_close
        }
    else:
        cache = cached_indicators[symbol]
        prev_close = cache['prev_close']

        if len(ohlc_data[symbol]) >= 20:
            old_sma = cache['sma_20']
            cache['sma_20'] = old_sma + (latest_close - old_sma) / 20

        alpha = 2 / (9 + 1)
        cache['ema_9'] = alpha * latest_close + (1 - alpha) * cache['ema_9']

        change = latest_close - prev_close
        gain = max(0, change)
        loss = max(0, -change)

        cache['avg_gain'] = (cache['avg_gain'] * 13 + gain) / 14
        cache['avg_loss'] = (cache['avg_loss'] * 13 + loss) / 14

        if cache['avg_loss'] == 0:
            cache['rsi_14'] = 100
        else:
            rs = cache['avg_gain'] / cache['avg_loss']
            cache['rsi_14'] = 100 - (100 / (1 + rs))

        cache['prev_close'] = latest_close

    return {
        'sma_20': cached_indicators[symbol]['sma_20'],
        'ema_9': cached_indicators[symbol]['ema_9'],
        'rsi_14': cached_indicators[symbol]['rsi_14']
    }


# ============ ENHANCED: Background data collection for all symbols ============
def emit_real_time_data():
    """Enhanced to emit data for all symbols and manage background collection"""
    global running
    while running:
        try:
            current_time = time.time()

            # Cleanup old data periodically
            cleanup_old_data()

            # Emit data for all symbols that have pending updates
            for symbol in list(pending_data.keys()):
                # Always store data regardless of active clients
                if symbol in pending_data:
                    data = pending_data[symbol].copy()

                    # Emit to subscribed clients if any
                    if symbol in symbol_to_clients and symbol_to_clients[symbol]:
                        if current_time - last_emit_time[symbol] >= REAL_TIME_INTERVAL:
                            for sid in list(symbol_to_clients[symbol]):
                                try:
                                    sio.emit('marketDataUpdate', data, room=sid)

                                    # Send chart-specific update
                                    chart_update = {
                                        'symbol': symbol,
                                        'price': data['ltp'],
                                        'timestamp': data['timestamp'],
                                        'volume': data.get('volume', 0),
                                        'change': data.get('change', 0),
                                        'changePercent': data.get('changePercent', 0)
                                    }
                                    sio.emit('chartUpdate', chart_update, room=sid)

                                except Exception as e:
                                    logger.error(f"Error sending data to client {sid}: {e}")

                            last_emit_time[symbol] = current_time

                    # Always store data even if no active clients (background collection)
                    store_historical_data(symbol, data)

            eventlet.sleep(CHART_UPDATE_INTERVAL)

        except Exception as e:
            logger.error(f"Error in real-time emission: {e}")
            eventlet.sleep(0.1)


def onmessage(message):
    """Enhanced to handle ALL symbols, not just subscribed ones"""
    if not isinstance(message, dict) or 'symbol' not in message:
        return

    symbol = message['symbol']

    if message.get('type') == 'sub':
        logger.info(f"Subscription confirmation: {symbol}")
        return

    # Always add symbol to active symbols when we receive data
    active_symbols.add(symbol)

    # Create optimized data structure
    simplified_data = {
        'symbol': symbol,
        'ltp': message.get('ltp'),
        'change': message.get('ch'),
        'changePercent': message.get('chp'),
        'volume': message.get('vol_traded_today'),
        'open': message.get('open_price'),
        'high': message.get('high_price'),
        'low': message.get('low_price'),
        'close': message.get('prev_close_price'),
        'bid': message.get('bid_price'),
        'ask': message.get('ask_price'),
        'timestamp': message.get('last_traded_time') or int(time.time())
    }

    # Calculate indicators with caching
    indicators = calculate_indicators_optimized(symbol)
    if indicators:
        simplified_data.update(indicators)

    # Store for ALL symbols (background + active)
    pending_data[symbol] = simplified_data

    eventlet.sleep(0)


def onerror(error):
    logger.error(f"Error: {error}")
    sio.emit('error', {'message': str(error)})


def onclose(message):
    logger.info(f"Connection closed: {message}")
    sio.emit('fyersDisconnected', {'message': str(message)})


def onopen():
    logger.info("Fyers WebSocket connected")
    sio.emit('fyersConnected', {'status': 'connected'})

    # Subscribe to all active symbols (including background ones)
    symbols_to_subscribe = list(active_symbols) if active_symbols else []
    if symbols_to_subscribe and fyers and hasattr(fyers, 'subscribe'):
        try:
            fyers.subscribe(symbols=symbols_to_subscribe, data_type="SymbolUpdate")
            logger.info(f"Subscribed to {len(symbols_to_subscribe)} symbols for background collection")
        except Exception as e:
            logger.error(f"Error subscribing to symbols: {e}")


def heartbeat_task():
    global running
    while running:
        try:
            sio.emit('heartbeat', {
                'timestamp': int(time.time()),
                'trading_active': is_trading_hours(),
                'server_time': datetime.datetime.now(INDIA_TZ).isoformat(),
                'active_symbols': list(active_symbols),
                'total_cached_points': sum(len(data) for data in historical_data.values()),
                'background_collection': True,
                'auth_status': auth_initialized
            })
            eventlet.sleep(10)
        except Exception as e:
            logger.error(f"Error in heartbeat: {e}")


def main_process():
    global fyers, fyers_client, running

    try:
        # Create data directory
        os.makedirs('data', exist_ok=True)
        
        # Try initial authentication
        if initialize_fyers():
            logger.info("‚úÖ Initial authentication successful")
            
            if fyers:
                ws_thread = threading.Thread(target=lambda: fyers.connect(), daemon=True)
                ws_thread.start()
                logger.info("‚úÖ WebSocket connection started")
        else:
            logger.info("‚ö†Ô∏è Initial authentication failed, will retry when auth file updates")
        
        # Start auth watcher
        auth_thread = threading.Thread(target=auth_watcher, daemon=True)
        auth_thread.start()

        # Start heartbeat
        heartbeat_thread = threading.Thread(target=heartbeat_task, daemon=True)
        heartbeat_thread.start()

        # Start real-time data emission
        emission_thread = threading.Thread(target=emit_real_time_data, daemon=True)
        emission_thread.start()

        logger.info("‚úÖ Starting enhanced Socket.IO server with persistent multi-symbol data on port 5001...")
        logger.info("üîë Using auto authentication with JWT token handling")
        logger.info("üìä Features: Background collection, 24h retention, optimized indicators")
        eventlet.wsgi.server(eventlet.listen(('0.0.0.0', 5001)), app)

    except Exception as e:
        logger.error(f"Error: {e}")
        import traceback
        traceback.print_exc()


def main():
    global running

    try:
        eventlet.spawn(main_process)

        while running:
            eventlet.sleep(0.1)
    except KeyboardInterrupt:
        logger.info("Shutting down enhanced server...")
        running = False


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logger.info("Shutting down enhanced server...")
        running = False



================================================================================
FILE 36/37: apps/backend/data/fyers_service_5010.py
CATEGORY: Python Services - Fyers Service
PURPOSE: Fyers API service on port 5010
PRIORITY: ?? PYTHON SERVICE
================================================================================

import eventlet
eventlet.monkey_patch()

import socketio
import json
import sys
import time
import datetime
import pytz
import threading
import logging
import requests
import numpy as np
import os
from collections import deque
from fyers_apiv3 import fyersModel
from fyers_apiv3.FyersWebsocket import data_ws
import pandas as pd

# Enhanced logging configuration
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger("LiveMarketServer")

# Socket.IO setup with enhanced CORS
sio = socketio.Server(
    cors_allowed_origins='*', 
    async_mode='eventlet',
    logger=True,
    engineio_logger=True
)
app = socketio.WSGIApp(sio)

# Fyers API credentials
client_id = "150HUKJSWG-100"
secret_key = "18YYNXCAS7"
redirect_uri = "https://daksphere.com/"
response_type = "code"
grant_type = "authorization_code"

# Global variables
clients = {}
symbol_to_clients = {}
active_subscriptions = set()
running = True
historical_data = {}
ohlc_data = {}
real_time_data = {}
MAX_HISTORY_POINTS = 10000
MAX_COMPANIES = 6
INDIA_TZ = pytz.timezone('Asia/Kolkata')
fyers = None
fyers_client = None
available_symbols = []
last_tick = {}
auth_initialized = False

MONITORED_FIELDS = [
    'ltp', 'vol_traded_today', 'last_traded_time', 'bid_size', 'ask_size',
    'bid_price', 'ask_price', 'low_price', 'high_price', 'open_price', 'prev_close_price'
]


def extract_jwt_token(full_token):
    """Extract JWT token from full token string."""
    if ':' in full_token:
        return full_token.split(':', 1)[1]
    else:
        return full_token


def load_available_symbols():
    """Load available symbols from watchlist A - optional, fallback to empty."""
    global available_symbols
    try:
        csv_path = os.path.join(os.path.dirname(__file__), 'data', 'watchlists', 'watchlist_A_2025-02-16.csv')
        
        # Try alternative paths if main path doesn't exist
        if not os.path.exists(csv_path):
            csv_path = 'apps/backend/data/watchlists/watchlist_A_2025-02-16.csv'
        
        if not os.path.exists(csv_path):
            csv_path = 'data/watchlists/watchlist_A_2025-02-16.csv'
        
        if not os.path.exists(csv_path):
            # No hardcoded symbols - completely dynamic
            logger.info("No watchlist file found - operating in dynamic mode")
            available_symbols = []
            return True
        else:
            df = pd.read_csv(csv_path)
        
        available_symbols = []
        for _, row in df.iterrows():
            symbol_data = {
                'symbol': f"{row.get('Exchange', 'NSE')}:{row['company_code']}-{row.get('marker', 'EQ')}",
                'company_code': row['company_code'],
                'name': row.get('name', row['company_code']),
                'exchange': row.get('Exchange', 'NSE'),
                'marker': row.get('marker', 'EQ')
            }
            available_symbols.append(symbol_data)
        
        logger.info(f"Loaded {len(available_symbols)} available symbols from watchlist")
        return True
        
    except Exception as e:
        logger.error(f"Error loading symbols: {e}")
        # No fallback symbols - completely empty
        available_symbols = []
        logger.info("Operating in fully dynamic mode - no predefined symbols")
        return True


def get_trading_hours():
    """Get market trading hours in IST."""
    now = datetime.datetime.now(INDIA_TZ)
    start_time = now.replace(hour=9, minute=15, second=0, microsecond=0)
    end_time = now.replace(hour=15, minute=30, second=0, microsecond=0)
    return start_time, end_time


def is_trading_hours():
    """Check if current time is within trading hours."""
    now = datetime.datetime.now(INDIA_TZ)
    start_time, end_time = get_trading_hours()
    if now.weekday() >= 5:  # Saturday or Sunday
        return False
    return start_time <= now <= end_time


def safe_symbol_parse(symbol):
    """Safely parse symbol string to extract exchange and company code."""
    try:
        if ':' not in symbol:
            logger.warning(f"Invalid symbol format (no colon): {symbol}")
            return None, None
        
        parts = symbol.split(':', 1)
        if len(parts) != 2:
            logger.warning(f"Invalid symbol format: {symbol}")
            return None, None
            
        exchange = parts[0]
        code_part = parts[1]
        
        if '-' not in code_part:
            logger.warning(f"Invalid code part (no hyphen): {code_part}")
            return exchange, code_part
        
        company_code = code_part.split('-')[0]
        return exchange, company_code
        
    except Exception as e:
        logger.error(f"Error parsing symbol {symbol}: {e}")
        return None, None


def create_symbol_from_code(company_code, exchange='NSE', marker='EQ'):
    """Create a full Fyers symbol from company code."""
    return f"{exchange}:{company_code}-{marker}"


def add_symbol_to_available(company_code, exchange='NSE', marker='EQ', name=None):
    """Dynamically add a symbol to available symbols if not exists."""
    global available_symbols
    
    symbol = create_symbol_from_code(company_code, exchange, marker)
    
    # Check if symbol already exists
    existing = next((s for s in available_symbols if s['symbol'] == symbol), None)
    if not existing:
        symbol_data = {
            'symbol': symbol,
            'company_code': company_code,
            'name': name or company_code,
            'exchange': exchange,
            'marker': marker
        }
        available_symbols.append(symbol_data)
        logger.info(f"Dynamically added symbol: {symbol}")
        return symbol_data
    return existing


def initialize_fyers():
    """Initialize Fyers client and WebSocket with auto authentication."""
    global fyers_client, fyers, auth_initialized
    
    auth_file_path = os.path.join('data', 'fyers_data_auth.json')
    
    try:
        if not os.path.exists(auth_file_path):
            logger.info("‚ÑπÔ∏è No auth file found")
            return False
        
        with open(auth_file_path, 'r') as f:
            auth_data = json.load(f)
        
        full_access_token = auth_data.get('access_token')
        if not full_access_token:
            logger.error("‚ùå No access token found")
            return False
        
        jwt_token = extract_jwt_token(full_access_token)
        logger.info(f"üîç JWT token: {jwt_token[:30]}...")
        logger.info(f"üîç Full token: {full_access_token[:30]}...")
        
        # Initialize REST API client
        try:
            fyers_client = fyersModel.FyersModel(
                client_id=client_id,
                token=jwt_token,
                log_path=""
            )
            
            # Test connection
            response = fyers_client.get_profile()
            if response and response.get('s') == 'ok':
                user_data = response.get('data', {})
                user_name = user_data.get('name', 'Unknown')
                logger.info(f"‚úÖ REST API client initialized - User: {user_name}")
            else:
                logger.error(f"‚ùå REST API test failed: {response}")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå REST client error: {e}")
            return False
        
        # Initialize WebSocket client
        try:
            ws_token = full_access_token if ':' in full_access_token else f"{client_id}:{jwt_token}"
            
            fyers = data_ws.FyersDataSocket(
                access_token=ws_token,
                log_path="",
                litemode=False,
                write_to_file=False,
                reconnect=True,
                on_connect=onopen,
                on_close=onclose,
                on_error=onerror,
                on_message=onmessage
            )
            logger.info("‚úÖ WebSocket client initialized")
            
        except Exception as e:
            logger.error(f"‚ùå WebSocket initialization error: {e}")
            fyers = None
        
        auth_initialized = True
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Error loading auth: {e}")
        return False


def auth_watcher():
    """Watch auth file for updates and reinitialize when needed."""
    global running, auth_initialized, fyers
    auth_file_path = os.path.join('data', 'fyers_data_auth.json')
    last_modified = 0
    
    while running:
        try:
            if os.path.exists(auth_file_path):
                current_modified = os.path.getmtime(auth_file_path)
                if current_modified > last_modified or not auth_initialized:
                    if not auth_initialized or current_modified > last_modified:
                        logger.info("üîÑ Auth file updated, reinitializing...")
                        if initialize_fyers() and fyers:
                            try:
                                ws_thread = threading.Thread(target=lambda: fyers.connect(), daemon=True)
                                ws_thread.start()
                                logger.info("‚úÖ WebSocket connection started")
                                
                                # Resubscribe to all active symbols
                                if active_subscriptions and hasattr(fyers, 'subscribe'):
                                    symbols_list = list(active_subscriptions)
                                    fyers.subscribe(symbols=symbols_list, data_type="SymbolUpdate")
                                    logger.info(f"‚úÖ Resubscribed to {len(symbols_list)} symbols")
                            except Exception as e:
                                logger.error(f"‚ùå WebSocket start error: {e}")
                    last_modified = current_modified
            time.sleep(5)
        except Exception as e:
            logger.error(f"‚ùå Auth watcher error: {e}")
            time.sleep(10)


@sio.event
def connect(sid, environ):
    """Handle client connection."""
    logger.info(f"Client connected: {sid}")
    clients[sid] = {
        'subscriptions': set(),
        'connected_at': datetime.datetime.now(INDIA_TZ),
        'last_activity': datetime.datetime.now(INDIA_TZ)
    }
    
    # Send available symbols to client (may be empty initially)
    sio.emit('availableSymbols', {
        'symbols': available_symbols,
        'maxCompanies': MAX_COMPANIES,
        'tradingHours': {
            'isActive': is_trading_hours(),
            'start': get_trading_hours()[0].isoformat(),
            'end': get_trading_hours()[1].isoformat()
        },
        'authStatus': auth_initialized
    }, room=sid)


@sio.event
def disconnect(sid):
    """Handle client disconnection."""
    logger.info(f"Client disconnected: {sid}")
    if sid in clients:
        # Clean up subscriptions
        for symbol in clients[sid]['subscriptions']:
            if symbol in symbol_to_clients:
                symbol_to_clients[symbol].discard(sid)
                
                # If no more clients for this symbol, unsubscribe from Fyers
                if not symbol_to_clients[symbol]:
                    active_subscriptions.discard(symbol)
                    logger.info(f"Removed {symbol} from active subscriptions")
        
        del clients[sid]
    
    # Update Fyers subscription if needed
    update_fyers_subscription()


@sio.event
def subscribe_companies(sid, data):
    """FIXED: Subscribe to selected companies with enhanced validation."""
    try:
        logger.info(f"üì° Received subscription request from {sid}: {data}")
        
        # FIXED: Extract companyCodes from data
        company_codes = data.get('companyCodes', [])
        logger.info(f"üì° Raw company codes: {company_codes}")
        
        # FIXED: Validate data structure
        if not isinstance(company_codes, list):
            logger.error(f"‚ùå Invalid data type for companyCodes: {type(company_codes)}")
            sio.emit('error', {'message': 'companyCodes must be an array'}, room=sid)
            return
        
        # FIXED: Simplified validation - accept any non-empty string
        valid_company_codes = []
        for code in company_codes:
            if isinstance(code, str) and code.strip():
                valid_company_codes.append(code.strip().upper())
            else:
                logger.warning(f"‚ö†Ô∏è Skipping invalid company code: {code}")
        
        logger.info(f"‚úÖ Valid company codes after filtering: {valid_company_codes}")
        
        # FIXED: Check limits
        if len(valid_company_codes) > MAX_COMPANIES:
            logger.error(f"‚ùå Too many companies requested: {len(valid_company_codes)}")
            sio.emit('error', {'message': f'Maximum {MAX_COMPANIES} companies allowed'}, room=sid)
            return
        
        if len(valid_company_codes) == 0:
            logger.error(f"‚ùå No valid company codes provided")
            sio.emit('error', {'message': 'At least 1 valid company code must be provided'}, room=sid)
            return
        
        # FIXED: Clear existing subscriptions for this client
        if sid in clients:
            for symbol in clients[sid]['subscriptions']:
                if symbol in symbol_to_clients:
                    symbol_to_clients[symbol].discard(sid)
                    if not symbol_to_clients[symbol]:
                        active_subscriptions.discard(symbol)
            clients[sid]['subscriptions'].clear()
        
        # FIXED: Process valid company codes and create symbols
        requested_symbols = []
        for company_code in valid_company_codes:
            logger.info(f"üì° Processing company code: {company_code}")
            
            # Try to find in existing available symbols
            symbol_data = next(
                (s for s in available_symbols if s['company_code'] == company_code),
                None
            )
            
            if symbol_data:
                requested_symbols.append(symbol_data['symbol'])
                logger.info(f"‚úÖ Found existing symbol for {company_code}: {symbol_data['symbol']}")
            else:
                # Dynamically create symbol
                new_symbol_data = add_symbol_to_available(company_code)
                requested_symbols.append(new_symbol_data['symbol'])
                logger.info(f"‚úÖ Dynamically created symbol for {company_code}: {new_symbol_data['symbol']}")
        
        logger.info(f"üì° Final requested symbols: {requested_symbols}")
        
        # FIXED: Update client subscriptions
        if sid not in clients:
            clients[sid] = {
                'subscriptions': set(),
                'connected_at': datetime.datetime.now(INDIA_TZ),
                'last_activity': datetime.datetime.now(INDIA_TZ)
            }
        
        # Add symbols to client subscriptions
        for symbol in requested_symbols:
            clients[sid]['subscriptions'].add(symbol)
            
            # Add to symbol_to_clients mapping
            if symbol not in symbol_to_clients:
                symbol_to_clients[symbol] = set()
            symbol_to_clients[symbol].add(sid)
            
            # Add to active subscriptions
            active_subscriptions.add(symbol)
            logger.info(f"‚úÖ Added {symbol} to active subscriptions")
        
        # FIXED: Update Fyers subscription
        update_fyers_subscription()
        
        # FIXED: Send historical data for each symbol
        def fetch_all_data():
            for symbol in requested_symbols:
                try:
                    # Check if we already have historical data
                    if symbol in historical_data and historical_data[symbol]:
                        sio.emit('historicalData', {
                            'symbol': symbol,
                            'data': list(historical_data[symbol])
                        }, room=sid)
                    else:
                        # Fetch historical data on demand
                        logger.info(f"üìä Fetching historical data for {symbol}")
                        hist_data = fetch_historical_intraday_data(symbol)
                        if hist_data:
                            if symbol not in historical_data:
                                historical_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)
                            
                            for data_point in hist_data:
                                historical_data[symbol].append(data_point)
                            
                            sio.emit('historicalData', {
                                'symbol': symbol,
                                'data': hist_data
                            }, room=sid)
                        else:
                            sio.emit('historicalData', {
                                'symbol': symbol,
                                'data': []
                            }, room=sid)
                    
                    time.sleep(0.2)  # Small delay between requests
                except Exception as e:
                    logger.error(f"Error fetching data for {symbol}: {e}")
        
        # Start background fetching
        threading.Thread(target=fetch_all_data, daemon=True).start()
        
        # FIXED: Send subscription confirmation
        sio.emit('subscriptionConfirm', {
            'success': True,
            'symbols': requested_symbols,
            'count': len(requested_symbols)
        }, room=sid)
        
        logger.info(f"‚úÖ Successfully subscribed client {sid} to {len(requested_symbols)} symbols")
        
    except Exception as e:
        logger.error(f"‚ùå Error in subscribe_companies: {e}")
        import traceback
        traceback.print_exc()
        sio.emit('error', {'message': f'Subscription failed: {str(e)}'}, room=sid)


@sio.event
def unsubscribe_all(sid, data):
    """Unsubscribe from all companies."""
    try:
        logger.info(f"üì° Unsubscribing all for client {sid}")
        
        if sid in clients:
            for symbol in clients[sid]['subscriptions']:
                if symbol in symbol_to_clients:
                    symbol_to_clients[symbol].discard(sid)
                    if not symbol_to_clients[symbol]:
                        active_subscriptions.discard(symbol)
            
            clients[sid]['subscriptions'].clear()
        
        update_fyers_subscription()
        
        sio.emit('subscriptionConfirm', {
            'success': True,
            'symbols': [],
            'count': 0
        }, room=sid)
        
        logger.info(f"‚úÖ Client {sid} unsubscribed from all symbols")
        
    except Exception as e:
        logger.error(f"‚ùå Error in unsubscribe_all: {e}")
        sio.emit('error', {'message': f'Unsubscription failed: {str(e)}'}, room=sid)


@sio.event
def get_market_status(sid, data):
    """Get current market status."""
    try:
        start_time, end_time = get_trading_hours()
        sio.emit('marketStatus', {
            'trading_active': is_trading_hours(),
            'trading_start': start_time.isoformat(),
            'trading_end': end_time.isoformat(),
            'current_time': datetime.datetime.now(INDIA_TZ).isoformat(),
            'is_market_day': datetime.datetime.now(INDIA_TZ).weekday() < 5,
            'active_subscriptions': len(active_subscriptions),
            'connected_clients': len(clients),
            'auth_status': auth_initialized
        }, room=sid)
    except Exception as e:
        logger.error(f"‚ùå Error in get_market_status: {e}")
        sio.emit('error', {'message': f'Failed to get market status: {str(e)}'}, room=sid)


def update_fyers_subscription():
    """Update Fyers WebSocket subscription based on active subscriptions."""
    if not fyers:
        logger.warning("Fyers not initialized, cannot update subscription")
        return
    
    try:
        current_symbols = list(active_subscriptions)
        if current_symbols:
            logger.info(f"üîÑ Updating Fyers subscription with {len(current_symbols)} symbols")
            fyers.subscribe(symbols=current_symbols, data_type="SymbolUpdate")
            logger.info(f"‚úÖ Updated Fyers subscription: {current_symbols}")
        else:
            logger.info("üì° No active subscriptions, keeping minimal connection")
    except Exception as e:
        logger.error(f"‚ùå Error updating Fyers subscription: {e}")


def fetch_historical_intraday_data(symbol, date=None):
    """Fetch historical intraday data for a symbol on demand."""
    if not date:
        date = datetime.datetime.now(INDIA_TZ).strftime('%Y-%m-%d')
    
    try:
        if not fyers_client or not auth_initialized:
            logger.warning(f"Fyers client not initialized for {symbol}")
            return []
        
        date_obj = datetime.datetime.strptime(date, '%Y-%m-%d')
        date_obj = INDIA_TZ.localize(date_obj)
        
        market_open = date_obj.replace(hour=9, minute=15, second=0, microsecond=0)
        market_close = date_obj.replace(hour=15, minute=30, second=0, microsecond=0)
        
        now = datetime.datetime.now(INDIA_TZ)
        if date == now.strftime('%Y-%m-%d') and now < market_open:
            logger.info(f"Market not yet open for {date}")
            return []
        
        end_time = min(now, market_close) if date == now.strftime('%Y-%m-%d') else market_close
        
        from_date = market_open.strftime('%Y-%m-%d %H:%M:%S')
        to_date = end_time.strftime('%Y-%m-%d %H:%M:%S')
        
        logger.info(f"üìä Fetching historical data for {symbol} from {from_date} to {to_date}")
        
        data_args = {
            "symbol": symbol,
            "resolution": "1",
            "date_format": "1",
            "range_from": from_date,
            "range_to": to_date,
            "cont_flag": "1"
        }
        
        response = fyers_client.history(data_args)
        
        if response and response.get('s') == 'ok' and 'candles' in response:
            candles = response['candles']
            logger.info(f"‚úÖ Received {len(candles)} candles for {symbol}")
            
            result = []
            
            for candle in candles:
                timestamp, open_price, high_price, low_price, close_price, volume = candle
                
                if timestamp > 10000000000:
                    timestamp = timestamp // 1000
                
                data_point = {
                    'symbol': symbol,
                    'ltp': float(close_price),
                    'open': float(open_price),
                    'high': float(high_price),
                    'low': float(low_price),
                    'close': float(close_price),
                    'volume': int(volume),
                    'timestamp': timestamp,
                    'change': 0,
                    'changePercent': 0
                }
                
                result.append(data_point)
            
            # Calculate change and change percent
            if result:
                prev_close = result[0]['open']
                for point in result:
                    point['change'] = point['ltp'] - prev_close
                    point['changePercent'] = (point['change'] / prev_close) * 100 if prev_close else 0
            
            return result
        else:
            error_msg = response.get('message', 'Unknown error') if response else 'No response'
            error_code = response.get('code') if response else 'No code'
            logger.error(f"‚ùå API error for {symbol}: Code={error_code}, Message={error_msg}")
        
        return []
        
    except Exception as e:
        logger.error(f"‚ùå Error fetching historical data for {symbol}: {e}")
        import traceback
        traceback.print_exc()
        return []


def onmessage(message):
    """Handle incoming Fyers WebSocket messages."""
    try:
        # Skip system messages
        if isinstance(message, dict) and message.get('type') == 'sub':
            logger.info(f"üì° Subscription confirmation: {message}")
            return
        
        if isinstance(message, dict) and message.get('type') in ['cn', 'ful']:
            logger.info(f"üì° Connection message: {message}")
            return
        
        # Process market data
        if isinstance(message, dict) and 'symbol' in message:
            symbol = message['symbol']
            
            # Only process if symbol is actively subscribed
            if symbol not in active_subscriptions:
                return
            
            current_time = message.get('last_traded_time') or int(time.time())
            
            # FIXED: Prepare enhanced market data
            simplified_data = {
                'symbol': symbol,
                'ltp': float(message.get('ltp', 0)),
                'change': float(message.get('ch', 0)),
                'changePercent': float(message.get('chp', 0)),
                'open': float(message.get('open_price', 0)),
                'high': float(message.get('high_price', 0)),
                'low': float(message.get('low_price', 0)),
                'close': float(message.get('prev_close_price', 0)),
                'volume': int(message.get('vol_traded_today', 0)),
                'bid': float(message.get('bid_price', 0)),
                'ask': float(message.get('ask_price', 0)),
                'timestamp': current_time
            }
            
            # Store real-time data
            real_time_data[symbol] = simplified_data
            
            # Store historical data
            if symbol not in historical_data:
                historical_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)
            
            historical_data[symbol].append(simplified_data)
            
            # Save to file if needed
            save_to_file(symbol, simplified_data)
            
            # FIXED: Emit to subscribed clients only
            if symbol in symbol_to_clients:
                for sid in symbol_to_clients[symbol]:
                    try:
                        sio.emit('marketData', simplified_data, room=sid)
                    except Exception as e:
                        logger.error(f"‚ùå Error sending data to client {sid}: {e}")
            
            logger.debug(f"üìà Processed market data for {symbol}: LTP={simplified_data['ltp']}")
            
    except Exception as e:
        logger.error(f"‚ùå Error processing message: {e}")
        import traceback
        traceback.print_exc()


def save_to_file(symbol, data):
    """Save market data to daily files."""
    try:
        exchange, company_code = safe_symbol_parse(symbol)
        
        if exchange and company_code:
            now = datetime.datetime.now(INDIA_TZ)
            folder = f"LD_{now.strftime('%d-%m-%Y')}"
            os.makedirs(folder, exist_ok=True)
            file_name = f"{company_code}-{exchange}.json"
            file_path = os.path.join(folder, file_name)
            
            with open(file_path, 'a') as f:
                json.dump(data, f)
                f.write('\n')
                
    except Exception as e:
        logger.error(f"‚ùå Error saving to file: {e}")


def onopen():
    """Handle Fyers WebSocket connection opening."""
    logger.info("‚úÖ Fyers WebSocket connected")
    sio.emit('fyersConnected', {'status': 'connected'})
    
    # Subscribe to active symbols if any
    if active_subscriptions and fyers and hasattr(fyers, 'subscribe'):
        try:
            symbols_list = list(active_subscriptions)
            fyers.subscribe(symbols=symbols_list, data_type="SymbolUpdate")
            logger.info(f"üì° Subscribed to {len(symbols_list)} symbols on reconnection")
        except Exception as e:
            logger.error(f"‚ùå Error subscribing on open: {e}")


def onerror(error):
    """Handle Fyers WebSocket errors."""
    logger.error(f"‚ùå Fyers WebSocket Error: {error}")
    sio.emit('fyersError', {'message': str(error)})


def onclose(message):
    """Handle Fyers WebSocket connection closure."""
    logger.info(f"‚ùå Fyers WebSocket Connection closed: {message}")
    sio.emit('fyersDisconnected', {'message': str(message)})


def heartbeat_task():
    """Send periodic heartbeat to clients."""
    global running
    while running:
        try:
            heartbeat_data = {
                'timestamp': int(time.time()),
                'trading_active': is_trading_hours(),
                'active_subscriptions': len(active_subscriptions),
                'connected_clients': len(clients),
                'server_status': 'healthy',
                'auth_status': auth_initialized
            }
            sio.emit('heartbeat', heartbeat_data)
            time.sleep(30)  # Send heartbeat every 30 seconds
        except Exception as e:
            logger.error(f"‚ùå Error in heartbeat: {e}")
            time.sleep(30)


def main_process():
    """Main process to authenticate and start WebSocket connection."""
    global fyers, fyers_client, running
    
    # Load available symbols (optional, may result in empty list)
    load_available_symbols()
    
    # No preloading of historical data - completely on-demand
    logger.info("üöÄ Backend initialized in dynamic mode - no preloading")
    
    try:
        # Create data directory
        os.makedirs('data', exist_ok=True)
        
        # Try initial authentication
        if initialize_fyers():
            logger.info("‚úÖ Initial authentication successful")
            
            if fyers:
                ws_thread = threading.Thread(target=lambda: fyers.connect(), daemon=True)
                ws_thread.start()
                logger.info("‚úÖ WebSocket connection started")
        else:
            logger.info("‚ö†Ô∏è Initial authentication failed, will retry when auth file updates")
        
        # Start auth watcher
        auth_thread = threading.Thread(target=auth_watcher, daemon=True)
        auth_thread.start()
        
        # Start heartbeat task
        heartbeat_thread = threading.Thread(target=heartbeat_task, daemon=True)
        heartbeat_thread.start()
        
        # Start server
        logger.info("üöÄ Starting Live Market Server on port 5010...")
        logger.info("üîë Using auto authentication with JWT token handling")
        logger.info("üì° Features: Dynamic symbol loading, on-demand data fetching")
        eventlet.wsgi.server(eventlet.listen(('0.0.0.0', 5010)), app)
        
    except Exception as e:
        logger.error(f"‚ùå Error in main process: {e}")
        import traceback
        traceback.print_exc()


def main():
    global running
    try:
        eventlet.spawn(main_process)
        while running:
            time.sleep(1)
    except KeyboardInterrupt:
        logger.info("üõë Shutting down...")
        running = False


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logger.info("üõë Shutting down...")
        running = False


================================================================================
FILE 37/37: apps/backend/multi_company_live_data.py
CATEGORY: Python Services - Multi-Company Data
PURPOSE: Multi-company live data fetching service
PRIORITY: ?? PYTHON SERVICE
================================================================================

import eventlet
eventlet.monkey_patch()

import socketio
import json
import sys
import time
import datetime
import pytz
import threading
import logging
import requests
import numpy as np
import os
from collections import deque
from fyers_apiv3 import fyersModel
from fyers_apiv3.FyersWebsocket import data_ws
import pandas as pd

# Enhanced logging configuration
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("LiveMarketServer")

# Socket.IO setup with enhanced CORS
sio = socketio.Server(
    cors_allowed_origins='*', 
    async_mode='eventlet',
    logger=True,
    engineio_logger=True
)
app = socketio.WSGIApp(sio)

# Fyers API credentials
client_id = "150HUKJSWG-100"
secret_key = "18YYNXCAS7"
redirect_uri = "https://daksphere.com/"
response_type = "code"
grant_type = "authorization_code"

# Global variables
clients = {}
symbol_to_clients = {}
active_subscriptions = set()
running = True
historical_data = {}
ohlc_data = {}
real_time_data = {}
MAX_HISTORY_POINTS = 10000
MAX_COMPANIES = 6
INDIA_TZ = pytz.timezone('Asia/Kolkata')
fyers = None
fyers_client = None
available_symbols = []
last_tick = {}

MONITORED_FIELDS = [
    'ltp', 'vol_traded_today', 'last_traded_time', 'bid_size', 'ask_size',
    'bid_price', 'ask_price', 'low_price', 'high_price', 'open_price', 'prev_close_price'
]

def load_available_symbols():
    """Load available symbols from watchlist A - optional, fallback to empty."""
    global available_symbols
    try:
        csv_path = os.path.join(os.path.dirname(__file__), 'data', 'watchlists', 'watchlist_A_2025-02-16.csv')
        
        # Try alternative paths if main path doesn't exist
        if not os.path.exists(csv_path):
            csv_path = 'apps/backend/data/watchlists/watchlist_A_2025-02-16.csv'
        
        if not os.path.exists(csv_path):
            # No hardcoded symbols - completely dynamic
            logger.info("No watchlist file found - operating in dynamic mode")
            available_symbols = []
            return True
        else:
            df = pd.read_csv(csv_path)
        
        available_symbols = []
        for _, row in df.iterrows():
            symbol_data = {
                'symbol': f"{row.get('Exchange', 'NSE')}:{row['company_code']}-{row.get('marker', 'EQ')}",
                'company_code': row['company_code'],
                'name': row.get('name', row['company_code']),
                'exchange': row.get('Exchange', 'NSE'),
                'marker': row.get('marker', 'EQ')
            }
            available_symbols.append(symbol_data)
        
        logger.info(f"Loaded {len(available_symbols)} available symbols from watchlist")
        return True
        
    except Exception as e:
        logger.error(f"Error loading symbols: {e}")
        # No fallback symbols - completely empty
        available_symbols = []
        logger.info("Operating in fully dynamic mode - no predefined symbols")
        return True

def get_trading_hours():
    """Get market trading hours in IST."""
    now = datetime.datetime.now(INDIA_TZ)
    start_time = now.replace(hour=9, minute=15, second=0, microsecond=0)
    end_time = now.replace(hour=15, minute=30, second=0, microsecond=0)
    return start_time, end_time

def is_trading_hours():
    """Check if current time is within trading hours."""
    now = datetime.datetime.now(INDIA_TZ)
    start_time, end_time = get_trading_hours()
    if now.weekday() >= 5:  # Saturday or Sunday
        return False
    return start_time <= now <= end_time

def safe_symbol_parse(symbol):
    """Safely parse symbol string to extract exchange and company code."""
    try:
        if ':' not in symbol:
            logger.warning(f"Invalid symbol format (no colon): {symbol}")
            return None, None
        
        parts = symbol.split(':', 1)
        if len(parts) != 2:
            logger.warning(f"Invalid symbol format: {symbol}")
            return None, None
            
        exchange = parts[0]
        code_part = parts[1]
        
        if '-' not in code_part:
            logger.warning(f"Invalid code part (no hyphen): {code_part}")
            return exchange, code_part
        
        company_code = code_part.split('-')[0]
        return exchange, company_code
        
    except Exception as e:
        logger.error(f"Error parsing symbol {symbol}: {e}")
        return None, None

def create_symbol_from_code(company_code, exchange='NSE', marker='EQ'):
    """Create a full Fyers symbol from company code."""
    return f"{exchange}:{company_code}-{marker}"

def add_symbol_to_available(company_code, exchange='NSE', marker='EQ', name=None):
    """Dynamically add a symbol to available symbols if not exists."""
    global available_symbols
    
    symbol = create_symbol_from_code(company_code, exchange, marker)
    
    # Check if symbol already exists
    existing = next((s for s in available_symbols if s['symbol'] == symbol), None)
    if not existing:
        symbol_data = {
            'symbol': symbol,
            'company_code': company_code,
            'name': name or company_code,
            'exchange': exchange,
            'marker': marker
        }
        available_symbols.append(symbol_data)
        logger.info(f"Dynamically added symbol: {symbol}")
        return symbol_data
    return existing

@sio.event
def connect(sid, environ):
    """Handle client connection."""
    logger.info(f"Client connected: {sid}")
    clients[sid] = {
        'subscriptions': set(),
        'connected_at': datetime.datetime.now(INDIA_TZ),
        'last_activity': datetime.datetime.now(INDIA_TZ)
    }
    
    # Send available symbols to client (may be empty initially)
    sio.emit('availableSymbols', {
        'symbols': available_symbols,
        'maxCompanies': MAX_COMPANIES,
        'tradingHours': {
            'isActive': is_trading_hours(),
            'start': get_trading_hours()[0].isoformat(),
            'end': get_trading_hours()[1].isoformat()
        }
    }, room=sid)

@sio.event
def disconnect(sid):
    """Handle client disconnection."""
    logger.info(f"Client disconnected: {sid}")
    if sid in clients:
        # Clean up subscriptions
        for symbol in clients[sid]['subscriptions']:
            if symbol in symbol_to_clients:
                symbol_to_clients[symbol].discard(sid)
                
                # If no more clients for this symbol, unsubscribe from Fyers
                if not symbol_to_clients[symbol]:
                    active_subscriptions.discard(symbol)
                    logger.info(f"Removed {symbol} from active subscriptions")
        
        del clients[sid]
    
    # Update Fyers subscription if needed
    update_fyers_subscription()

@sio.event
def subscribe_companies(sid, data):
    """FIXED: Subscribe to selected companies with enhanced validation."""
    try:
        logger.info(f"üì° Received subscription request from {sid}: {data}")
        
        # FIXED: Extract companyCodes from data
        company_codes = data.get('companyCodes', [])
        logger.info(f"üì° Raw company codes: {company_codes}")
        
        # FIXED: Validate data structure
        if not isinstance(company_codes, list):
            logger.error(f"‚ùå Invalid data type for companyCodes: {type(company_codes)}")
            sio.emit('error', {'message': 'companyCodes must be an array'}, room=sid)
            return
        
        # FIXED: Simplified validation - accept any non-empty string
        valid_company_codes = []
        for code in company_codes:
            if isinstance(code, str) and code.strip():
                valid_company_codes.append(code.strip().upper())
            else:
                logger.warning(f"‚ö†Ô∏è Skipping invalid company code: {code}")
        
        logger.info(f"‚úÖ Valid company codes after filtering: {valid_company_codes}")
        
        # FIXED: Check limits
        if len(valid_company_codes) > MAX_COMPANIES:
            logger.error(f"‚ùå Too many companies requested: {len(valid_company_codes)}")
            sio.emit('error', {'message': f'Maximum {MAX_COMPANIES} companies allowed'}, room=sid)
            return
        
        if len(valid_company_codes) == 0:
            logger.error(f"‚ùå No valid company codes provided")
            sio.emit('error', {'message': 'At least 1 valid company code must be provided'}, room=sid)
            return
        
        # FIXED: Clear existing subscriptions for this client
        if sid in clients:
            for symbol in clients[sid]['subscriptions']:
                if symbol in symbol_to_clients:
                    symbol_to_clients[symbol].discard(sid)
                    if not symbol_to_clients[symbol]:
                        active_subscriptions.discard(symbol)
            clients[sid]['subscriptions'].clear()
        
        # FIXED: Process valid company codes and create symbols
        requested_symbols = []
        for company_code in valid_company_codes:
            logger.info(f"üì° Processing company code: {company_code}")
            
            # Try to find in existing available symbols
            symbol_data = next(
                (s for s in available_symbols if s['company_code'] == company_code),
                None
            )
            
            if symbol_data:
                requested_symbols.append(symbol_data['symbol'])
                logger.info(f"‚úÖ Found existing symbol for {company_code}: {symbol_data['symbol']}")
            else:
                # Dynamically create symbol
                new_symbol_data = add_symbol_to_available(company_code)
                requested_symbols.append(new_symbol_data['symbol'])
                logger.info(f"‚úÖ Dynamically created symbol for {company_code}: {new_symbol_data['symbol']}")
        
        logger.info(f"üì° Final requested symbols: {requested_symbols}")
        
        # FIXED: Update client subscriptions
        if sid not in clients:
            clients[sid] = {
                'subscriptions': set(),
                'connected_at': datetime.datetime.now(INDIA_TZ),
                'last_activity': datetime.datetime.now(INDIA_TZ)
            }
        
        # Add symbols to client subscriptions
        for symbol in requested_symbols:
            clients[sid]['subscriptions'].add(symbol)
            
            # Add to symbol_to_clients mapping
            if symbol not in symbol_to_clients:
                symbol_to_clients[symbol] = set()
            symbol_to_clients[symbol].add(sid)
            
            # Add to active subscriptions
            active_subscriptions.add(symbol)
            logger.info(f"‚úÖ Added {symbol} to active subscriptions")
        
        # FIXED: Update Fyers subscription
        update_fyers_subscription()
        
        # FIXED: Send historical data for each symbol
        for symbol in requested_symbols:
            # Send any existing historical data
            if symbol in historical_data and historical_data[symbol]:
                sio.emit('historicalData', {
                    'symbol': symbol,
                    'data': list(historical_data[symbol])
                }, room=sid)
            else:
                # Fetch historical data on demand
                logger.info(f"üìä Fetching historical data for {symbol}")
                hist_data = fetch_historical_intraday_data(symbol)
                if hist_data:
                    if symbol not in historical_data:
                        historical_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)
                    
                    for data_point in hist_data:
                        historical_data[symbol].append(data_point)
                    
                    sio.emit('historicalData', {
                        'symbol': symbol,
                        'data': hist_data
                    }, room=sid)
        
        # FIXED: Send subscription confirmation
        sio.emit('subscriptionConfirm', {
            'success': True,
            'symbols': requested_symbols,
            'count': len(requested_symbols)
        }, room=sid)
        
        logger.info(f"‚úÖ Successfully subscribed client {sid} to {len(requested_symbols)} symbols")
        
    except Exception as e:
        logger.error(f"‚ùå Error in subscribe_companies: {e}")
        import traceback
        traceback.print_exc()
        sio.emit('error', {'message': f'Subscription failed: {str(e)}'}, room=sid)

@sio.event
def unsubscribe_all(sid, data):
    """Unsubscribe from all companies."""
    try:
        logger.info(f"üì° Unsubscribing all for client {sid}")
        
        if sid in clients:
            for symbol in clients[sid]['subscriptions']:
                if symbol in symbol_to_clients:
                    symbol_to_clients[symbol].discard(sid)
                    if not symbol_to_clients[symbol]:
                        active_subscriptions.discard(symbol)
            
            clients[sid]['subscriptions'].clear()
        
        update_fyers_subscription()
        
        sio.emit('subscriptionConfirm', {
            'success': True,
            'symbols': [],
            'count': 0
        }, room=sid)
        
        logger.info(f"‚úÖ Client {sid} unsubscribed from all symbols")
        
    except Exception as e:
        logger.error(f"‚ùå Error in unsubscribe_all: {e}")
        sio.emit('error', {'message': f'Unsubscription failed: {str(e)}'}, room=sid)

@sio.event
def get_market_status(sid, data):
    """Get current market status."""
    try:
        start_time, end_time = get_trading_hours()
        sio.emit('marketStatus', {
            'trading_active': is_trading_hours(),
            'trading_start': start_time.isoformat(),
            'trading_end': end_time.isoformat(),
            'current_time': datetime.datetime.now(INDIA_TZ).isoformat(),
            'is_market_day': datetime.datetime.now(INDIA_TZ).weekday() < 5,
            'active_subscriptions': len(active_subscriptions),
            'connected_clients': len(clients)
        }, room=sid)
    except Exception as e:
        logger.error(f"‚ùå Error in get_market_status: {e}")
        sio.emit('error', {'message': f'Failed to get market status: {str(e)}'}, room=sid)

def update_fyers_subscription():
    """Update Fyers WebSocket subscription based on active subscriptions."""
    if not fyers:
        logger.warning("Fyers not initialized, cannot update subscription")
        return
    
    try:
        current_symbols = list(active_subscriptions)
        if current_symbols:
            logger.info(f"üîÑ Updating Fyers subscription with {len(current_symbols)} symbols")
            fyers.subscribe(symbols=current_symbols, data_type="SymbolUpdate")
            logger.info(f"‚úÖ Updated Fyers subscription: {current_symbols}")
        else:
            logger.info("üì° No active subscriptions, keeping minimal connection")
    except Exception as e:
        logger.error(f"‚ùå Error updating Fyers subscription: {e}")

def fetch_historical_intraday_data(symbol, date=None):
    """Fetch historical intraday data for a symbol on demand."""
    if not date:
        date = datetime.datetime.now(INDIA_TZ).strftime('%Y-%m-%d')
    
    try:
        date_obj = datetime.datetime.strptime(date, '%Y-%m-%d')
        date_obj = INDIA_TZ.localize(date_obj)
        
        market_open = date_obj.replace(hour=9, minute=15, second=0, microsecond=0)
        market_close = date_obj.replace(hour=15, minute=30, second=0, microsecond=0)
        
        now = datetime.datetime.now(INDIA_TZ)
        if date == now.strftime('%Y-%m-%d') and now < market_open:
            logger.info(f"Market not yet open for {date}")
            return []
        
        end_time = min(now, market_close) if date == now.strftime('%Y-%m-%d') else market_close
        
        from_date = market_open.strftime('%Y-%m-%d %H:%M:%S')
        to_date = end_time.strftime('%Y-%m-%d %H:%M:%S')
        
        logger.info(f"üìä Fetching historical data for {symbol} from {from_date} to {to_date}")
        
        if fyers_client:
            data_args = {
                "symbol": symbol,
                "resolution": "1",
                "date_format": "1",
                "range_from": from_date,
                "range_to": to_date,
                "cont_flag": "1"
            }
            
            response = fyers_client.history(data_args)
            
            if response and response.get('s') == 'ok' and 'candles' in response:
                candles = response['candles']
                logger.info(f"‚úÖ Received {len(candles)} candles for {symbol}")
                
                result = []
                
                for candle in candles:
                    timestamp, open_price, high_price, low_price, close_price, volume = candle
                    
                    if timestamp > 10000000000:
                        timestamp = timestamp // 1000
                    
                    data_point = {
                        'symbol': symbol,
                        'ltp': close_price,
                        'open': open_price,
                        'high': high_price,
                        'low': low_price,
                        'close': close_price,
                        'volume': volume,
                        'timestamp': timestamp,
                        'change': 0,
                        'changePercent': 0
                    }
                    
                    result.append(data_point)
                
                # Calculate change and change percent
                if result:
                    prev_close = result[0]['open']
                    for point in result:
                        point['change'] = point['ltp'] - prev_close
                        point['changePercent'] = (point['change'] / prev_close) * 100 if prev_close else 0
                
                return result
            else:
                logger.error(f"‚ùå Failed to fetch historical data for {symbol}: {response}")
        
        return []
        
    except Exception as e:
        logger.error(f"‚ùå Error fetching historical data for {symbol}: {e}")
        return []

def onmessage(message):
    """Handle incoming Fyers WebSocket messages."""
    try:
        # Skip system messages
        if isinstance(message, dict) and message.get('type') == 'sub':
            logger.info(f"üì° Subscription confirmation: {message}")
            return
        
        if isinstance(message, dict) and message.get('type') in ['cn', 'ful']:
            logger.info(f"üì° Connection message: {message}")
            return
        
        # Process market data
        if isinstance(message, dict) and 'symbol' in message:
            symbol = message['symbol']
            
            # Only process if symbol is actively subscribed
            if symbol not in active_subscriptions:
                return
            
            # FIXED: Prepare enhanced market data
            simplified_data = {
                'symbol': symbol,
                'ltp': message.get('ltp'),
                'change': message.get('ch'),
                'changePercent': message.get('chp'),
                'open': message.get('open_price'),
                'high': message.get('high_price'),
                'low': message.get('low_price'),
                'close': message.get('prev_close_price'),
                'volume': message.get('vol_traded_today'),
                'bid': message.get('bid_price'),
                'ask': message.get('ask_price'),
                'timestamp': message.get('last_traded_time') or int(time.time())
            }
            
            # Store real-time data
            real_time_data[symbol] = simplified_data
            
            # Store historical data
            if symbol not in historical_data:
                historical_data[symbol] = deque(maxlen=MAX_HISTORY_POINTS)
            
            historical_data[symbol].append(simplified_data)
            
            # FIXED: Emit to subscribed clients only
            if symbol in symbol_to_clients:
                for sid in symbol_to_clients[symbol]:
                    try:
                        sio.emit('marketData', simplified_data, room=sid)
                    except Exception as e:
                        logger.error(f"‚ùå Error sending data to client {sid}: {e}")
            
            logger.debug(f"üìà Processed market data for {symbol}: LTP={simplified_data['ltp']}")
            
    except Exception as e:
        logger.error(f"‚ùå Error processing message: {e}")

def save_to_file(symbol, data):
    """Save market data to daily files."""
    try:
        exchange, company_code = safe_symbol_parse(symbol)
        
        if exchange and company_code:
            now = datetime.datetime.now(INDIA_TZ)
            folder = f"LD_{now.strftime('%d-%m-%Y')}"
            os.makedirs(folder, exist_ok=True)
            file_name = f"{company_code}-{exchange}.json"
            file_path = os.path.join(folder, file_name)
            
            with open(file_path, 'a') as f:
                json.dump(data, f)
                f.write('\n')
                
    except Exception as e:
        logger.error(f"‚ùå Error saving to file: {e}")

def onopen():
    """Handle Fyers WebSocket connection opening."""
    logger.info("‚úÖ Fyers WebSocket connected")
    sio.emit('fyersConnected', {'status': 'connected'})
    
    # No default subscriptions - wait for client requests
    logger.info("üì° Fyers connection established, ready for dynamic subscriptions")

def onerror(error):
    """Handle Fyers WebSocket errors."""
    logger.error(f"‚ùå Fyers WebSocket Error: {error}")
    sio.emit('fyersError', {'message': str(error)})

def onclose(message):
    """Handle Fyers WebSocket connection closure."""
    logger.info(f"‚ùå Fyers WebSocket Connection closed: {message}")
    sio.emit('fyersDisconnected', {'message': str(message)})

def heartbeat_task():
    """Send periodic heartbeat to clients."""
    global running
    while running:
        try:
            heartbeat_data = {
                'timestamp': int(time.time()),
                'trading_active': is_trading_hours(),
                'active_subscriptions': len(active_subscriptions),
                'connected_clients': len(clients),
                'server_status': 'healthy'
            }
            sio.emit('heartbeat', heartbeat_data)
            time.sleep(30)  # Send heartbeat every 30 seconds
        except Exception as e:
            logger.error(f"‚ùå Error in heartbeat: {e}")
            time.sleep(30)

def main_process():
    """Main process to authenticate and start WebSocket connection."""
    global fyers, fyers_client, running
    
    # Load available symbols (optional, may result in empty list)
    load_available_symbols()
    
    # No preloading of historical data - completely on-demand
    logger.info("üöÄ Backend initialized in dynamic mode - no preloading")
    
    try:
        # Fyers Authentication
        session = fyersModel.SessionModel(
            client_id=client_id,
            secret_key=secret_key,
            redirect_uri=redirect_uri,
            response_type=response_type,
            grant_type=grant_type
        )
        
        auth_url = session.generate_authcode()
        logger.info("\n==== Fyers Authentication ====")
        logger.info("Open this URL in your browser and log in:")
        logger.info(auth_url)
        
        auth_code = input("\nEnter Auth Code: ")
        session.set_token(auth_code)
        token_response = session.generate_token()
        
        if token_response.get('s') != 'ok':
            logger.error(f"‚ùå Authentication failed: {token_response}")
            return
        
        logger.info("‚úÖ Authentication successful!")
        access_token = f"{client_id}:{token_response['access_token']}"
        
        fyers_client = fyersModel.FyersModel(
            client_id=client_id,
            token=token_response['access_token'],
            log_path=""
        )
        
        fyers = data_ws.FyersDataSocket(
            access_token=access_token,
            log_path="",
            litemode=False,
            write_to_file=False,
            reconnect=True,
            on_connect=onopen,
            on_close=onclose,
            on_error=onerror,
            on_message=onmessage
        )
        
        # Start heartbeat task
        heartbeat_thread = threading.Thread(target=heartbeat_task, daemon=True)
        heartbeat_thread.start()
        
        # Connect to Fyers
        fyers.connect()
        logger.info("‚úÖ Connected to Fyers WebSocket")
        
        # Start server
        logger.info("üöÄ Starting Live Market Server on port 5010...")
        eventlet.wsgi.server(eventlet.listen(('0.0.0.0', 5010)), app)
        
    except Exception as e:
        logger.error(f"‚ùå Error in main process: {e}")
        import traceback
        traceback.print_exc()

def main():
    global running
    try:
        eventlet.spawn(main_process)
        while running:
            time.sleep(1)
    except KeyboardInterrupt:
        logger.info("üõë Shutting down...")
        running = False

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logger.info("üõë Shutting down...")
        running = False


################################################################################
END OF APM-TOP-K-STOCKS PROJECT EXTRACTION
################################################################################

EXTRACTION SUMMARY:
===================
?? CRITICAL FILES:
   Section 1: Frontend Files - 8 files
   Section 2: Backend Files - 5 files
   Section 3: Configuration Files - 3 files
   Subtotal: 16 files

?? IMPORTANT FILES:
   Section 4: Chart Components - 4 files
   Section 5: Data Management - 3 files
   Section 6: Layout and UI - 4 files
   Subtotal: 11 files

?? OPTIONAL FILES:
   Section 7: Reference Files - 6 files
   Subtotal: 6 files

?? PYTHON SERVICE FILES:
   Section 8: Python Services - 4 files
   Subtotal: 4 files

================================================================================
TOTAL FILES PROCESSED: 37 FILES
================================================================================

PROJECT: APM-TOP-K-STOCKS
DESCRIPTION: Stock Market Analytics and Real-time Trading Dashboard
TECHNOLOGY STACK:
- Frontend: Next.js 15 + React 19 + TypeScript + Tailwind CSS
- Backend: NestJS + TypeScript + PostgreSQL + TypeORM
- Real-time: Socket.IO + WebSocket
- Charts: Plotly.js + ApexCharts + Syncfusion + Financial Charts
- Python: Data Fetching + ML/AI Pattern Discovery
- External APIs: Fyers API Integration

FILE ORGANIZATION:
- Core application code extracted
- Configuration files included
- Chart components documented
- Data management layer captured
- UI components extracted
- Python services included

NEXT STEPS:
1. Review extracted files in APM_TOP_K_STOCKS_complete_extraction.txt
2. Check error log for any missing files: APM_TOP_K_STOCKS_extraction_errors.log
3. Implement required features based on extracted code
4. Test integration with Python services
5. Deploy using Docker Compose

################################################################################
